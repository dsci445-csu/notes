<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Chapter 8: Tree-Based Methods" />






<meta name="description" content="Chapter 8: Tree-Based Methods">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","output":{"pagedown::html_paged":{"self_contained":true,"css":["../style/my-style-page.css","default-fonts","default-page","default"],"number_sections":true}},"title":"Chapter 8: Tree-Based Methods"}
</script>

<title>Chapter 8: Tree-Based Methods</title>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  let beforePaged = PagedConfig.before;
  window.PagedConfig.before = async () => {
    if (beforePaged) await beforePaged();
    return new Promise((resolve, reject) => {
      var script = document.createElement("script");
      script.type = "text/javascript";
      var src = `https://mathjax.rstudio.com/latest/MathJax.js` + "?config=TeX-MML-AM_CHTML";
      if (location.protocol !== "file:" && /^https?:/.test(src))
        src = src.replace(/^https?:/, '');
      script.src = src;
      window.MathJax = {
        AuthorInit: () => {
          MathJax.Hub.Register.StartupHook("Begin", () => {
            MathJax.Hub.Queue(resolve);
          });
        }
      };
      document.getElementsByTagName("head")[0].appendChild(script);
    });
  };
})();
</script>

<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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IC5HI0cjYSBgsCBgZrACYiCwAFBYsEBgWWawAWMjICA8ijgtsD4sIyAuRrACJUawEENYUBtSWVggPFkusS4BFCstsD8sIyAuRrACJUawEENYUhtQWVggPFkusS4BFCstsEAsIyAuRrACJUawEENYUBtSWVggPFkjIC5GsAIlRrAQQ1hSG1BZWCA8WS6xLgEUKy2wQSywOCsjIC5GsAIlRrAQQ1hQG1JZWCA8WS6xLgEUKy2wQiywOSuKICA8sAQjQoo4IyAuRrACJUawEENYUBtSWVggPFkusS4BFCuwBEMusC4rLbBDLLAAFrAEJbAEJiAuRyNHI2GwCUMrIyA8IC4jOLEuARQrLbBELLEIBCVCsAAWsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgR7AEQ7ACYiCwAFBYsEBgWWawAWNgILABKyCKimEgsAJDYGQjsANDYWRQWLACQ2EbsANDYFmwAyWwAmIgsABQWLBAYFlmsAFjYbACJUZhOCMgPCM4GyEgIEYjR7ABKyNhOCFZsS4BFCstsEUssQA4Ky6xLgEUKy2wRiyxADkrISMgIDywBCNCIzixLgEUK7AEQy6wListsEcssAAVIEewACNCsgABARUUEy6wNCotsEgssAAVIEewACNCsgABARUUEy6wNCotsEkssQABFBOwNSotsEossDcqLbBLLLAAFkUjIC4gRoojYTixLgEUKy2wTCywCCNCsEsrLbBNLLIAAEQrLbBOLLIAAUQrLbBPLLIBAEQrLbBQLLIBAUQrLbBRLLIAAEUrLbBSLLIAAUUrLbBTLLIBAEUrLbBULLIBAUUrLbBVLLMAAABBKy2wViyzAAEAQSstsFcsswEAAEErLbBYLLMBAQBBKy2wWSyzAAABQSstsFosswABAUErLbBbLLMBAAFBKy2wXCyzAQEBQSstsF0ssgAAQystsF4ssgABQystsF8ssgEAQystsGAssgEBQystsGEssgAARistsGIssgABRistsGMssgEARistsGQssgEBRistsGUsswAAAEIrLbBmLLMAAQBCKy2wZyyzAQAAQistsGgsswEBAEIrLbBpLLMAAAFCKy2waiyzAAEBQistsGssswEAAUIrLbBsLLMBAQFCKy2wbSyxADorLrEuARQrLbBuLLEAOiuw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) format('truetype');
}
body {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;
}
blockquote {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '楷体', 'SimKai', 'DFKai-SB', 'NSimSun', serif;
}
code {
font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;
}
pre, code {
font-size: .95em;
}
</style>
<style type="text/css">
@page {
size: 6in 9in; 
}
@page :blank {
}

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: counter(page);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: counter(page);
}
@top-left {
content: element(runningH2Title);
white-space: nowrap !important;
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
background-image: var(--front-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.front-cover {
break-after: recto;
}

.front-page {
counter-reset: page 1;
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:right {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.back-cover {
break-before: verso;
}
.pagedjs_page:nth-last-of-type(1) {
background-image: var(--back-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.level1 {
break-before: recto;
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

.main .level1:first-child h1 {
counter-reset: page 1;
}

caption {
break-inside: avoid;
break-after: avoid;
}
</style>
<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: hidden;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>




<style type="text/css">@page {
size: 8.5in 11in; 
}
@page :blank {
}
.pagedjs_page {
--pagedjs-pagebox-width: 8.5in;
--pagedjs-pagebox-height: 11in;
}
.level1 {
break-before: avoid;
}
.red {
color: red;
}
.hidden {
color: transparent;
font-size: 0;
}
.yourturn {
color: blue;
font-size: 2em;
}
.pagebreak {
break-after: always;
}</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Chapter 8: Tree-Based Methods</h1>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p>We will introduce <em>tree-based</em> methods for regression and classification.</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>The set of splitting rules can be summarized in a tree <span class="math inline">\(\Rightarrow\)</span> “decision trees”.</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>Combining a large number of trees can often result in dramatic improvements in prediction accuracy at the expense of interpretation.</p>
<p><img src="data:image/gif;base64,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" /></p>
<p>Credit: <a href="http://phdcomics.com/comics.php?f=852" class="uri">http://phdcomics.com/comics.php?f=852</a></p>
<p>Decision trees can be applied to both regression and classification problems. We will start with regression.</p>
<div id="regression-trees" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Regression Trees</h1>
<p><strong>Example:</strong> We want to predict baseball salaries using the <code>Hittters</code> data set based on <code>Years</code> (the number of years that a player has been in the major leagues) and <code>Hits</code> (the number of hits he made the previous year).</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p><img src="data:image/png;base64,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5cuXD9uRe/bskXHjxsn3338vmzdvlho1asipp54qF110keTLly9hx4Q9ERsRQAABBBBAAAEEEEAAAQQQQAABBBBAIGkCgUqA6srKTz75pOzatctJXJYtW1Zmz54t3333nXz44Yfyz3/+U5o3b54Nc8uWLdK9e3f5448/nO1lypSRSZMmOf+++eYbeeSRR6RgwYK5PibbCfgBAQTiEli3bp1MnDhRli5dKkcccYScdtpp0qxZs8Meo3GdnIMQQAABBBDwUGDZsmXy2WefyapVq6REiRLSsGFD51+ePHk8rAWXQgABBBBAAAEEMkMgMAlQffHoJj9vvPFG6dChgxQqVEh0dOfo0aOdf0899ZTUrFlTjjnmmKzeffzxx53k51lnnSUPPfSQlCxZ0nkhqis1T58+XQYPHiy9evXKitdv4jkm2wn4AQEErAT279/vrJ4+cOBA2bdvX7Zjq1SpIkOHDpWWLVtm284PCCCAAAII+FFg69atctttt8mbb755WPX0DqThw4fLGWeccdg+NiCAAAIIIIAAAgjELxCYOUA/+ugjZ+Tn+eefL507d3aSn8qiSdCuXbtK06ZNZffu3aJxbvnpp5+c0aGFCxeWvn37OslP3Xf00UfLgAEDnFGkOtps+/bt7iESzzFZB/MNAghYCxw4cEAuvfRS6d+//2HJTz3ZihUrpHXr1s6HHNYn5wAEEEAAAQQ8FNi2bZs0atQobPJTqzF37lxn/9dff+1hrbgUAggggAACCCAQfIHAJEB/+OEHp7caN24cttd0hKeW3377LWu/3jKvpUmTJs7ttM4P//1Pb4WvX7++7N2717nl1t0XzzHusXxFAAF7Af0w4pNPPol64KFDh5wPOvR2QgoCCCCAAAJ+Fbj99ttlwYIFUaunH9i3b99edu7cGTWOnQgggAACCCCAAALmAoFJgOqt6v/617/k7LPPDtv6TZs2OdtLlSqVtX/hwoXO925yNGvHf7/RBKiWH3/88b9bROI5JutgvkEAASsBHf359NNPGx2jH1Y899xzRrEEIYAAAggg4LWATtc0atQoo8uuXr1aXn/9daNYghBAAAEEEEAAAQRiCwRmDlC91b1SpUphW6zzB+qt7FpOOumkrBh9IaolNCmatTNku7tAku6L55jQc7rfd+rUSXQBpnBFJ8LXxM/69euz7dZtbtHV7pkk39UI1le3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BQl79OghdevWlWbNmsmSJUv8W/k0r5k+j95+++1GrXjjjTdk5syZRrFeB1199dUyceJE53co57ULFCggOvJTk7j58uXLuZufEUAAAQQQQACBlAnkT9mVuXDgBXQ02MaNG43bqfEUBBDwl4Denvn+++8bV0rftDPqx5iLQAQ8FdC/yQ0aNJDFixeHva7euaFzNn799ddy4oknho1hY/wC//73v2XlypXGJ3jzzTed/jI+wMPACy+8UHSu92nTponO5b5r1y4nIarzQFeoUMHDmnApBBBAAAEEEEDATIAEqJkTUXEING3aVH755RejIwsVKiRnnXWWUSxBCCDgnYC+wTUZ/enWaMGCBc6tnbFuj3Tjvf6qt/m+8MILMn36dNGRcBUrVpTzzz/fWbCtatWqXlfH+nraF6+//rq8++67zvOrOmuiSkf0dezYkRFX1qKZdYDeVh0p+elKbN68Wdq3by/z5s3j98lFSdBXfX60KX6fliB//vzO86c+h1IQQAABBBBAAAG/C3ALvN97KI3rp7d5mSZBbr31VilatGgat5aqIxBMgf3791s17NChQ1HntrM6WYKDda7DU045RV599VVZtGiR6LQbmpB4/vnnnblLR40aleArJvZ0v//+u5x55pnO3IBffvml/Pnnn85oss8//1w6deok55xzjqxZsyaxF+VsgRH4+eefReefNCkLFy6UCRMmmIQSYyFg+3yqCyNREEAAAQQQQAABBBIjQAI0MY6cJYzACSecIM8++2yYPdk3aULi8ccfz76RnxAIqICOOtTklSYXvvnmG9m7d6+vW6rzudkU/dBDRwX5rWiSU+c61ARtuKL9oElEm9v9w50nWdu2bdsmesvpjz/+GPES3377rejCI3orqt/LX3/9JV988YW88847ztcdO3b4vcppX7/PPvvMqg228VYnz9Bg20XibOMzlJVmI5ByAZ1eROfF1b9pX331le9f26UcjAoggAACKRIgAZoi+Ey57J133inDhw+XEiVKhG3yZZdd5swfVaxYsbD72YhAUAR0gaDrrrvOueVab1XWRUfatm0rOvftE088IbYjg7xysU2mHTx4UPbs2eNV9YyuoyMldSEnk9K9e3dfJhCfeuopZ769WG2YO3euDBo0KFZYyvZr4vOuu+6SsmXLygUXXODcuq9fy5Ur5ywOQyI0eV2jI4htym+/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blJ0tO7TTz9tEkoMAgh4LKBToHz44YdGV120aFHEUaJGJyAorMCqVauc+arD7syx8c8//5RRo0bl2MqPCCCAAAIIIIAAAvEKkACNV47jEEgDAb393bToKNFp06aZhnsSN2fOHNm4caPxtT777DPjWALNBJYuXeqsZGoWLc4CSaaxxCGAgHcCts+PtvHetSR9r/TFF1+I3rFgWugDUyniEEAAAQQQQACB2AIkQGMbEYFA2groCBKbYhtvc+54Ym3ro6NrKIkVWL16tdUJdcTxnj17rI4hGAEEki9g+3xqG5/8FqT/FWyfT+mD9O9zWoAAAggggAAC/hEgAeqfvqAmCCRcoFSpUlbntI23OnkcwaVLl7Y6qkyZMlbxBMcWsP2dOOKII6RQoUKxT0wEAgh4KmD7fGob72lj0vRits+n9EGadjTVRgABBBBAAAFfCuT3Za2oFAIIJERAV5rVBY5Mi64866dyxhlnSP78+Y0X49B4P5fly5fLq6++6kw1oAuNVKpUSVq3bi033nijFC1a1JdVP+GEE0QTy5s2bTKqn/7OUZIrMHHiRHn33Xfll19+kbx588qJJ54o1157rTRv3jy5F+bsaS1g+/xuG5/WOB5V3tbUNt6jZnAZBBBAAAEEEEAgLQUYAZqW3UalETATuPnmmyVfvnxGwZqIq1q1qlGsV0FFihQRHVFoWooXL24a6nncoEGDpFatWqILCn3zzTeyYMEC0Tlae/bsKTVq1JAZM2Z4XieTC+rvT/fu3U1CnZjbbrvNOJZAOwFNQrdo0UIuueQSGT16tHz33Xcya9Ysee211+T888+Xyy67TLZv3253UqIzRuDcc8+VunXrGrVXRyp26NDBKJYgc4E6depIkyZNjA7Qv3033XSTUSxBCCCAAAIIIIAAArEFSIDGNiICgbQV0MSayQre5cuXlyFDhviunfPnz5cdO3YY12vu3LnGsV4GDh48WO644w7RlerDFZ0X7oILLhC/1v/++++X0047LVzVs23ThEnbtm2zbeOHxAjovKoXX3yxkzSPdMb333/f8d+/f3+kEN9s14VgdATrV1995Xy1WRjGL43YunWr85idPXu21WJtqaq/jhbWZLnJh0qvvPKK2N6unap2pdt11bZkyZIxq/3888/L0UcfHTOOAAQQQAABBBBAAAEzARKgZk5EIZC2Avfee68MHDgw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XUXEeVXkChKIUgKoK96gQQM5cOCA1xlcv35dOnXqJLly5ZLKlSt71eMKEiABEiABEiABEggnAUaAhpN2HO7r4Ycflg0bNqiIK/fpI1VqzJgxMmPGDPnPf/7jvprvg0AAUbi6gujPZs2a6apTjwRIgATiigCi3eAE9SdwgiKilUICsUhgypQpsnv3br9T++eff+S5557zq0cFEiABEiABEiABEggXAUaAhot0HO+naNGiKuJqz549snXrVrl06ZLkzJlTKlasKMmTJ49jMqGf+lNPPSWvvfaaHDlyxO/OoEchgXgigCgl0zIR8cSHc72RAEoo6Mq8efNU5gN/43SJJU0PzrabbuIz/aRR1Nt6zpw5eor/1UItUESK5smTR3sbKpIACZAACZAACZBAqAjwajFUZDluIgIFChRQ9d06d+4sNWrUoPMzEaHQLMANyL333utz8L59+wqOC4UEYp3AypUrVfomItBvueUWufvuu6VFixZs2hHrBz6J8/vtt9/k9OnT2qOg7MuxY8e09aloRgBp2BMmTFDNE2+77TZBPV842fBb5qtEgdleqO2JAOolm8jevXtN1KlLAiRAAiRAAiRAAiEjQAdoyNByYBKwg0CaNGnkxx9/FHS4hrPHKTeAG8YiRYrIpk2bVCMDO6ylFSQQGgKIEEOtYZTlWLBgQUIDm7NnzwoimtDQY9SoUaHZOUeNegLO96bJRALZxmT8eNU9efKkPPTQQ4IMhy1btgga7+D8Rr1rnMP58+dXpXfilU+o5236uTbVD7X9HJ8ESIAESIAESCB+CTAFPn6PPWduSOCnn36SN998U3744QfVQbpu3bpRVTMTHa7Z5drwoFM9EQFEtq1evVqlNcKJjo7YcEbYnn46ePBgeeuttxLNx1nw77//quixDBkySLt27ZzFVv6Fw2ft2rWqcz2cCwULFlSd1BHRSgkNAUQMZ86cWeB80xHUVM6ePbuOKnUMCCDyE42okNngTRABWqdOHaWDJjyU4BJANo9JNDT0bZbff/9dPRRDZ/uUKVNK1apVpVixYjabTNtIgARIgARIgAQCJMC7pQDBcbP4IQCHD7qjf/311zdMGs2bOnToIO+8846gkz2FBGKdwMSJE2XAgAFy/vz5G6Z63333KedizZo1b1huyxvUwH3llVe0zEHTjqZNm6qHHFobhFkJ3zu9e/dO5IBA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VK5Tp440bNhQli9fHnQEOOHGjRsXsD5i0IO5U4sAbqjgBN2xY4e89957cvbsWUFzBdSc1E2R15ooDEpDhw5VNp87dy7o6IjsQ01ECgnEIoH//ve/2suaP3++TJw4UVKnTq19DBVjn0Du3LmNFlmwYEEjfSrrE0B2BrIunn/+eVm0aJF6uHHNNddIjRo1BDXgbc5k0F8lNUmABEiABEiABHwJ0AHqS4O/u0oAF4+LFy9WDrhANdFwATp79my/kXGuGpOMwapWraoiA3RT0GrWrJmMWcJ/CPjCyRaokzfqfk6ePFlq164dfmM4g1SoUOFSnU84/7Nnz249lcKFC8uyZcukadOmgjRgf4II4pUrVwojlvzRcW8bShGgWRNSMw8dOqRu0lF24L777lORxKY1W92zLLZHgvP/66+/1l4kyl0gVR61Zikk4BBAKRQTMdU3GZu6/yMApzQe2KPuOwQPs+n8/B8b/k8CJEACJEACsUaAKfCxdkYtWw8uJDdt2qQ6/5YuXfqSdVmyZJH27dvLvn37VCfdSzss+gU2olmKjiDKp2vXrjqqnusghRkRh1OnTlXON6cLdoYMGdRFP2rVsfmL56cl6iZEVAya1yDCM1euXJfsh+PzxRdflI8//lgKFChwaTt/cZ8Amu6UL19eNeVAeubJkycFzXfwcAOfVSglcuLECfcn5ojy119/GVPQfXhmPDAPiFoCKPXTpEkTLfszZcqkfQ2iNSCVSIAESIAESIAESCDOCTACNM5fAF4sH85BdP7FP0QvoQmAjbUO/bEYPny4KpKPzr/BZPz48ZIvX75gKhHdh6iwjh07qn+4kUd0Em6uKCRgQuC6665TpRJQLuGXX35RzZFQS40SfgI///yz1KpVSz777LOAk3300UeqSQ9KLaRLly6gHneYE8ADMURr63blxvee7aUtzCnwCDcIoDQC3qvBmkTiQeXMmTMFrzsKCZAACZAACZAACZCAOwQYAeoOR46iSQApv9Hi/MSS4CREBGug7uhYzyuvvKIci5oIIq6GlHc6PyN+GqLegPTp0wudn96dRtRhDeb8dCzZu3evlTWVHfui+WeLFi20zUftZZaD0MYVV4pIud66datUr17d77rxoGnFihVGzef8DsSNJEACJEACJEACJEACiQjQAZoIB/8ggcQELl68KE888YTs378/8Y7//wsRrQMG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IIAAAggggAACCCCAAAIIIIAAAggggIDzAgyBD9Fch0KPHDlSJk6cKJMnT5bPPvtMWrRoIevXrzevdUWye++9lxXaQ3QlOwIIIIAAAggggAACCCCAAAIIIIAAAuUhQA/QUqj26NFD/vKXv0jdunVlyZIl8vzzz5vgp/YMfeKJJyQzM7MUZ+UQBBBAAAEEEEAAAQQQQAABBBBAAAEEEAi3AD1ASynaoUMHefPNN82Q9z179ogujqQB0QoViCmXkpTDEEAAAQQQQAABBBBAAAEEEEAAAQQQCLsAAdAyktaqVUv0i4QAAggggAACCCCAAAIIIIAAAggggAAC7hOgu6L72oQSIYAAAggggAACCCCAAAIIIIAAAggggECYBAiAhgmS0yCAAAIIIIAAAggggAACCCCAAAIIIICA+wQIgLqvTSgRAggggAACCCCAAAIIIIAAAggggAACCIRJgABomCA5DQIIIIAAAggggAACCCCAAAIIIIAAAgi4T4AAqPvahBIhgAACCCCAAAIIIIAAAggggAACCCCAQJgECICGCZLTIIAAAggggAACCCCAAAIIIIAAAggggID7BAiAuq9NKBECCCCAAAIIIIAAAggggAACCCCAAAIIhEmAAGiYIDkNAggggAACCCCAAAIIIIAAAggggAACCLhPgACo+9qEEiGAAAIIIIAAAggggAACCCCAAAIIIIBAmAQIgIYJktMggAACCCCAAAIIIIAAAggggAACCCCAgPsECIC6r00oEQIIIIAAAggggAACCCCAAAIIIIAAAgiESYAAaJggOQ0CCCCAAAIIIIAAAggggAACCCCAAAIIuE+AAKj72oQSIYAAAggggAACCCCAAAIIIIAAAggggECYBAiAhgmS0yCAAAIIIIAAAggggAACCCCAAAIIIICA+wQIgLqvTSgRAggggAACCCCAAAIIIIAAAggggAACCIRJoGKYzsNpwiyQnZ0tc+fOLXLW48ePS0FBgdlWrVo1qVCB+HURoBh5k5ubK2fPnpXU1NQYqRHV8BYoLCyUY8eOmU2JiYmSlpbmvZvXMSKgn+GjR49KcnKyVK5cOUZqRTW8BU6dOiUnTpwwm6pUqSL6RYo9Aaudee6Kvba1aqTPXadPnzZv9Z6s92ZS7Ano/9dnzpzhuSv2mtZTI/39WZP+jqz/Z5NiU0Cfr/XZmueu2GxfvR/r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GVetWmWG/+s19Dj9atq0qd+esEVOwBsEEEAAAQQQQACBEgIEQEuQsAEBBBBAAAEEEEAg0gLjxo2Tp556yhRD5/V87733PEXSIGanTp2koKBALrjgAhMwTEpK8uwv/mLr1q1y8803iw6ZL54yMjLM3KOB5g597rnnZPz48XL8+PHih5v3Xbp0kVmzZsn5559fZP+BAwdEA52a/vOf/8jTTz8tc+bM8eSpVq2a7Nu3T3T+00OHDpnFnLSevmao6tOnj7z00kvSsGFDz/G8QAABBBBAAAEEELAnQADUnhO5EEAAAQQQQAABBBwUOHHihBkKby2EtGDBArn66qtNcFDn/dSV4itXrixr1qwpEXj0Lub8+fNl6NChokPrExISpHPnztK2bVvZs2ePCZweO3bMZL/33nvlscce8z7UXGvAgAGyaNEis117jXbt2lVq1qxpApfaU/PgwYNmn849unv3bqlRo4bnHN4B0GHDhpkApmfnjy8uv/xy+eCDDyQvL0969+4tn332mdmtAdXWrVtLTk6O/Otf/5KjR4+a7XruL774Qpo0aWLe8w8CCCCAAAIIIICAPQFWgbfnRC4EEEAAAQQQQAABBwV0uPjs2bM9w75/85vfiA5Df/75503wU4syadKkgMHPI0eOyG233WaCnzqEfsmSJaYX6Isvvigff/yxmWf0sssuM7X685//bHppeldRA59W8HP06NGyc+dOmTdvnsycOVMWLlwoO3bsEA1satLeoTNmzDCvff2jvTe1N6jOaarD4qdNm2Z6lWpeDe5awc9nnnnG1E/z67U0wGoFZrU+akJCAAEEEEAAAQQQCE2AHqCheZEbAQQQQAABBBBAwEEBDXxOnz7dXHHUqFHyxhtvSHZ2tvTs2dPMpakLIPlL1orymuff//63WTG+eF4dRq9D13Vez44dO8rq1as983n269dPPvroIzPsXIOfiYmJxQ83wdX09HQzHP+aa66Rd955x5PHuweobvznP/8pffv29ey3Xtx5553yt7/9zfQs/f7770tcxyqjBkC1p6gakBBAAAEEEEAAAQTsC/h/YrR/DnIigAACCCCAAAIIIFAuArrQUfPmzc25tfekBj917syXX37ZE6j0deEzZ86Ynpq6T4ea67B5X6lixYoyduxYs0uHl3/99deebFOmTJG5c+eK9hj1FfzUjDp/pzUvp785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" width="672" /></p>
<p>The predicted salary for players is given by the mean response value for the players in that box. Overall, the tree segments the players into 3 regions of predictor space.</p>
<div class="page-break-after"></div>
<p>We now discuss the process of building a regression tree. There are to steps:</p>
<p><br /></p>
<ol style="list-style-type: decimal">
<li><p><br /><br /><br /><br /><br /><br /></p></li>
<li><p><br /><br /><br /><br /><br /><br /></p></li>
</ol>
<p><br /></p>
<p>How do we construct the regions <span class="math inline">\(R_1, \dots, R_J\)</span>?</p>
<p><br /><br /><br /></p>
<p>The goal is to find boxes <span class="math inline">\(R_1, \dots, R_J\)</span> that minimize the RSS.</p>
<p><br /><br /><br /><br /><br /></p>
<p>The approach is <em>top-down</em> because</p>
<p><br /><br /><br /><br /><br /></p>
<p>The approach is <em>greedy</em> because</p>
<div class="page-break-after"></div>
<p>In order to perform recursive binary splitting,</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>The process described above may produce good predictions on the training set, but is likely to overfit the data.</p>
<p><br /></p>
<p>A smaller tree, with less splits might lead to lower variance and better interpretation at the cost of a little bias.</p>
<p><br /><br /><br /><br /></p>
<p>A strategy is to grow a very large tree <span class="math inline">\(T_0\)</span> and then <em>prune</em> it back to obtain a <em>subtree</em>.</p>
<div class="page-break-after"></div>
<p>Algorithm for building a regression tree:</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p><img src="data:image/png;base64,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CCCAAAIIIICAYwUIgDq2a2kYAggggAACCCCAAAIIIIAAAggggAACCBAA5TuAAAIIIIAAAggggAACCCCAAAIIIIAAAo4VIADq2K6lYQgggAACCCCAAAIIIIAAAggggAACCCBAAJTvAAIIIIAAAggggAACCCCAAAIIIIAAAgg4VoAAqGO7loYhgAACCCCAAAIIIIAAAggggAACCCCAAAFQvgMIIIAAAggggAACCCCAAAIIIIAAAggg4FgBAqCO7VoahgACCCCAAAIIIIAAAggggAACCCCAAAIEQPkOIIAAAggggAACCCCAAAIIIIAAAggggIBjBQiAOrZraRgCCCCAAAIIIIAAAggggAACCCCAAAIIEADlO4AAAggggAACCCCAAAIIIIAAAggggAACjhUgAOrYrqVhCCCAAAIIIIAAAggggAACCCCAAAIIIEAAlO8AAggggAACCCCAAAIIIIAAAggggAACCDhWgACoY7uWhiGAAAIIIIAAAggggAACCCCAAAIIIIAAAVC+AwgggAACCCCAAAIIIIAAAggggAACCCDgWAECoI7tWhqGAAIIIIAAAggggAACCCCAAAIIIIAAAgRA+Q4ggAACCCCAAAIIIIAAAggggAACCCCAgGMFCIA6tmtpGAIIIIAAAggggAACCCCAAAIIIIAAAggQAOU7gAACCCCAAAIIIIAAAggggAACCCCAAAKOFSAA6tiupWEIIIAAAggggAACCCCAAAIIIIAAAgggQACU7wACCCCAAAIIIIAAAggggAACCCCAAAIIOFaAAKhju5aGIYAAAggggAACCCCAAAIIIIAAAggggAABUL4DCCCAAAIIIIAAAggggAACCCCAAAIIIOBYAQKgju1aGoYAAggggAACCCCAAAIIIIAAAggggAACBED5DiCAAAIIIIAAAggggAACCCCAAAIIIICAYwUIgDq2a2kYAggggAACCCCAAAIIIIAAAggggAACCBAA5TuAAAIIIIAAAggggAACCCCAAAIIIIAAAo4VIADq2K6lYQgggAACCCCAAAIIIIAAAggggAACCCBAAJTvAAIIIIAAAggggAACCCCAAAIIIIAAAgg4VoAAqGO7loYhgAACCCCAAAIIIIAAAggggAACCCCAAAFQvgMIIIAAAggggAACCCCAAAIIIIAAAggg4FgBAqCO7VoahgACCCCAAAIIIIAAAggggAACCCCAAAIEQPkOIIAAAggggAACCCCAAAIIIIAAAggggIBjBQiAOrZraRgCCCCAAAIIIIAAAggggAACCCCAAAIIEADlO4AAAggggAACCCCAAAIIIIAAAggggAACjhUgAOrYrqVhCCCAAAIIIIAAAggggAACCCCAAAIIIEAAlO8AAggggAACCCCAAAIIIIAAAggggAACCDhWgACoY7uWhiGAAAIIIIAAAggggAACCCCAAAIIIIAAAVC+AwgggAACCCCAAAIIIIAAAggggAACCCDgWAECoI7tWhqGAAIIIIAAAggggAACCCCAAAIIIIAAAgRA+Q4ggAACCCCAAAIIIIAAAggggAACCCCAgGMFCIA6tmtpGAIIIIAAAggggAACCCCAAAIIIIAAAggQAOU7gAACCCCAAAIIIIAAAggggAACCCCAAAKOFSAA6tiupWEIIIAAAggggAACCCCAAAIIIIAAAgggQACU7wACCCCAAAIIIIAAAggggAACCCCAAAIIOFaAAKhju5aGIYAAAggggAACCCCAAAIIIIAAAggggAABUL4DCCCAAAIIIIAAAggggAACCCCAAAIIIOBYAQKgju1aGoYAAggggAACCCCAAAIIIIAAAggggAACBED5DiCAAAIIIIAAAggggAACCCCAAAIIIICAYwUIgDq2a2kYAggggAACCCCAAAIIIIAAAggggAACCBAA5TuAAAIIIIAAAggggAACCCCAAAIIIIAAAo4VIADq2K6lYQgggAACCCCAAAIIIIAAAggggAACCCBAAJTvAAIIIIAAAggggAACCCCAAAIIIIAAAgg4VoAAqGO7loYhgAACCCCAAAIIIIAAAggggAACCCCAAAFQvgMIIIAAAggggAACCCCAAAIIIIAAAggg4FgBAqCO7VoahgACCCCAAAIIIIAAAggggAACCCCAAAIEQPkOIIAAAggggAACCCCAAAIIIIAAAggggIBjBQiAOrZraRgCCCCAAAIIIIAAAggggAACCCCAAAIIEADlO4AAAggggAACCCCAAAIIIIAAAggggAACjhUgAOrYrqVhCCCAAAIIIIAAAggggAACCCCAAAIIIBAJAQIIIIAAAggggIBvgX/++Ue2bdsmu3btkp07d5qXdbx3716JiYnxfWOIn82aNasULVrUvIoVKyb60s/6XrFiRSlQoECI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BPwTYBMk/5zIhQACCCDgcIHRo0ebFuoIUB0NqSO5nJ402PvYY4/J0KFDTVMtA6e3m/YhECiBxYsXm+CnrqE5b968kAx+qoX+Lnj00UfNH3/0M78LVIGEAAIIIIAAAk4SIADqpN6kLQgggAACSRZYs2aNubd169ZJLiNUb7TabBmEajuoNwKpLWD9zLRo0UKioqJS+/EBfx6/CwJOSoEIIIAAAgggECQCzh/eEiTQVAMBBBBAILgFzp49ayqYI0eO4K5oCtQuZ86cptQzZ86kQOm+i7x48aJs2rTJ7JZdvnx5KVCggO+MnEUgiAWsnxnrZyiIq+pX1ax2WO3y6yYyIYAAAggggAACISBAADQEOokqIoAAAggg4ASB77//3qwzqKPm/v77bzl37pzdrDx58kilSpWkQ4cOZlp+unTp7GveB0899ZRZr9Q6ryPvtm/fbn2M871EiRIez9RRe+PHj/fI3759e/n666/tc40aNTLrpNonfBysXbtWqlat6uNKeJ6KiYmRunXryqpVq2wAXWP3xhtvtD+7H/z222/ywQcfuJ+K97hz585SvXp1n3n02RMmTJCVK1fK77//Lvv27TN5dUOzNm3amA2KfN7ISQQQQAABBBBAAAFHCxAAdXT30jgEEEAAAQTSXkA3VXnppZfMztK62YqvdOTIEVmxYoV56cZMGpiMK6h4/Phx2b9/v12Mv1OP9R73oKuW452OHTvmUbZ+jivt2bNH+vTpI998843oMemywKBBgzyCnwm5LFy40AQtE8pnXb/nnnt8BkAPHDggrVq1ku+++87Kat418K6vMWPGmLUtNYBOQgABBBBAAAEEEAgvAdYADa/+prUIIIAAAgikqsC6devMqLvhw4dLXMFP7wrp6L3rrrtOFixY4H0pKD5rQHfIkCGiU/enTZvmd7uCovIpXIk//vhDBg4cmKinrF69OlH5fWU+fPiw3HDDDVcFP93zXrhwQXT06Msvv+x+mmMEEEAAAQQQQACBMBAgABoGnUwTEUAAAQQQSAsBHW157733ik4R907Zs2eXW265Re68804pXLiw92XRqcwPP/ywbNu27apraX3izTfflL59+8qpU6fSuirJer5OD3/ttdckUCMiNTCsfRYdHZ2oev3555+Jyu8rc79+/WTnzp0elwoWLCi33XabREREeJzX4LUG5kkIIIAAAggg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IACaXE9KQwABBBBAAAEEEEAAAQQQQAABBBBAAIF8JEAANB89DC4FAQQQQAABBBBAAAEEEEAAAQQQQAABBJIrQAA0uZ6UhgACCCCAAAIIIIAAAggggAACCCCAAAL5SIAAaD56GFwKAggggAACCCCAAAIIIIAAAggggAACCCRXgABocj0pDQEEEEAAAQQQQAABBBBAAAEEEEAAAQTykQAB0Hz0MLgUBBBAAAEEEEAAAQQQQAABBBBAAAEEEEiuAAHQ5HpSWpoJLFu2zEaPHm1//PGHbdq0Kc3unttFAAEEEEAAAQQQiCfw1VdfWfXq1aN+XnrppXjZbdasWVF5vWO7desW95h//vnHatSoEXXcPffcEzd/Tnb89ttvUeXruiZOnBhV1ODBgzPl2bhxY1QeVrYLzJ8/33r37m0XX3yx7bXXXla2bFlr3ry5XX755fbnn39uz5jgkv4eKVCggP9z7bXXJngk2RBAAIH0ESicPrfKnSKQe4F169bZk08+ad9//71NmDDB5s6d6xdauHBha9iwoR166KF2//33W/369f19wYU2bdrYjz/+6G8qV66cTZkyxVVY/I2BhRtvvNHefffdwBZzeVUZrVq1atR2b6VHjx726quveqtWsGBBmzx5sulcyUqXXHKJffrpp35xp556atQ5VRG+/vrr/f1aUMW+WLFiUdtYySxw4okn2hdffOHvWLBggfujwt8QZ2HRokX29NNPu+/XtGnTTOv6Hqpiffjhh1unTp2sRIkScY7evnnLli2mP9DGjBljP/30ky1cuNCaNWtmBx10kLVv394OOeSQ7ZlZQgABBBBAAIGYAgcccIAtWbLEtm3b5u9XUPSaa67x14MLn332mfvdHdym5Q8//NB69uwZ3uzWx44d635PB3fut99+wdVcL6teoDpFMGlbMG3YsCFTnuB+lrcLfPnll9auXTtbvHjx9o2RpV9++cX9vPnmm3bnnXdadgLZWQXJo07CCgIIIJDGAgRA0/jhc+vZE/jhhx9MQb+pU6fGPFAVQb2x1Y+Cf3fffbd17tzZihQpEpVfwagRI0b421ShVJnaHisNGzYsZoVSFejzzz8/1iEWrkA3bdo0qcFPnXTFihVR16X1YKIiHNRIfPmjjz6KCn4meuRdd93lgvMK0geTAt/60ffohRdesGeeecbOOOOMYJaoZVXG9b36+uuv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mYwnmcoZZW3YsME0GL8mHNAfGRojlFafyXemRAQQSE8BdYXVkC0HH3ywC1ClpwJ3jQACCCCQDAG9DFEjBrX63tELlWScjzIQ2B0Fsj+F3e54l1wzAnkgoNaeaiUZbimZB6fKkyLVzVld72N1v8+TEyapUA1DoJ/d9a1/khh2SjGadVYtikkIIIAAAggggAACCCCAAAII7M4CdIHfnZ8e144AAggggAACCCCAAAIIIIAAAggggAACWQoQAM2Sh50IIIAAAggggAACCCCAAAIIIIAAAgggsDsLEADdnZ8e144AAggggAACCCCAAAIIIIAAAggggAACWQoQAM2Sh50IIIAAAggggAACCCCAAAIIIIAAAgggsDsLMAnS7vz0uPY8E/j333/9spn12qdgAYEoAf47ieJgBQEEEEAAAQQQQAABBBBAIJ8K0AI0nz4YLmvXCvTq1csKFixo3bp127UXwtkRyMcC3333nfvv5Nhjj83HV8mlIYAAAggggAACCCCAAAIIpLsAAdB0/wZw/wgggAACCCCAAAIIIIAAAggggAACCKSwAAHQFH643BoCCCCAAAIIIIAAAggggAACCCCAAALpLkAANN2/Adw/AggggAACCCCAAAIIIIAAAggggAACKSxAADSFHy63hgACCCCAAAIIIIAAAggggAACCCCAQLoLEABN928A948AAggggAACCCCAAAIIIIAAAggggEAKCxAATeGHy60hgAACCCCAAAIIIIAAAggggAACCCCQ7gIEQNP9G8D9I4AAAggggAACCCCAAAIIIIAAAgggkMICBEBT+OFyawgggAACCCCAAAIIIIAAAggggAACCKS7AAHQdP8GcP8IIIAAAggggAACCCCAAAIIIIAAAgiksAAB0BR+uNwaAggggAACCCCAAAIIIIAAAggggAAC6S5AADTdvwHcPwIIIIAAAggggAACCCCAAAIIIIAAAiksQAA0hR8ut4YAAggggAACCCCAAAIIIIAAAggggEC6CxAATfdvAPePAAIIIIAAAggggAACCCCAAAIIIIBACgsQAE3hh8utIYAAAggggAACCCCAAAIIIIAAAgggkO4CBEDT/RvA/SOAAAIIIIAAAggggAACCCCAAAIIIJDCAgRAU/jhcmsIIIAAAggggAACCCCAAAIIIIAAAgikuwAB0HT/BnD/CCCAAAIIIIAAAggggAACCCCAAAIIpLAAAdAUfrjcGgIIIIAAAggggAACCCCAAAIIIIAAAukuQAA03b8B3D8CCCCAAAIIIIAAAggggAACCCCAAAIpLEAANIUfLreGAAIIIIAAAggggAACCCCAAAIIIIBAugsQAE33bwD3jwACCCCAAAIIIIAAAggggAACCCCAQAoLEABN4YfLrSGAAAIIIIAAAggggAACCCCAAAIIIJDuAgRA0/0bwP0jgAACCCCAAAIIIIAAAggggAACCCCQwgIEQFP44XJrCCCAAAIIIIAAAggggAACCCCAAAIIpLsAAdB0/wZw/wgggAACCCCAAAIIIIAAAggggAACCKSwAAHQFH643BoCCCCAAAIIIIAAAggggAACCCCAAALpLkAANN2/Adw/AggggAACCCCAAAIIIIAAAggggAACKSxAADSFHy63hgACCCCAAAIIIIAAAggggAACCCCAQLoLEABN928A948AAggggAACCCCAAAIIIIAAAggggEAKCxAATeGHy60hgAACCCCAAAIIIIAAAggggAACCCCQ7gIEQNP9G8D9I4AAAggggAACCCCAAAIIIIAAAgggkMICBEBT+OFyawgggAACCCCAAAIIIIAAAggggAACCKS7AAHQdP8GcP8IIIAAAggggAACCCCAAAIIIIAAAgiksAAB0BR+uNwaAggggAACCCCAAAIIIIAAAggggAAC6S5AADTdvwHcPwIIIIAAAggggAACCCCAAAIIIIAAAiksQAA0hR8ut4YAAggggAACCCCAAAIIIIAAAggggEC6CxAATfdvAPePAAIIIIAAAggggAACCCCAAAIIIIBACgsQAE3hh8utIYAAAggggAACCCCAAAIIIIAAAgggkO4CBEDT/RvA/SOAAAIIIIAAAggggAACCCCAAAIIIJDCAgRAU/jhcmsIIIAAAggggAACCCCAAAIIIIAAAgikuwAB0HT/BnD/CCCAAAIIIIAAAggggAACCCCAAAIIpLAAAdAUfrjcGgIIIIAAAggggAACCCCAAAIIIIAAAukuQAA03b8B3D8CCCCAAAIIIIAAAggggAACCCCAAAIpLEAANIUfLreGAAIIIIAAAggggAACCCCAAAIIIIBAugsQAE33bwD3jwACCCCAAAIIIIAAAggggAACCCCAQAoLEABN4YfLrSGAAAIIIIAAAggggAACCCCAAAIIIJDuAgRA0/0bwP0jgAACCCCAAAIIIIAAAggggAACCCCQwgIEQFP44XJrCCCAAAIIIIAAAggggAACCCCAAAIIpLsAAdB0/wZw/wgggAACCCCAAAIIIIAAAggggAACCKSwAAHQFH643BoCCCCAAAIIIIAAAggggAACCCCAAALpLkAANN2/Adw/AggggAACCCCAAAIIIIAAAggggAACKSxAADSFHy63hgACCCCAAAIIIIAAAggggAACCCCAQLoLEABN928A948AAggggAACCCCAAAIIIIAAAggggEAKCxAATeGHy60hgAACCCCAAAIIIIAAAggggAACCCCQ7gIEQNP9G8D9I4AAAggggAACCCCAAAIIIIAAAgggkMICBEBT+OFyawgggAACCCCAAAIIIIAAAggggAACCKS7AAHQdP8GcP8IIIAAAggggAACCCCAAAIIIIAAAgiksAAB0BR+uNwaAggggAACCCCAAAIIIIAAAggggAAC6S5AADTdvwHcPwIIIIAAAggggAACCCCAAAIIIIAAAiksQAA0hR8ut4YAAggggAACCCCAAAIIIIAAAggggEC6CxAATfdvAPePAAIIIIAAAggggAACCCCAAAIIIIBACgsQAE3hh8utIYAAAggggAACCCCAAAIIIIAAAgggkO4CBEDT/RvA/SOAAAIIIIAAAggggAACCCCAAAIIIJDCAgRAU/jhcmsIIIAAAggggAACCCCAAAIIIIAAAgikuwAB0HT/BnD/CCCAAAIIIIAAAggggAACCCCAAAIIpLAAAdAUfrjcGgIIIIAAAggggAACCCCAAAIIIIAAAukuQAA03b8B3D8CCCCAAAIIIIAAAggggAACCCCAAAIpLEAANIUfLreGAAIIIIAAAggggAACCCCAAAIIIIBAugsQAE33bwD3jwACCCCAAAIIIIAAAggggAACCCCAQAoLEABN4YfLrSGAAAIIIIAAAggggAACCCCAAAIIIJDuAgRA0/0bwP0jgAACCCCAAAIIIIAAAggggAACCCCQwgIEQFP44XJrCCCAAAIIIIAAAggggAACCCCAAAIIpLsAAdB0/wZw/wgggAACCCCAAAIIIIAAAggggAACCKSwQIF/IymF749bS0GBTZs22aRJk2zOnDnuZ+7cuVGfy5Yty/Vdb9iwwdavX2/FihWzkiVL5rq88uXL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IoAAAggggAACCCCAAAIIIIAAAgggkMYECICmsRPO4SKAAAIIIIAAAggggAACCCCAAAIIIJCWBAiApqWzzbEigAACCCCAAAIIIIAAAggggAACCCCQxgQIgKaxE87hIoAAAggggAACCCCAAAIIIIAAAgggkJYECICmpbPNsSKAAAIIIIAAAggggAACCCAQBQIXL14UHWyQhICnwJkzZzxn8RkBIQDKH4FLYOzYsTJ06FA5fPiwax4TCJw9e9b8XQwfPhwMBBBAAAEEEEAAAQQQQCAiBC5cuCB9+vSJiH1hJyJH4I8//pD3338/cnaIPYkYAQKgEXMqUn5HxowZIy+88IIcOXIk5XeGPYgYAQ2A6t/FsGHDImaf2BEEEEAAAQQQQAABBBBAYPHixSAg4Cawdu1aYhpuInywBQiA2hK8I4AAAggggAACCCCAAAIIIIAAAggggEDUCRAAjbpTygEhgAACCCCAAAIIIIAAAggggAACCCCAgC1AANSW4B0BBBBAAAEEEEAAAQQQQAABBBBAAAEEok6AAGjUnVIOCAEEEEAAAQQQQAABBBBAAAEEEEAAAQRsAQKgtgTvCCCAAAIIIIAAAggggAACCCCAAAIIIBB1AgRAo+6UckAIIIAAAggggAACCCCAAAIIIIAAAgggYAsQALUleEcAAQQQQAABBBBAAAEEEEAAAQQQQACBqBMgABp1p5QDQgABBBBAAAEEEEAAAQQQQAABBBBAAAFbgACoLcE7AggggAACCCCAAAIIIIAAAggggAACCESdAAHQqDulHBACCCCAAAIIIIAAAggggAACCCCAAAII2AIEQG0J3hFAAAEEEEAAAQQQQAABBBBAAAEEEEAg6gQIgEbdKeWAEEAAAQQQQAABBBBAAAEEEEAAAQQQQMAWIABqS/COAAIIIIAAAggggAACCCCAAAIIIIAAAlEnQAA06k4pB4QAAggggAACCCCAAAIIIIAAAggggAACtgABUFuCdwQQQAABBBBAAAEEEEAAAQQQQAABBBCIOgECoFF3SjkgBBBAAAEEEEAAAQQQQAABBBBAAAEEELAFCIDaErwjgAACCCCAAAIIIIAAAggggAACCCCAQNQJEACNulPKASGAAAIIIIAAAggggAACCCCAAAIIIICALUAA1JbgHQEEEEAAAQQQQAABBBBAAAEEEEAAAQSiToAAaNSd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Agh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcCBEBdE1IBAggggAACCCCAAAIIIIAAAggggAACCHhVgACoV/cM7UIAAQQQQAABBBBAAAEEEEAAAQQQQAAB1wIEQF0TUgECCCCAAAIIIIAAAggggAACCCCAAAIIeFWAAKhX9wztQgABBBBAAAEEEEAAAQQQQAABBBBAAAHXAgRAXRNSAQIIIIAAAggggAACCCCAAAIIIIAAAgh4VYAAqFf3DO1CAAEEEEAAAQQQQAABBBBAAAEEEEAAAdcC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SIAESIAESIAESIAESIAESIAESIAESIAESMCJBKgAdSJ8dk0CJEACJEACJEACJEACJEACJEACJEACJEACJOBYAlSAOpYvWycBEiABEiABEiABEiABEiABEiABEiABEiABEnAiASpAnQifXZMACZAACZAACZAACZAACZAACZAACZAACZAACTiWABWgjuXL1kmABEiABEiABEiABEiABEiABEiABEiABEiABJxIgApQJ8Jn1yRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAo4lQAWoY/mydRIgARIgARIgARIgARIgARIgARIgARIgARIgAScSoALUifDZNQmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQgGMJUAHqWL5snQRIgARIgARIgARIgARIgARIgARIgARIgARIwIkEqAB1Inx2TQIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIk4FgCVIA6li9bJwESIAESIAESIAESIAESIAESIAESIAESIAEScCIBKkCdCJ9dkwAJkAAJkAAJkAAJkADfdaSXAAAHg0lEQVQJkAAJkAAJkAAJkAAJOJYAFaCO5cvWSYAESIAESIAESIAESIAESIAESIAESIAESIAEnEiAClAnwmfXJEACJEACJEACJEACJEACJEACJEACJEACJEACjiVABahj+bJ1EiABEiABEiABEiABEiABEiABEiABEiABEiABJxKgAtSJ8Nk1CZAACZAACZAACZAACZAACZAACZAACZAACZCAYwlQAepYvmydBEiABEiABEiABEiABEiABEiABEiABEiABEjAiQSoAHUifHZNAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiTgWAJUgDqWL1snARIgARIgARIgARIgARIgARIgARIgARIgARJwIgEqQJ0In12TAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAk4lgAVoI7ly9ZJgARIgARIgARIgARIgARIgARIgARIgARIgAScSIAKUCfCZ9ckQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAKOJUAFqGP5snUSIAESIAESIAESIAESIAESIAESIAESIAESIAEnEqAC1Inw2TUJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkIBjCVAB6li+bJ0ESIAESIAESIAESIAESIAESIAESIAESIAESMCJBKgAdSJ8dk0CJEACJEACJEACJEACJEACJEACJEACJEACJOBYAlSAOpYvWycBEiABEiABEiABEiABEiABEiABEiABEiABEnAiASpAnQifXZMACZAACZAACZAACZAACZAACZAACZAACZAACTiWABWgjuXL1kmABEiABEiABEiABEiABEiABEiABEiABEiABJxIgApQJ8Jn1yRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAo4lQAWoY/mydRIgARIgARIgARIgARIgARIgARIgARIgARIgAScSoALUifDZNQmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQgGMJUAHqWL5snQRIgARIgARIgARIgARIgARIgARIgARIgARIwIkEqAB1Inx2TQIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIk4FgCVIA6li9bJwESIAESIAESIAESIAESIAESIAESIAESIAEScCIBKkCdCJ9dkwAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJOJYAFaCO5cvWSYAESIAESIAESIAESIAESIAESIAESIAESIAEnEiAClAnwmfXJEACJEACJEACJEACJEACJEACJEACJEACJEACjiVABahj+bJ1EiABEiABEiABEiABEiABEiABEiABEiABEiABJxKgAtSJ8Nk1CZAACZAACZAACZAACZAACZAACZAACZAACZCAYwlQAepYvmydBEiABEiABEiABEiABEiABEiABEiABEiABEjAiQSoAHUifHZNAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiTgWAJUgDqWL1snARIgARIgARIgARIgARIgARIgARIgARIgARJwIgEqQJ0In12TAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAk4lgAVoI7ly9ZJgARIgARIgARIgARIgARIgARIgARIgARIgAScSIAKUCfCZ9ckQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAKOJUAFqGP5snUSIAESIAESIAESIAESIAESIAESIAESIAESIAEnEqAC1Inw2TUJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkIBjCVAB6li+bJ0ESIAESIAESIAESIAESIAESIAESIAESIAESMCJBKgAdSJ8dk0CJEACJEACJEACJEACJEACJEACJEACJEACJOBYAlSAOpYvWycBEiABEiABEiABEiABEiABEiABEiABEiABEnAiASpAnQifXZMACZAACZAACZAACZAACZAACZAACZAACZAACTiWABWgjuXL1kmABEiABEiABEiABEiABEiABEiABEiABEiABJxIgApQJ8Jn1yRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAo4lQAWoY/mydRIgARIgARIgARIgARIgARIgARIgARIgARIgAScSoALUifDZNQmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQgGMJUAHqWL5snQRIgARIgARIgARIgARIgARIgARIgARIgARIwIkEqAB1Inx2TQIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIk4FgCVIA6li9bJwESIAESIAESIAESIAESIAESIAESIAESIAEScCIBKkCdCJ9dkwAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJOJYAFaCO5cvWSYAESIAESIAESIAESIAESIAESIAESIAESIAEnEiAClAnwmfXJEACJEACJEACJEACJEACJEACJEACJEACJEACjiVABahj+bJ1EiABEiABEiABEiABEiABEiABEiABEiABEiABJxKgAtSJ8Nk1CZAACZAACZAACZAACZAACZAACZAACZAACZCAYwlQAepYvmydBEiABEiABEiABEiABEiABEiABEiABEiABEjAiQT+H3VcQZ0ETTHQAAAAAElFTkSuQmCC" width="33%" /><img src="data:image/png;base64,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98cCaNxKhc7yE39qxH/kxq35p83/6SnfCBAgQIAAAQIECBAgQIAAAQIECBCoskBuCqDxys4bbrgh7O4G//FK0LiVlpfHqni8ND1upeeSB83+U/pAo9KVE/Gp0l+wX3/99WZH/rlZ2n/cccf9eacWAQIECBAgQIAAAQIECBAgQIAAAQI1EchNAXThwoVh1qxZYf78+a1CLlq0KNl/zDHHJN/jJ8PH+3rG7Zlnnkm+t/zPkiVLkl2f/vSny0+NGzcuac+ZM6e8r9SI91uYO3du8nD48OGl3b4TIECAAAECBAgQIECAAAECBAgQIFAjgdwUQEuFyXgl6NKlS3fijMXPadOmJfsuueSS8nOlJe7/+7//G1599dXy/tiIV5L+7Gc/S/aVjosPRowYET7xiU+EV155JcyYMSN5vvSf+MFJ8T6DRx11VDjrrLNKu30nQIAAAQIECBAgQIAAAQIECBAgQKBGArn5EKRY2FywYEF47LHHQvxQo9NPPz2ccsopSWEzXpUZl7tPnTo1KWCWrOOnvsfj49Wjf/d3f5cULT/zmc+EZcuWJVeTxg+sOOecc0J9fX3plOQG2l/96lfDd77znRA/GCmef/TRR4fFixcn7bic/vrrr3ej7bKYBgECBAgQIECAAAECBAgQIECAAIHaCeSmABo/2S/eA/TWW28Nv/71r5OiZixsxi3et/Paa68No0ePTh6X/hPP+Y//+I9wxx13hJtuuinMmzcv+YrP77333sk5sUjacjv//PPDjTfemBRAm58Trwy97rrrwkknndTyFI8JECBAgAABAgQIECBAgAABAgQIEKiBQG4KoNGub9++4Ytf/GK4+uqrw9tvvx1Wr14djjzyyDBkyJDd0sYPRfr85z8frrzyymTZe7z685BDDkmKprFAurstXl0aC6dxyftbb72VHH/wwQeHnj1zc1eB3aVuPwECBAgQIECAAAECBAgQIECAAIHMCOSqAFpSj0XNeDVm/GrvFoudsYAZvzqyxeLqngqsHenLsQQIECBAgAABAgQIECBAgAABAgQIVFbA5YqV9dQbAQIECBAgQIAAAQIECBAgQIAAAQIpElAATdFkCIUAAQIECBAgQIAAAQIECBAgQIAAgcoKKIBW1lNvBAgQIECAAAECBAgQIECAAAECBAikSEABNEWTIRQCBAgQIECAAAECBAgQIECAAAECBCoroABaWU+9ESBAgAABAgQIECBAgAABAgQIECCQIgEF0BRNhlAIECBAgAABAgQIECBAgAABAgQIEKisgAJoZT31RoAAAQIECBAgQIAAAQIECBAgQIBAigQUQFM0GUIhQIAAAQIECBAgQIAAAQIECBAgQKCyAgqglfXUGwECBAgQIECAAAECBAgQIECAAAECKRJQAE3RZAiFAAECBAgQIECAAAECBAgQIECAAIHKCiiAVtZTbwQIECBAgAABAgQIECBAgAABAgQIpEhAATRFkyEUAgQIECBAgAABAgQIECBAgAABAgQqK6AAWllPvREgQIAAAQIECBAgQIAAAQIECBAgkCIBBdAUTYZQCBAgQIAAAQIECBAgQIAAAQIECBCorIACaGU99UaAAAECBAgQIECAAAECBAgQIECAQIoEFEBTNBlCIUCAAAECBAgQIECAAAECBAgQIECgsgIKoJX11BsBAgQIECBAgAABAgQIECBAgAABAikSUABN0WQIhQABAgQIECBAgAABAgQIECBAgACBygoogFbWU28ECBAgQIAAAQIECBAgQIAAAQIECKRIQAE0RZMhFAIECBAgQIAAAQIECBAgQIAAAQIEKiugAFpZT70RIECAAAECBAgQIECAAAECBAgQIJAiAQXQFE2GUAgQIECAAAECBAgQIECAAAECBAgQqKyAAmhlPfVGgAABAgQIECBAgAABAgQIECBAgECKBBRAUzQZQiFAgAABAgQIECBAgAABAgQIECBAoLICCqCV9dQbAQIECBAgQIAAAQIECBAgQIAAAQIpElAATdFk5D2UHTt2hJdffjk888wzYe3atXlPV34ECBAgQIAAAQIECBAgQIAAAQIpEFAATcEkFCGEW265JRxxxBHhjDPOCJMnTw5Dhw4NX/7ylxVCizD5ciRAgAABAgQIECBAgAABAgQI1FBAAbSG+EUZ+ic/+Um4+uqrw9KlS8spb9u2Ldx0001h7NixYePGjeX9GgQIECBAgAABAgQIECBAgAABAgQqKaAAWklNfe0isGzZsvDP//zPu+wv7Xj66afDjTfeWHroOwECBAgQIECAAAECBAgQIECAAIGKCiiAVpRTZy0F7r777rBp06aWu3d6fPvtt+/02AMCBAgQIECAAAECBAgQIECAAAEClRJQAK2UpH5aFWi+7L3VAz7a2Z5jdneu/QQIECBAgAABAgQIECBAgAABAgT2JKAAuicdz3VZ4PDDD2+zj/Yc02YnDiBAgAABAgQIECBAgAABAgQIECDQioACaCsodlVO4OKLLw4DBgzYY4dTp07d4/OeJECAAAECBAgQIECAAAECBAgQINBZAQXQzso5r10CBx10UPjhD3+422NPO+208A//8A+7fd4TBAgQIECAAAECBAgQIECAAAECBLoioADaFT3ntkvgmmuuCbfddls48sgjdzq+V69eYcaMGW1eIbrTSR4QIECAAAECBAgQIECAAAECBAgQ6ICAAmgHsBzaeYG4zP2NN94ITz31VJg4cWLSUVNTU5g5c2bnO3UmAQIECBAgQIAAAQIECBAgQIAAgTYEFEDbAPJ05QR69OgRjj766HDVVVeVO21oaCi3NQgQIECAAAECBAgQIECAAAECBAhUWkABtNKi+mtT4Kyzzgo9e3780nvwwQfDjh072jzHAQQIECBAgAABAgQIECBAgAABAgQ6I6AA2hk153RJYPDgwaGuri7pY+XKlWH69Old6s/JBAgQIECAAAECBAgQIECAAAECBHYnoAC6Oxn7u1WgVACNg1gG363UOidAgAABAgQIECBAgAABAgQIFFpAAbTQ01+75MeMGVMefN68eeW2BgECBAgQIECAAAECBAgQIECAAIFKCiiAVlJTX+0WOPLII8OoUaOS41977bXw6KOPtvtcBxIgQIAAAQIECBAgQIAAAQIECBBor4ACaHulHFdxgebL4BsbGyvevw4JECBAgAABAgQIECBAgAABAgQIKIB6DdRMoPky+AceeKBmcRiYAAECBAgQIECAAAECBAgQIEAgvwIKoPmd29RnNnz48DBs2LAkzoULF4aXXnop9TELkAABAgQIECBAgAABAgQIECBAIFsCCqDZmq/cRWsZfO6mVEIECBAgQIAAAQIECBAgQIAAgVQJKICmajqKF0x9fX05afcBLVNoECBAgAABAgQIECBAgAABAgQIVEhAAbRCkLrpnEBcBj948ODk5CeffDJ88MEHnevIWQQIECBAgAABAgQIECBAgAABAgRaEVAAbQXFruoJ9OrVK3zhC19IBty6dWu49dZbqze4kQgQIECAAAECBAgQIECAAAECBHIvoACa+ylOf4LN7wPa0NCQ/oBFSIAAAQIECBAgQIAAAQIECBAgkBkBBdDMTFV+Az3nnHNCnz59kgQffvjh0NTUlN9kZUaAAAECBAgQIECAAAECBAgQIFBVAQXQqnIbrDWBgQMHhssuuyx5at26dcFVoK0p2UeAAAECBAgQIECAAAECBAgQINAZAQXQzqg5p+IClsFXnFSHBAgQIECAAAECBAgQIECAAAECHwkogHoZpEJg9OjR5TgeeOCBcluDAAECBAgQIECAAAECBAgQIECAQFcEFEC7oufcigkcdNBBYeLEiUl/b7/9dpg3b17F+tYRAQIECBAgQIAAAQIECBAgQIBAcQUUQIs796nL3DL41E2JgAgQIECAAAECBAgQIECAAAECmRdQAM38FOYngbFjx5aTcQVomUKDAAECBAgQIECAAAECBAgQIECgCwIKoF3Ac2plBT7zmc+EM844I+l08eLF4ZlnnqnsAHojQIAAAQIECBAgQIAAAQIECBAonIACaOGmPN0JN18G39jYmO5gRUeAAAECBAgQIECAAAECBAgQIJB6AQXQ1E9RsQKsr68vJ6wAWqbQIECAAAECBAgQIECAAAECBAgQ6KSAAmgn4ZzWPQInnHBCOOCAA5LOn3322bB69eruGUivBAgQIECAAAECBAgQIECAAAEChRBQAC3ENGcryb/8y79MAt6+fXv4v//7v2wFL1oCBAgQIECAAAECBAgQIECAAIFUCSiApmo6BBMFLIP3OiBAgAABAgQIECBAgAABAgQIEKiUgAJopST1UzGBM888MwwYMCDp79FHHw2bN2+uWN86IkCAAAECBAgQIECAAAECBAgQKJaAAmix5jsT2fbr1y9ceeWVSawbN24Md955ZybiFiQBAgQIECBAgAABAgQIECBAgED6BBRA0zcnIvpIoK6uruzQ0NBQbmsQIECAAAECBAgQIECAAAECBAgQ6IiAAmhHtBxbNYHzzz8/9Oz58ctz/vz5VRvXQAQIECBAgAABAgQIECBAgAABAvkSUADN13zmJpv99tsvXHzxxUk+K1asCDNmzMhNbhIhQIAAAQIECBAgQIAAAQIECBConoACaPWsjdRBAcvgOwjmcAIECBAgQIAAAQIECBAgQIAAgV0EFEB3IbEjLQJjx44thzJ37txyW4MAAQIECBAgQIAAAQIECBAgQIBAewUUQNsr5biqCxx11FFh5MiRybivvvpqePzxx6segwEJECBAgAABAgQIECBAgAABAgSyLaAAmu35y330lsHnfoolSIAAAQIECBAgQIAAAQIECBDoVgEF0G7l1XlXBcaMGVPuorGxsdzWIECAAAECBAgQIECAAAECBAgQINAeAQXQ9ig5pmYCp556ajjhhBOS8V988cXw3nvv1SwWAxMgQIAAAQIECBAgQIAAAQIECGRPQAE0e3NWuIibL4P/1a9+Vbj8JUyAAAECBAgQIECAAAECBAgQINB5AQXQzts5s0oC9fX15ZEsgy9TaBAgQIAAAQIECBAgQIAAAQIECLRDQAG0HUgOqa1AXAY/aNCgJIgnnngibNiwobYBGZ0AAQIECBAgQIAAAQIECBAgQCAzAgqgmZmq4gbaq1evcNVVVyUAW7ZsCbfddltxMWROgAABAgQIECBAgAABAgQIECDQIQEF0A5xObhWApbB10reuAQIECBAgAABAgQIECBAgACBbAsogGZ7/goT/bnnnhv69OmT5Pvggw+GpqamwuQuUQIECBAgQIAAAQIECBAgQIAAgc4LKIB23s6ZVRTYe++9w5QpU5IR165dG373u99VcXRDESBAgAABAgQIECBAgAABAgQIZFVAATSrM1fAuOvq6spZNzQ0lNsaBAgQIECAAAECBAgQIECAAAECBHYnoAC6Oxn7UycwZsyYckzz5s0rtzUIECBAgAABAgQIECBAgAABAgQI7E5AAXR3MvanTuDggw8OF1xwQRLXW2+9FebPn5+6GAVEgAABAgQIECBAgAABAgQIECCQLgEF0HTNh2jaELAMvg0gTxMgQIAAAQIECBAgQIAAAQIECOwkoAC6E4cHaRcYO3ZsOcS5c+eW2xoECBAgQIAAAQIECBAgQIAAAQIEWhNQAG1Nxb7UChx33HHhtNNOS+J77rnnwuLFi1Mbq8AIECBAgAABAgQIECBAgAABAgRqL6AAWvs5EEEHBSyD7yCYwwkQIECAAAECBAgQIECAAAECBRZQAC3w5Gc19fr6+nLojY2N5bYGAQIECBAgQIAAAQIECBAgQIAAgZYCCqAtRTxOvcCJJ54Yhg4dmsS5aNGisGbNmtTHLEACBAgQIECAAAECBAgQIECAAIHaCCiA1sbdqF0Q6NGjR/jCF76Q9LB9+/Zw8803d6E3pxIgQIAAAQIECBAgQIAAAQIECORZQAE0z7Ob49wsg8/x5EqNAAECBAgQIECAAAECBAgQIFBBAQXQCmLqqnoCI0aMCAMGDEgGfOSRR8KWLVuqN7iRCBAgQIAAAQIECBAgQIAAAQIEMiOgAJqZqRJoc4F+/fqFyy+/PNn14Ycfhrvuuqv509oECBAgQIAAAQIECBAgQIAAAQIEEgEFUC+EzApYBp/ZqRM4AQIECBAgQIAAAQIECBAgQKBqAgqgVaM2UKUFRo0aFXr2/PglPG/evEp3rz8CBAgQIECAAAECBAgQIECAAIEcCCiA5mASi5rC/vvvHy666KIk/eXLl4dZs2YVlULeBAgQIECAAAECBAgQIECAAAECuxFQAN0NjN3ZEKirqysH2tDQUG5rECBAgAABAgQIECBAgAABAgQIEIgCCqBeB5kWGDt2bDn+uXPnltsaBAgQIECAAAECBAgQIECAAAECBKKAAqjXQaYFPvnJT4Zzzz03yeH3v/99eOKJJzKdj+AJECBAgAABAgQIECBAgAABAgQqK6AAWllPvdVAwDL4GqAbkgABAgQIECBAgAABAgQIECCQEQEF0IxMlDB3L9B8GXxjY+PuD/QMAQIECBAgQIAAAQIECBAgQIBA4QQUQAs35flL+LTTTgvHHXdcktiSJUtC/ER4GwECBAgQIECAAAECBAgQIECAAIEooADqdZALgebL4H/961/nIidJECBAgAABAgQIECBAgAABAgQIdF1AAbTrhnpIgUB9fX05CsvgyxQaBAgQIECAAAECBAgQIECAAIHCCyiAFv4lkA+AuAx+0KBBSTKPP/54+PDDD/ORmCwIECBAgAABAgQIECBAgAABAgS6JKAA2iU+J6dFoHfv3uHKK69MwtmyZUuYNm1aWkITBwECBAgQIECAAAECBAgQIECAQA0FFEBriG/oygpYBl9ZT70RIECAAAECBAgQIECAAAECBPIgoACah1mUQyJw3nnnhT59+iTt+fPnh6amJjIECBAgQIAAAQIECBAgQIAAAQIFF1AALfgLIE/p77PPPqH0afBr1qwJ99xzT57SkwsBAgQIECBAgAABAgQIECBAgEAnBBRAO4HmlPQKWAaf3rkRGQECBAgQIECAAAECBAgQIECgFgIKoLVQN2a3CYwdO7bc9/33319uaxAgQIAAAQIECBAgQIAAAQIECBRTQAG0mPOe26wPOeSQMG7cuCS/N998Mzz00EO5zVViBAgQIECAAAECBAgQIECAAAECbQso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tKWIxwT2IGAZ/B5wPEWAAAECBAgQIECAAAECBAgQSKGAAmgKJ0VI6RWoq6srB9fQ0FBuaxAgQIAAAQIECBAgQIAAAQIECKRTQAE0nfMiqpQKnHjiieHggw9OootL4FeuXJnSSIVFgAABAgQIECBAgAABAgQIECAQBRRAvQ4IdFDgqquuSs7Yvn17uO222zp4tsMJECBAgAABAgQIECBAgAABAgSqKaAAWk1tY+VCwDL4XEyjJAgQIECAAAECBAgQIECAAIGCCCiAFmSipVk5gREjRoS999476fCRRx4JGzdurFzneiJAgAABAgQIECBAgAABAgQIEKiogAJoRTl1VgSBvn37hssuuyxJddOmTeE3v/lNEdKWIwECBAgQIECAAAECBAgQIEAgkwIKoJmcNkHXWqD5MvjGxsZah2N8AgQIECBAgAABAgQIECBAgACB3QgogO4Gxm4CexIYM2ZM6N27d3LI3LlzQ/xAJBsBAgQIECBAgAABAgQIECBAgED6BBRA0zcnIsqAwODBg8OFF16YRLpq1aowa9asDEQtRAIECBAgQIAAAQIECBAgQIBA8QQUQIs35zKukIBl8BWC1A0BAgQIECBAgAABAgQIECBAoBsFFEC7EVfX+Ra44IILygned9995bYGAQIECBAgQIAAAQIECBAgQIBAegQUQNMzFyLJmMARRxwRzjvvvCTq119/PTz++OMZy0C4BAgQIECAAAECBAgQIECAAIH8CyiA5n+OZdiNAvX19eXefRp8mUKDAAECBAgQIECAAAECBAgQIJAaAQXQ1EyFQLIo0HwZfENDQxZTEDMBAgQIECBAgAABAgQIECBAINcCCqC5nl7JdbfASSedFI4//vhkmBdffDEsXbq0u4fUPwECBAgQIECAAAECBAgQIECAQAcEFEA7gOVQAq0JNF8Gf+utt7Z2iH0ECBAgQIAAAQIECBAgQIAAAQI1ElAArRG8YfMjUFdXV07GMvgyhQYBAgQIECBAgAABAgQIECBAIBUCCqCpmAZBZFngtNNOC/vtt1+SwsKFC8O6deuynI7YCRAgQIAAAQIECBAgQIAAAQK5ElAAzdV0SqYWAr169QpTp05Nht66dWu48847axGGMQkQIECAAAECBAgQIECAAAECBFoRUABtBcUuAh0VsAy+o2KOJ0CAAAECBAgQIECAAAECBAhUR0ABtDrORsm5wMiRI0O/fv2SLOfPnx/ilaA2AgQIECBAgAABAgQIECBAgACB2gsogNZ+DkSQA4GBAweG0lWg8R6g99xzTw6ykgIBAgQIECBAgAABAgQIECBAIPsCCqDZn0MZpESgVACN4TQ2NqYkKmEQIECAAAECBAgQIECAAAECBIotoABa7PmXfQUFxo8fH3r06JH0OGfOnAr2rCsCBAgQIECAAAECBAgQIECAAIHOCiiAdlbOeQRaCBx44IFh3Lhxyd6lS5eGeC9QGwECBAgQIECAAAECBAgQIECAQG0FFEBr62/0nAlYBp+zCZUOAQIECBAgQIAAAQIECBAgkHkBBdDMT6EE0iQwYcKEcjizZ88utzUIECBAgAABAgQIECBAgAABAgRqI6AAWht3o+ZU4Jhjjgmnnnpqkt2SJUvC4sWLc5qptAgQIECAAAECBAgQIECAAAEC2RBQAM3GPIkyQwL19fXlaH0afJlCgwABAgQIECBAgAABAgQIECBQEwEF0JqwGzTPAs3vA9rQ0JDnVOVGgAABAgQIECBAgAABAgQIEEi9gAJo6qdIgFkTGDZsWDjooIOSsBctWhRWrVqVtRTES4AAAQIECBAgQIAAAQIECBDIjYACaG6mUiJpEejRo0f4/Oc/n4Szffv2MG3atLSEJg4CBAgQIECAAAECBAgQIECAQOEEFEALN+USroaAZfDVUDYGAQIECBAgQIAAAQIECBAgQKBtAQXQto0cQaDDAmeffXYYOHBgct7DDz8cNm3a1OE+nECAAAECBAgQIECAAAECBAgQINB1AQXQrhvqgcAuAv369QuXXnppsn/jxo3BhyHtQmQHAQIECBAgQIAAAQIECBAgQKAqAgqgVWE2SBEFLIMv4qzLmQABAgQIECBAgAABAgQIEEibgAJo2mZEPLkRGDt2bOjVq1eSz/333x/iByLZCBAgQIAAAQIECBAgQIAAAQIEqiugAFpdb6MVSGDfffcNkydPTjJeuXJluO+++wqUvVQJECBAgAABAgQIECBAgAABAukQUABNxzyIIqcCzZfBNzY25jRLaREgQIAAAQIECBAgQIAAAQIE0iugAJreuRFZDgQmTJhQzmL27NnltgYBAgQIECBAgAABAgQIECBAgEB1BBRAq+NslIIKHHnkkeGcc85Jsn/ttdfCE088UVAJaRMgQIAAAQIECBAgQIAAAQIEaiOgAFobd6MWSMAy+AJNtlQJECBAgAABAgQIECBAgACB1AkogKZuSgSUN4Hmy+DdBzRvsysfAgQIECBAgAABAgQIECBAIO0CCqBpnyHxZV5g+PDh4dhjj03yeP7558M777yT+ZwkQIAAAQIECBAgQIAAAQIECBDIioACaFZmSpyZFqivry/Hf9ttt5XbGgQIECBAgAABAgQIECBAgAABAt0roADavb56J5AINL8PaENDAxUCBAgQIECAAAECBAgQIECAAIEqCSiAVgnaMMUWOOOMM8K+++6bICxYsCCsX7++2CCyJ0CAAAECBAgQIECAAAECBAhUSUABtErQhim2QK9evcIVV1yRIGzdujXcddddxQaRPQECBAgQIECAAAECBAgQIECgSgIKoFWCNgwBy+C9BggQIECAAAECBAgQIECAAAEC1RdQAK2+uRELKjBq1KjQr1+/JPsHHnggbNu2raAS0iZAgAABAgQIECBAgAABAgQIVE9AAbR61kYquMDAgQPDxRdfnCisXbs2TJ8+veAi0idAgAABAgQIECBAgAABAgQIdL+AAmj3GxuBQFnAMvgyhQYBAgQIECBAgAABAgQIECBAoCoCCqBVYTYIgY8FLrjggtCjR4/kwX333YeFAAECBAgQIECAAAECBAgQIECgmwUUQLsZWPcEmgscdNBBYcyYMcmut99+Ozz00EPNn9YmQIAAAQIECBAgQIAAAQIECBCosIACaIVBdUegLYHmy+AbGxvbOtzzBAgQIECAAAECBAgQIECAAAECXRBQAO0CnlMJdEZg4sSJ5dNmz55dbmsQIECAAAECBAgQIECAAAECBAhUXkABtPKmeiSwR4HPfOYzYfjw4ckxixcvDkuWLNnj8Z4kQIAAAQIECBAgQIAAAQIECBDovIACaOftnEmg0wKWwXeazokECBAgQIAAAQIECBAgQIAAgQ4JKIB2iMvBBCojUF9fX+7IfUDLFBoECBAgQIAAAQIECBAgQIAAgYoLKIBWnFSHBNoWOPnkk8OBBx6YHPjUU0+F999/v+2THEGAAAECBAgQIECAAAECBAgQINBhAQXQDpM5gUDXBXr06BGuvPLKpKOmpqZw++23d71TPRAgQIAAAQIECBAgQIAAAQIECOwioAC6C4kdBKoj0Pw+oA0NDdUZ1CgECBAgQIAAAQIECBAgQIAAgYIJKIAWbMKlmx6Bc889NwwcODAJ6KGHHgqbNm1KT3AiIUCAAAECBAgQIECAAAECBAjkREABNCcTKY3sCfTr1y9ccsklSeAffvhh+N3vfpe9JERMgAABAgQIECBAgAABAgQIEEi5gAJoyidIePkWsAw+3/MrOwIECBAgQIAAAQIECBAgQKD2AgqgtZ8DERRYYNy4caFXr16JwJw5c8L27dsLrCF1AgQIECBAgAABAgQIECBAgEDlBRRAK2+qRwLtFthvv/3CxIkTk+NXrFgR5s6d2+5zHUiAAAECBAgQIECAAAECBAgQINC2gAJo20aOINCtApbBdyuvzgkQIECAAAECBAgQIECAAIGCCyiAFvwFIP3aC5SuAI2RzJo1q/YBiYAAAQIECBAgQIAAAQIECBAgkCMBBdAcTaZUsilw1FFHhREjRiTBv/rqq+Gpp57KZiKiJkCAAAECBAgQIECAAAECBAikUKB3CmPqUkgrV64Mt9xyS3jllVfCxo0bwwknnBBOOeWUMHr06F36/fnPfx7Wr1+/y/6WO3r27Bm+/vWv77R78+bN4c477wxPPvlkWL16dTj66KPD8OHDw6RJk8ofarPTCR4Q2INAXAa/YMGC5IjGxsZw2mmn7eFoTxEgQIAAAQIECBAgQIAAAQIECLRXIFcF0Mcffzx861vfCps2bUry32effcLLL78cfvOb34QLL7wwXH/99TsVJ2fMmBHiB8+0tbUsgK5ZsyZcc8014a233kpO3X///cPMmTOTr0cffTR897vfDX379m2rW88TKAvU19eHf/3Xf00exwLo9773vfJzGgQIECBAgAABAgQIECBAgAABAp0XyE0BdPny5eH//b//lxQ/L7vssnD55ZeHgw46KDzxxBPhpz/9aZg+fXqIBdGvfe1rZa2//du/LRdLyzv/1Ghqagq/+MUvwrp168JFF12009Pf//73k+LnWWedFb797W+HwYMHh6VLl4ZvfvOb4cEHHwz/8z//E77xjW/sdI4HBPYkcOyxx4YjjjgieV0tXrw4vPvuu+GQQw7Z0ymeI0CAAAECBAgQIECAAAECBAgQaIdAbu4BGq/AjMvZDzvssHDttdeGQw89NLnaM95b8a/+6q8SigceeGAnkgkTJoTPfe5zrX7FZe2x+BmX0F933XXl81544YWwcOHCMGDAgHDDDTckxc/4ZBz3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C5PxHqC33npr+PWvfx3ikvj4Fbd4385rr7027O6T1+NVm3H71Kc+lXxv6z/nn39+uPHGG5MC6Lx580L8itsnPvrwpOuuuy4pXLXVh+cJtCUQl8HHAmjcGhsbFUDbAvM8AQIECBAgQIAAAQIECBAgQKAVgdwUQGNuffv2DV/84hfD1VdfHd5+++2wevXqEJe0DxkypJXU/7zrS1/6UohfHdni1aV33HFHsuQ9flBNLLLGD6/p2TM3dxXoCIdju0Ggvr4+fP/73096jgXQf/mXf+mGUXRJgAABAgQIECBAgAABAgQIEMi3QK4KoKWpip/0Hq/GjF/dvcXialsF1u6OQf/5FIhF9lhYX758eXjiiSfC+++/H/bff/98JisrAgQIECBAgAABAgQIECBAgEA3CbhcsZtgdUugqwLxtg6XX3550k1TU1O48847u9ql8wkQIECAAAECBAgQIECAAAEChRNQAC3clEs4SwJxGXxpi8vgbQQIECBAgAABAgQIECBAgAABAh0TUADtmJejCVRV4Lzzzgt77bVXMub8+fPDpk2bqjq+wQgQIECAAAECBAgQIECAAAECWRdQAM36DIo/1wL9+/cPpatAN2zYEO65555c5ys5AgQIECBAgAABAgQIECBAgEClBRRAKy2qPwIVFqirqyv32NDQUG5rECBAgAABAgQIECBAgAABAgQItC2gANq2kSMI1FRg/PjxoVevXkkM9913X9ixY0dN4zE4AQIECBAgQIAAAQIECBAgQCBLAgqgWZotsRZSYP/99w8XXHBBkvvy5cvDvHnzCukgaQIECBAgQIAAAQIECBAgQIBAZwQUQDuj5hwCVRawDL7K4IYjQIAAAQIECBAgQIAAAQIEciOgAJqbqZRIngUmTpxYTm/WrFnltgYBAgQIECBAgAABAgQIECBAgMCeBRRA9+zjWQKpEPjkJz8ZzjzzzCSW3//+9+GZZ55JRVyCIECAAAECBAgQIECAAAECBAikXUABNO0zJD4CfxKwDN5LgQABAgQIECBAgAABAgQIECDQcQEF0I6bOYNATQTq6+vL4zY2NpbbGgQIECBAgAABAgQIECBAgAABArsXUADdvY1nCKRK4Pjjjw+HH354EtOzzz4bli1blqr4BEOAAAECBAgQIECAAAECBAgQSKOAAmgaZ0VMBHYjMHXq1OSZHTt2hNtvv303R9lNgAABAgQIECBAgAABAgQIECBQElAALUn4TiADApbBZ2CShEiAAAECBAgQIECAAAECBAikSkABNFXTIRgCexYYMWJEGDx4cHLQI488Ej744IM9n+BZAgQIECBAgAABAgQIECBAgEDBBRRAC/4CkH62BHr37h2mTJmSBL158+bQ0NCQrQRES4AAAQIECBAgQIAAAQIECBCosoACaJXBDUegqwKWwXdV0PkECBAgQIAAAQIECBAgQIBAkQQUQIs023LNhcCYMWNC3759k1zmzJkTtm3blou8JEGAAAECBAgQIECAAAECBAgQ6A4BBdDuUNUngW4U2GeffcKFF16YjLBmzZowe/bsbhxN1wQIECBAgAABAgQIECBAgACBbAsogGZ7/kRfUIG6urpy5u4DWqbQIECAAAECBAgQIECAAAECBAjsIqAAuguJHQTSLzBx4sTQo0ePJNBZs2alP2AREiBAgAABAgQIECBAgAABAgRqJKAAWiN4wxLoisAhhxwSRo4cmXTx5ptvhgULFnSlO+cSIECAAAECBAgQIECAAAECBHIroACa26mVWN4FLIPP+wzLjwABAgQIECBAgAABAgQIEKiEgAJoJRT1QaAGApMmTSqP2tjYWG5rECBAgAABAgQIECBAgAABAgQI/FlAAfTPFloEMiVw/PHHhxNPPDGJ+aWXXgp//OMfMxW/YAkQIECAAAECBAgQIECAAAEC1RBQAK2GsjEIdJNA82Xw06ZN66ZRdEuAAAECBAgQIECAAAECBAgQyK6AAmh2507kBEJ9fX1ZwTL4MoUGAQIECBAgQIAAAQIECBAgQKAsoABaptAgkD2BU089NRxwwAFJ4I8//nhYvXp19pIQMQECBAgQIECAAAECBAgQIECgGwUUQLsRV9cEulugZ8+e4bLLLkuGaWpqCnfddVd3D6l/AgQIECBAgAABAgQIECBAgECmBBRAMzVdgiWwq4Bl8Lua2EOAAAECBAgQIECAAAECBAgQKAkogJYkfCeQUYHzzz8/7LXXXkn08+bNC5s3b85oJsImQIAAAQIECBAgQIAAAQIECFReQAG08qZ6JFBVgf79+4eLL744GXPDhg3h3nvvrer4BiNAgAABAgQIECBAgAABAgQIpFlAATTNsyM2Au0UsAy+nVAOI0CAAAECBAgQIECAAAECBAonoABauCmXcB4FLrjg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gAABAgQIEMiqgAJoVmdO3AS6UcAy+G7E1TUBAgQIECBAgAABAgQIECBQVQEF0KpyG4xANgTq6urKgTY0NJTbGgQIECBAgAABAgQIECBAgACBrAkogGZtxsRLoAoCw4cPD4ceemgy0pNPPhlWrFhRhVENQYAAAQIECBAgQIAAAQIECBCovIACaOVN9Ugg8wI9evQIl156aZLH9u3bw1133ZX5nCRAgAABAgQIECBAgAABAgQIFFNAAbSY8y5rAm0KNF8G39jY2ObxDiBAgAABAgQIECBAgAABAgQIpFFAATSNsyImAikQGDlyZNhnn32SSB544IHw4YcfpiAqIRAgQIAAAQIECBAgQIAAAQIEOiagANoxL0cTKIxA3759w+c+97kk302bNoV77rmnMLlLlAABAgQIECBAgAABAgQIEMiPgAJofuZSJgQqLmAZfMVJdUiAAAECBAgQIECAAAECBAhUWUABtMrghiOQJYEJEyaEPn36JCHPmjUrNDU1ZSl8sRIgQIAAAQIECBAgQIAAAQIEggKoFwEBArsVGDx4cBg/fnzy/KpVq8K8efN2e6wnCBAgQIAAAQIECBAgQIAAAQJpFFAATeOsiIlAigTq6+vL0fg0+DKFBgECBAgQIECAAAECBAgQIJARAQXQjEyUMAnUSmDy5Mnloe+9995yW4MAAQIECBAgQIAAAQIECBAgkAUBBdAszJIYCdRQ4IgjjghnnXVWEsEf/vCH8PTTT9cwGkMTIECAAAECBAgQIECAAAECBDomoADaMS9HEyikgGXwhZx2SRMgQIAAAQIECBAgQIAAgVwIKIDmYholQaB7Berq6soDNDQ0lNsaBAgQIECAAAECBAgQIECAAIG0CyiApn2GxEcgBQLHHXdc+OQnP5lE8txzz4W33347BVEJgQABAgQIECBAgAABAgQIECDQtoACaNtGjiBA4COByy67rOxw1113ldsaBAgQIECAAAECBAgQIECAAIE0CyiApnl2xEYgRQKWwadoMoRCgAABAgQIECBAgAABAgQItFtAAbTdVA4kUGyBESNGhP333z9BeOSRR8LatWuLDSJ7AgQIECBAgAABAgQIECBAIBMCCqCZmCZBEqi9QK9evcIll1ySBLJ169bQ2NhY+6BEQIAAAQIECBAgQIAAAQIECBBoQ0ABtA0gTxMg8GeB5svgFUD/7KJF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LnnjEsipQMeOHeOoo45Ks0ueAfroo4/mNFNpESBAgAABAgQIECBAgAABAtUgoABaDbMkRgJVJtD0NvjZs2dXWfTCJUCAAAECBAgQIECAAAECBPIkoACap9mUC4EKETjmmGOivv6vXy8PPPBAhUQlDAIECBAgQIAAAQIECBAgQKAWBRRAa3HW5UygyAJvetOb4v3vf386ygsvvBA/+clPijyi7gkQIECAAAECBAgQIECAAAECOxZQAN2xi60ECOyhgNvg9xDQ6QQIECBAgAABAgQIECBAgEBBBBRAC8KoEwIEthc49thjs02eA5pRaBAgQIAAAQIECBAgQIAAAQIlFlAALTG44QjUisDb3/72OPDAA9N0f/3rX8dvf/vbWkldngQIECBAgAABAgQIECBAgEAFCSiAVtBkCIVA3gSGDBmSpXT33XdnbQ0CBAgQIECAAAECBAgQIECAQKkEFEBLJW0cAjUo0PQ5oLNmzapBASkTIECAAAECBAgQIECAAAEC5RZQAC33DBifQI4F+vXrF926dUsznD9/fvzpT3/KcbZSI0CAAAECBAgQIECAAAECBCpRQAG0EmdFTARyIlBXVxcnnnhims3mzZvDy5ByMrHSIECAAAECBAgQIECAAAECVSSgAFpFkyVUAtUo4Db4apw1MRMgQIAAAQIECBAgQIAAgfwIKIDmZy5lQqAiBQ477LDYa6+90tgef/zx+Mtf/lKRcQqKAAECBAgQIECAAAECBAgQyKeAAmg+51VWBCpGoF27djF48OA0nnXr1sVDDz1UMbEJhAABAgQIECBAgAABAgQIEMi/gAJo/udYhgTKLuA2+LJPgQAIECBAgAABAgQIECBAgEDNCiiA1uzUS5xA6QQGDRoUDQ0N6YBz586NLVu2lG5wIxEgQIAAAQIECBAgQIAAAQI1LaAAWtPTL3kCpRHYd999Y+DAgelgK1eujKeeeqo0AxuFAAECBAgQIECAAAECBAgQqHkBBdCa/wgAIFAagaa3wc+ePbs0gxqFAAECBAgQIECAAAECBAgQqHkBBdCa/wgAIFAagWOPPTYb6P7778/aGgQIECBAgAABAgQIECBAgACBYgoogBZTV98ECGQCb33rW+Pggw9O15csWRK/+MUvsn0aBAgQIECAAAECBAgQIECAAIFiCSiAFktWvwQIvE7AbfCvI7GBAAECBAgQIECAAAECBAgQKLKAAmiRgXVPgMDfBIYMGZKteA5oRqFBgAABAgQIECBAgAABAgQIFFFAAbSIuLomQGBbgXe9612R3AqfLM8880wsX7582wOsESBAgAABAgQIECBAgAABAgQKLKAAWmBQ3REgsGuBoUOHpgds3bo17r333l0fbC8BAgQIECBAgAABAgQIECBAYA8FFED3ENDpBAi0TKDpc0BnzZrVspMdTYAAAQIECBAgQIAAAQIECBBooYACaAvBHE6AwJ4JvP/9749999037eSpp56KV155Zc86dDYBAgQIECBAgAABAgQIECBAYBcCCqC7wLGLAIHCCzQ0NMTxxx+fdvzaa6/F/fffX/hB9EiAAAECBAgQIECAAAECBAgQ+D8BBVAfBQIESi7gNviSkxuQAAECBAgQIECAAAECBAjUrIACaM1OvcQJlE/gwx/+cLRr1y4N4OGHH46NGzeWLxgjEyBAgAABAgQIECBAgAABArkWUADN9fRKjkBlCuy1115x5JFHpsG9/PLL8fjjj1dmoKIiQIAAAQIECBAgQIAAAQIEql5AAbTqp1ACBKpTwG3w1TlvoiZAgAABAgQIECBAgAABAtUmoABabTMmXgI5ERg8eHDU1dWl2XgRUk4mVRoECBAgQIAAAQIECBAgQKACBRRAK3BShESgFgS6desW//qv/5qm+vvf/z5++tOf1kLaciRAgAABAgQIECBAgAABAgRKLKAAWmJwwxEg8DeBprfBz549+287tAgQIECAAAECBAgQIECAAAECBRJQAC0QpG4IEGi5wHHHHZedpACaUWgQIECAAAECBAgQIECAAAECBRRQAC0gpq4IEGiZwDve8Y545zvfmZ60aNGiWLp0acs6cDQBAgQIECBAgAABAgQIECBAYDcCCqC7AbKbAIHiCjS9Df6ee+4p7mB6J0CAAAECBAgQIECAAAECBGpOQAG05qZcwgQqS2DIkCFZQG6Dzyg0CBAgQIAAAQIECBAgQIAAgQIJKIAWCFI3BAi0TuCQQw6JN73pTenJP/rRj+Kll15qXUfOIkCAAAECBAgQIECAAAECBAjsQEABdAcoNhEgUDqB+vr6aLwKdPPmzXHfffeVbnAjESBAgAABAgQIECBAgAABArkXUADN/RRLkEDlCzR9DuisWbMqP2AREiBAgAABAgQIECBAgAABAlUjoABaNVMlUAL5FRg4cGB07NgxTfAHP/hBrF+/Pr/JyowAAQIECBAgQIAAAQIECBAoqYACaEm5DUaAwI4E2rdvH8ccc0y6a926dfHwww/v6DDbCBAgQIAAAQIECBAgQIAAAQItFlAAbTGZEwgQKIaA2+CLoapPAgQIECBAgAABAgQIECBAQAHUZ4AAgYoQOProo6NNmzZpLA8++GBs2bKlIuISBAECBAgQIECAAAECBAgQIFDdAgqg1T1/oieQG4H99tsvDjvssDSfP/7xj/H000/nJjeJECBAgAABAgQIECBAgAABAuUTUAAtn72RCRDYTsBt8NuBWCVAgAABAgQIECBAgAABAgT2WEABdI8JdUCAQKEEjjvuuKyrOXPmZG0NAgQIECBAgAABAgQIECBAgEBrBRRAWyvnPAIECi7Qs2fPOOigg9J+n3322fiv//qvgo+hQwIECBAgQIAAAQIECBAgQKC2BBRAa2u+ZUug4gWa3gY/e/bsio9XgAQIECBAgAABAgQIECBAgEBlCyiAVvb8iI5AzQkMGTIky1kBNKPQIECAAAECBAgQIECAAAECBFopoADaSjinESBQHIF3v/vd0aNHj7Tzn/3sZ/GHP/yhOAPplQABAgQIECBAgAABAgQIEKgJAQXQmphmSRKoLoHGq0C3bt0as2bNqq7gRUuAAAECBAgQIECAAAECBAhUlEBJC6CvvvpqrF27tqIABEOAQOUJNBZAk8jcBl958yMiAgQIECBAgAABAgQIECBQTQJFLYCuXLkyRowYER/84Aeje/fusddee8X48eNTn6VLl8YHPvCBuOuuu2LLli3VZCZWAgSKLJB8N+yzzz7pKE8++WS88sorRR5R9wQIECBAgAABAgQIECBAgEBeBYpSAE1uW/3KV74SvXv3jiuuuCKeeuqp1z3H7/nnn49///d/j5NPPjk+/elPx8aNG/NqLC8CBFoo0NDQEMcdd1x61oYNG+LBBx9sYQ8OJ0CAAAECBAgQIECAAAECBAj8VaAoBdCk+Dls2LBYvXp1JIWMgw46KA444IBtzDdt2hRt27ZNt916661x5plnbrPfCgECtS1wwgknZACeA5pRaBAgQIAAAQIECBAgQIAAAQItFCh4AfSXv/xljBkzJg1j8ODB8dxzz8UzzzwTSbvp8uEPfzjdl9zqmiw33nhjLF68uOkh2gQI1LDAkUceGe3atUsFHnrooUj+aGIhQIAAAQIECBAgQIAAAQIECLRUoOAF0CuvvDKSW1aTqz7vvPPO6NGjx05jestb3hIPP/xw7LfffrF58+a47rrrdnqsHQQI1JbA3nvvHUcccUSadHI1+RNPPFFbALIlQIAAAQIECBAgQIAAAQIECiJQ8ALof/7nf6aBJVeBvvGNb9xtkMkxjVeHPvvss7s93gEECNSOgNvga2euZUqAAAECBAgQIECAAAECBIolUNACaHIV56JFi9JYDz744GbHPGjQoPTY//mf/2n2OQ4kQCD/Ascee2zU1dWlic6ZMyf/CcuQAAECBAgQIECAAAECBAgQKLhAQQugbdq0ib322isN8uWXX252sCtXrkyP7d69e7PPcSABAvkX+Pu///t473vfmya6bNmyWLBgQf6TliEBAgQIECBAgAABAgQIECBQUIGCFkCTyN797nenAT722GPNDjR5Dmiy9OnTp9nnOJAAgdoQcBt8bcyzLAkQIECAAAECBAgQIECAQLEECl4Afc973pPGOmnSpFiyZMlu477hhhti7ty56XEtuW1+tx07gACBXAgMGTIky2P27NlZW4MAAQIECBAgQIAAAQIECBAg0ByBghdAL7jggkje7v7KK69Ev3794pprrokXX3zxdbH87ne/izPOOCNOP/30dN+AAQNi6NChrzvOBgIEalvg7W9/e/Tq1StF+OUvfxnPP/98bYPIngABAgQIECBAgAABAgQIEGiRQMELoPvss0/cdNNNUV9fH8lzQM8888zo1q1bWghNIrvtttti//33j549e8Z1110XW7dujQ4dOkRyJWhyjoUAAQLbC5x44onZpnvvvTdraxAgQIAAAQIECBAgQIAAAQIEdidQlIrjwIED4yc/+Un28pIkiA0bNqSx/OEPf4g//elPWVyHH354/OxnP4sDDjgg26ZBgACBpgJug2+qoU2AAAECBAgQIECAAAECBAi0RKChJQe35NhDDjkkfvSjH8Vdd92V/n722Wcj+Umu+Ozdu3d6S2tSKD3++ONb0q1jCRCoQYHk2cJ/93d/F3/84x/j3//932PVqlWx33771aCElAkQIECAAAECBAgQIECAAIGWChStAJoEUldXFyeffHL609LAHE+AAIFGgeTxGMkfS77zne/E5s2bY86cOXHaaac17vabAAECBAgQIECAAAECBAgQILBTgaLcAr/T0f5vxwsvvBDXX399+gzQ5IouCwECBHYn4Db43QnZT4AAAQIECBAgQIAAAQIECOxIoCgF0E2bNsWsWbPihBNOiMcff3ybcSdMmBBvfvOb07e/J2+B//u///s49dRT01vjtznQCgECBJoIJM8L7tixY7rlkUceifXr1zfZq0mAAAECBAgQIECAAAECBAgQ2LFAUQqgY8aMieStzffdd18sXrw4G/n++++PSZMmZetJY8uWLXHzzTfHxIkTt9luhQABAk0F2rdvH4MGDUo3vfrqq/Hoo4823a1NgAABAgQIECBAgAABAgQIENihQMELoPPmzYuZM2emgzU0NESHDh2ygSdPnpxe6dmmTZsYNmxYLFiwIM4+++x0f1IYTdYtBAgQ2JlAclV545JcZW4hQIAAAQIECBAgQIAAAQIECOxOoOAvQbruuuvSqzr79OkTd999d/rG9ySI3/3udzF//vw0nqFDh2ZF0n/5l3+JX//61/HYY4+lb3c++OCDdxez/QQI1KjAMcccE8kfUJIXIT3wwAPpd03ygiQLAQIECBAgQIAAAQIECBAgQGBnAgWvHPzqV79Kx0re0Ny7d+9s3AcffDBrn3TSSVk7aSRvik+WZ555Jv3tfwgQILAjgS5dusShhx6a7nrxxRfjxz/+8Y4Os40AAQIECBAgQIAAAQIECBAgkAkUtAC6devW+O///u+086OOOiobJGnMnTs3XU+u3jryyCO32Ze8CClZFi1atM12KwQIENhewG3w24tYJ0CAAAECBAgQIECAAAECBHYlUNACaPJCo9deey0db++9987GTbY98cQT6fohhxwS++67b7Yvafzxj39M1/fZZ59ttlshQIDA9gLHH398til50ZqFAAECBAgQIECAAAECBAgQILArgYIWQJOrO9/61rem4zVeCZqsJC9GWrt2bbp9+ytDk43J8z+TpUePHulv/0OAAIGdCbztbW+Ld7/73enu3/zmN+kzhHd2rO0ECBAgQIAAAQIECBAgQIAAgYIWQBPO9773vanqhAkT4rnnnot169bFmDFjMulTTjkla69fvz59GdIdd9yRbhswYEC2T4MAAQI7E3Ab/M5kbCdAgAABAgQIECBAgAABAgS2Fyh4AXTYsGHpGMkb39/5znfGm970pliwYEG6bdCgQfFP//RPafvpp5+O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mLlMV1IECNSCQFIAbVzuu+++xqbfBAgQIECAAAECBAgQIECAQA0KFPwK0Jtuuim9zX1Xt7rvzLl9+/Y722U7AQIEmi3wD//wD/Gud70rfvnLX8Z///d/x+LFiyO5Nd5CgAABAgQIECBAgAABAgQI1J5Awa8AnT59erz73e+OqVOnxhve8IbYZ599mv2jAFp7H0AZEyiWQNOrQJv7GI5ixaJfAgQIECBAgAABAgQIECBAoHwCBS+A3nLLLfH73/8+rr322mjXrl35MjMyAQI1LdC0ADp79uyatpA8AQIECBAgQIAAAQIECBCoZYGC3gK/efPmSF56lCwDBgyINm3alNz2T3/6U9x6663x7LPPxl/+8pc48MAD46CDDorDDjtsl7E8/fTTMX/+/PRW2bq6ukhuof3Yxz4WPXr02OF5GzZsiLvuuit+9rOfxZ///Ofo1atX/PM//3MMGjSoLHnvMEgbCdSwwMEHHxxvfvOb0z/IJP9s//GPf0yvRq9hEqkTIECAAAECBAgQIECAAIGaFChoATQpeB566KHx2GOPxU9/+tPYsmVL+jzQUskmRY5x48bF+vXr0yH33nvvtKB5zz33xDHHHBPJG+q3L8pu3Lgxrrrqqrj33nvTczp37pyev2jRovRt9kl/RxxxxDYprF69Os4666xYtmxZun2//faLhx56KP350Y9+FOPHj09v/9/mJCsECJRUIPlDxvHHHx/f+MY30u+i5J/R5I8aFgIECBAgQIAAAQIECBAgQKC2BAp+C/zkyZOjU6dO8Yc//CHOOOOMWLNmTUlEk6u7Jk6cmBYvP/KRj8Qdd9wRc+bMieSZpD179kyLmd/85jdfF8v111+fFj/333//+PrXvx7JG6MffvjhNPbkitbkWaYvvvjiNuddcsklafHzPe95T9x///2R3F57++23xz/+4z/GU089FV/72te2Od4KAQLlERgyZEg28Ny5c7O2BgECBAgQIECAAAECBAgQIFA7AgW9AjRhS156dM0116RXW95www1pcfGd73xneot4UohMXoy0syW5evQDH/jAznbvcntyddcrr7wS/+///b8455xzsitP3/ve96bbJ02aFE8++WScffbZWT+vvvpqGl/yxvoJEyZE3759s32nnXZazJs3L72VPvl9yimnpPt+9atfpVe3vvGNb4yk2Nv44qZk3JkzZ8bQ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/SiSK0GbXv3dGMlee+3V2PSbAAECBAgQIECAAAECBAgQyKnA3+4Hr/IEk8Jm8jbnH//4x/GJT3wi+vXrFwcddFAsWbIkvSozeQPqRz/60UgKmI1L8hKk888/PyZOnBjXXnttzJ8/Pw455JBIXhjw0EMPpQ9tHz16dBx44IGNp6QP0P785z8fF198cVx22WXpeL169Ypf/vKXaTu51X7UqFEetJ2JaRAor8D+++8ft956a/rPa/J98Oijj8a0adPSoC699NJo/ONJeaM0OgECBAgQIECAAAECBAgQIFAsgdwUQJM3+yXPAL3tttvi5ptvjuSW+OQnWZLn/J1zzjk7fNbfoYceGt/61rdiypQpaRHzF7/4RXpOctts8nb4wYMHp+tN/yc558orr0wLKk888UQkP8mSXBk6bNiw6Nu3b9PDtQkQqACBvffeO/1jxtve9ra47rrr0qu1k392kyvADz744AqIUAgECBAgQIAAAQIECBAgQIBAMQRyUwBNcJIrOk877bT45Cc/Gb///e/jz3/+c/To0SO9zX1XeEmx8zvf+U6sW7cukpcYJW9/391b3JOrS++88860iLJs2bK0yNqtW7eor8/NUwV2RWYfgaoV6NChQyRXdo8cOTLNIbma+4EHHqjafAROgAABAgQIECBAgAABAgQI7Fogl9W65Fl/ydWYSZEyecZnc5ekMNKnT5/dFj+b9pf0n7zwqHv37oqfTWG0CVSwwOmnnx6dO3dOI0ye5bto0aIKjlZoBAgQIECAAAECBAgQIECAwJ4I5LIAuicgziVAIP8CnTp1yq4ATZ4PnFwFaiFAgAABAgQIECBAgAABAgTyKaAAms95lRUBArsR+NKXvhQdO3ZMj5o9e3b6wrTdnGI3AQIECBAgQIAAAQIECBAgUIUCCqBVOGlCJkBgzwWSx1ecd955aUebN2+OCRMm7HmneiBAgAABAgQIECBAgAABAgQqTkABtOKmREAECJRK4Oyzz4727dunw33/+9+P5IVmFgIECBAgQIAAAQIECBAgQCBfAgqg+ZpP2RAg0AKBbt26xVlnnZWesXHjxpg0aVILznYoAQIECBAgQIAAAQIECBAgUA0CCqDVMEtiJECgaALnnntutG3bNu3/lltuiRdffLFoY+mYAAECBAgQIECAAAECBAgQKL2AAmjpzY1IgEAFCfTo0SPOOOOMNKL169fHpZdeWkHRCYUAAQIECBAgQIAAAQIECBDYUwEF0D0VdD4BAlUvMGzYsKiv/+vX4Q033BCrVq2q+pwkQIAAAQIECBAgQIAAAQIECPxVQAHUJ4EAgZoX6NWrV5x66qmpw9q1a2Pq1Kk1bwKAAAECBAgQIECAAAECBAjkRUABNC8zKQ8CBPZIYPjw4VFXV5f28e1vfzvWrFmzR/05mQABAgQIECBAgAABAgQIEKgMAQXQypgHURAgUGaBPn36xCmnnJJGsXr16pg5c2aZIzI8AQIECBAgQIAAAQIECBAgUAgBBdBCKOqDAIFcCIwYMSLL4xvf+EasW7cuW9cgQIAAAQIECBAgQIAAAQIEqlNAAbQ6503UBAgUQaBfv35x/PHHpz2vXLkyrrrqqiKMoksCBAgQIECAAAECBAgQIECglAIKoKXUNhYBAhUvMHLkyCzGr33ta/Haa69l6xoECBAgQIAAAQIECBAgQIBA9QkogFbfnImYAIEiCgwYMCCOPPLIdITly5fHNddcU8TRdE2AAAECBAgQIECAAAECBAgUW0ABtNjC+idAoOoExo4dm8V85ZVXxqZNm7J1DQIECBAgQIAAAQIECBAgQKC6BBRAq2u+REuAQAkEDj300Ojfv3860vPPPx/XX399CUY1BAECBAgQIECAAAECBAgQIFAMAQXQYqjqkwCBqheYNGlSlsPMmTNjy5Yt2boGAQIECBAgQIAAAQIECBAgUD0CCqDVM1ciJUCghAJHHXVU9O3bNx1x8eLF8b3vfa+EoxuKAAECBAgQIECAAAECBAgQKJSAAmihJPVDgEDuBCZOnJjldMUVV2RtDQIECBAgQIAAAQIECBAgQKB6BBRAq2euREqAQIkFjj/++Ojdu3c66sKFC+Ouu+4qcQSGI0CAAAECBAgQIECAAAECBPZUQAF0TwWdT4BAbgXq6+uj6VWgM2bMyG2uEiNAgAABAgQIECBAgAABAnkVUADN68zKiwCBggh85CMfiZ49e6Z9zZ8/Px544IGC9KsTAgQIECBAgAABAgQIECBAoDQCCqClcTYKAQJVKtDQ0BAXX3xxFv306dOztgYBAgQIECBAgAABAgQIECBQ+QIKoJU/RyIkQKDMAp/4xCeie/fuaRTz5s2Lxx9/vMwRGZ4AAQIECBAgQIAAAQIECBBoroACaHOlHEeAQM0KtGvXLsaOHZvlP3ny5KytQYAAAQIECBAgQIAAAQIECFS2gAJoZc+P6AgQqBCBz3zmM9G1a9c0mieeeCIWLFhQIZEJgwABAgQIECBAgAABAgQIENiVgALornTsI0CAwP8JdOjQIUaPHp15NH0uaLZRgwABAgQIECBAgAABAgQIEKg4AQXQipsSAREgUKkCn//856Nz585peHPnzo1FixZVaqjiIkCAAAECBAgQIECAAAECBP5PQAHUR4EAAQLNFOjUqVOMGDEiPXrr1q0xfvz4Zp7pMAIECBAgQIAAAQIECBAgQKBcAgqg5ZI3LgECVSlw5plnRseOHdPYZ82aFUuWLKnKPARNgAABAgQIECBAgAABAgRqRUABtFZmWp4ECBREoEuXLnHuueemfW3evDkmTpxYkH51QoAAAQIECBAgQIAAAQIECBRHQAG0OK56JUAgxwLnnHNOtG/fPs3wjjvuiGXLluU4W6kRIECAAAECBAgQIECAAIHqFlAAre75Ez0BAmUQ6NatWyS3wifLxo0b45JLLilDFIYkQIAAAQIECBAgQIAAAQIEmiOgANocJccQIEBgO4Hzzjsv2rZtm269+eab48UXX9zuCKsECBAgQIAAAQIECBAgQIBAJQgogFbCLIiBAIGqE+jRo0ecfvrpadzr16+Pyy67rOpyEDABAgQIECBAgAABAgQIEKgFAQXQWphlORIgUBSB888/P+rr//o1ev3118eqVauKMo5OCRAgQIAAAQIECBAgQIAAgdYLKIC23s6ZBAjUuECvXr3i1FNPTRXWrl0b06ZNq3ER6RMgQIAAAQIECBAgQIAAgcoTUACtvDkREQECVSQwfPjwqKurSyP+1re+FWvWrKmi6IVKgAABAgQIECBAgAABAgTyL6AAmv85liEBAkUU6NOnT5xyyinpCKtXr44rr7yyiKPpmgABAgQIECBAgAABAgQIEGipgAJoS8UcT4AAge0ERowYkW25+uqrY926ddm6BgECBAgQIECAAAECBAgQIFBeAQXQ8vobnQCBHAj069cvjj/++DSTlStXxlVXXZWDrKRAgAABAgQIECBAgAABAgTyIaAAmo95lAUBAmUWGDlyZBbB1772tXjttdeydQ0CBAgQIECAAAECBAgQIECgfAIKoOWzNzIBAjkSGDBgQHz4wx9OM1q+fHlcc801OcpOKgQIECBAgAABAgQIECBAoHoFFECrd+5EToBAhQmMHTs2iyh5GdKmTZuydQ0CBAgQIECAAAECBAgQIECgPAIKoOVxNyoBAjkU+OAHPxj9+/dPM3v++efjhhtuyGGWUiJAgAABAgQIECBAgAABAtUloABaXfMlWgIEKlxg0qRJWYRXXHFFbNmyJVvXIECAAAECBAgQIECAAAECBEovoABaenMjEiCQY4Gjjjoq+vbtm2a4ePHiuPXWW3OcrdQIECBAgAABAgQIECBAgEDlCyiAVv4ciZAAgSoTmDhxYhbxjBkzsrYGAQIECBAgQIAAAQIECBAgUHoBBdDSmxuRAIGcCxx//PHRu3fvNMuFCxfG3XffnfOMpUeAAAECBAgQIECAAAECBCpXQAG0cudGZAQIVKlAfX19TJgwIYt++vTpWVuDAAECBAgQIECAAAECBAgQKK2AAmhpvY1GgECNCJx88snRs2fPNNv58+fHgw8+WCOZS5MAAQIECBAgQIAAAQIECFSWgAJoZc2HaAgQyIlAQ0NDXHTRRVk206ZNy9oaBAgQIECAAAECBAgQIECAQOkEFEBLZ20kAgRqTOCTn/xkdO/ePc163rx58cQTT9SYgHQJECBAgAABAgQIECBAgED5BRRAyz8HIiBAIKcC7dq1iwsvvDDLbvLkyVlbgwABAgQIECBAgAABAgQIECiNgAJoaZyNQoBAjQp89rOfja5du6bZP/7447FgwYIalZA2AQIECBAgQIAAAQIECBAoj4ACaHncjUqAQI0IdOjQIS644IIs2/Hjx2dtDQIECBAgQIAAAQIECBAgQKD4AgqgxTc2AgECNS7whS98ITp37pwqJG+DX7RoUY2LSJ8AAQIECBAgQIAAAQIECJROQAG0dNZGIkCgRgU6deoUw4cPT7PfunVrTJgwoUYlpE2AAAECBAgQIECAAAECBEovoABaenMjEiBQgwJnnXVWdOzYMc383nvvjSVLltSggpQJECBAgAABAgQIECBAgEDpBRRAS29uRAIEalCgS5cu8eUvfznNfPPmzTFp0qQaVJAyAQIECBAgQIAAAQIECBAovYACaOnNjUiAQI0KJAXQ9u3bp9nffvvtsWzZshqVkDYBAgQIECBAgAABAgQIECidgAJo6ayNRIBAjQt069YtzjzzzFRh48aNMXny5BoXkT4BAgQIECBAgAABAgQIECi+gAJo8Y2NQIAAgUzgvPPOi7Zt26br3/3ud2PFihXZPg0CBAgQIECAAAECBAgQIECg8AIKoIU31SMBAgR2KtCjR484/fTT0/3r16+Pyy+/fKfH2kGAAAECBAgQIECAAAECBAjsuYAC6J4b6oEAAQItEjj//POjvv6vX7/XX399rFq1qkXnO5gAAQIECBAgQIAAAQIECBBovoACaPOtHEmAAIGCCPTq1Ss+/elPp32tXbs2pk2bVpB+dUKAAAECBAgQIECAAAECBAi8XkAB9PUmthAgQKDoAiNGjIi6urp0nG9961uxZs2aoo9pAAIECBAgQIAAAQIECBAgUIsCCqC1OOtyJkCg7AJ9+vSJk08+OY1j9erVceWVV5Y9JgEQIECAAAECBAgQIECAAIE8CiiA5nFW5USAQFUIjBw5Movz6quvjnXr1mXrGgQIECBAgAABAgQIECBAgEBhBBRAC+OoFwIECLRYoF+/fnHcccel561cuTK+/vWvt7gPJxAgQIAAAQIECBAgQIAAAQK7FlAA3bWPvQQIECiqwKhRo7L+v/rVr8Zrr72WrWsQIECAAAECBAgQIECAAAECey6gALrnhnogQIBAqwUGDBgQRxxxRHr+8uXLI3khkoUAAQIECBAgQIAAAQIECBAonIACaOEs9USAAIFWCYwbNy47b+bMmbFp06ZsXYMAAQIECBAgQIAAAQIECBDYMwEF0D3zczYBAgT2WOCDH/xg9O/fP+3n+eefjxtvvHGP+9QBAQIECBAgQIAAAQIECBAg8FcBBVCfBAIECFSAwMSJE7MoZsyYEVu2bMnWNQgQIECAAAECBAgQIECAAIHWCyiAtt7OmQQIECiYwKBBg6Jv375pf4sXL47bbrutYH3riAABAgQIECBAgAABAgQI1LKAAmgtz77cCRCoKIEJEyZk8UyfPj1raxAgQIAAAQIECBAgQIAAAQKtF1AAbb2dMwkQIFBQgRNOOCF69+6d9rlw4cK45557Ctq/zggQIECAAAECBAgQIECAQC0KKIDW4qzLmQCBihSor6+P8ePHZ7FNmzYta2sQIECAAAECBAgQIECAAAECrRNQAG2dm7MIECBQFIFTTjklevbsmfY9f/78ePDBB4syjk4JECBAgAABAgQIECBAgECtCCiA1spMy5MAgaoQaGhoiHHjxmWxugo0o9AgQIAAAQIECBAgQIAAAQKtElAAbRWbkwgQIFA8gU996lPRvXv3dIB58+bFE088UbzB9EyAAAECBAgQIECAAAECBHIuoACa8wmWHgEC1SfQrl27GDNmTBb4pZdemrU1CBAgQIAAAQIECBAgQIAAgZYJKIC2zMvRBAgQKInA5z73uejatWs61mOPPRYLFiwoybgGIUCAAAECBAgQIECAAAECeRNQAM3bjMqHAIFcCHTo0CEuuOCCLJcJEyZkbQ0CBAgQIECAAAECBAgQIECg+QIKoM23ciQBAgRKKvCFL3whOnfunI75wAMPxKJFi0o6vsEIECBAgAABAgQIECBAgEAeBBRA8zCLciBAIJcCnTp1iuHDh6e5bd26NSZOnJjLPCVFgAABAgQIECBAgAABAgSKKaAAWkxdfRMgQGAPBc4666zo2LFj2ss999wTS5Ys2cMenU6AAAECBAgQIECAAAECBGpLQAG0tuZbtgQIVJlAly5d4stf/nIa9ebNm2PSpElVloFwCRAgQIAAAQIECBAgQIBAeQUUQMvrb3QCBAjsViApgLZv3z497vbbb49ly5bt9hwHECBAgAABAgQIECBAgAABAn8VUAD1SSBAgECFC3Tr1i2+9KUvpVFu3LgxJk+eXOERC48AAQIECBAgQIAAAQIECFSOgAJo5cyFSAgQILBTgWHDhkXbtm3T/d/97ndjxYoVOz3WDgIECBAgQIAAAQIECBAgQOBvAgqgf7PQIkCAQMUK9OjRIz73uc+l8a1fvz6mTJlSsbEKjAABAgQIECBAgAABAgQIVJKAAmglzYZYCBAgsAuB4cOHR339X7+2r7vuuli1atUujraLAAECBAgQIECAAAECBAgQSAQUQH0OCBAgUCUCvXr1ik996lNptGvXro3p06dXSeTCJECAAAECBAgQIECAAAEC5RNQAC2fvZEJECDQYoGRI0dGXV1det4111wTa9asaXEfTiBAgAABAgQIECBAgAABArUkoABaS7MtVwIEql6gT58+8ZGPfCTNY/Xq1fGVr3yl6nOSAAECBAgQIECAAAECBAgQKKaAAmgxdfVNgACBIgiMGjUq6/XrX/96rFu3LlvXIECAAAECBAgQIECAAAECBLYVUADd1sMaAQIEKl6gX79+ceyxx6Zxrly5Mq6++uqKj1mABAgQIECAAAECBAgQIECgXAIKoOWSNy4BAgT2QOCCCy7I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BdB8zqusCBAgUBUCXbp0iX/7t39LY928eXN4I3xVTJsgCRAgQIAAAQIECBAgUFUCCqBVNV2CJUCAQP4Ehg0bFu3bt08T+973vhfLli3LX5IyIkCAAAECBAgQIECAAIGyCSiAlo3ewAQIECCQCHTr1i0+//nPpxgbN26Myy+/HAwBAgQIECBAgAABAgQIECiYgAJowSh1RIAAAQKtFRgxYkS0bds2Pf2GG26IFStWtLYr5xEgQIAAAQIECBAgQIAAgW0EFEC34bBCgAABAuUQ6NGjR5x22mnp0OvXr4/p06eXIwxjEiBAgAABAgQIECBAgEAOBRRAczipUiJAgEA1CowaNSratGmThv7tb387Vq1aVY1piJkAAQIECBAgQIAAAQIEKkxAAbTCJkQ4BAgQqFWBXr16xcc+9rE0/bVr18bMmTNrlULeBAgQIECAAAECBAgQIFBAAQXQAmLqigABAgT2TGD06NFRV1eXdnL11VfHmjVr9qxDZxMgQIAAAQIECBAgQIBAzQsogNb8RwAAAQIEKkegT58+MXTo0DSg1atXx1VXXVU5wYmEAAECBAgQIECAAAECBKpSQAG0KqdN0AQIEMivQHIVaOPy1a9+NdatW9e46jcBAgQIECBAgAABAgQIEGixgAJoi8mcQIAAAQLFFOjXr18cc8wx6RArV66Ma665ppjD6ZsAAQIECBAgQIAAAQIEci6gAJrzCZYeAQIEqlFgzJgxWdhXXHFFbNiwIVvXIECAAAECBAgQIECAAAECLRFQAG2JlmMJECBAoCQCAwYMiIEDB6ZjLV++PK677rqSjGsQAgQIECBAgAABAgQIEMifgAJo/uZURgQIEMiFwNixY7M8ZsyYEZs2bcrWNQgQIECAAAECBAgQIECAQHMFFECbK+U4AgQIECipwOGHHx79+/dPx1y6dGncfPPNJR3fYAQIECBAgAABAgQIECCQDwEF0HzMoywIECCQS4GLLrooy2vq1KmxZcuWbF2DAAECBAgQIECAAAECBAg0R0ABtDlKjiFAgACBsggMHjw4+vbtm469ePHi+P73v1+WOAxKgAABAgQIECBAgAABAtUroABavXMncgIECOReoK6uLppeBTplypTc5yxBAgQIECBAgAABAgQIECisgAJoYT31RoAAAQIFFhg6dGj07t077XXhwoUxe/bsAo+gOwIECBAg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" width="33%" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAASACAYAAAA+mec7AAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAVAoAMABAAAAAEAAASAAAAAAPPnq6AAAEAASURBVHgB7N0HvJ/T/Qfwkx1iRhISCYkRe9SmZu2ttEbIn5ZSSpWiaOlA1Wqpqll0WDVqlNRorRo1atbekQhiJBIj8//7PvH8/O4vd7v35t7nvs/rdd3n9+zzPs+9+NzznNNlZqkkhQABAgQIECBAgAABAgQIECBAgAABAgUU6FrAOqkSAQIECBAgQIAAAQIECBAgQIAAAQIEMgEBqAeBAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAgADUM0CAAAECBAgQIECAAAECBAgQIECAQGEFBKCFbVoVI0CAAAECBAgQIECAAAECBAgQIEBAAOoZIECAAAECBAgQIECAAAECBAgQIECgsAIC0MI2rYoRIECAAAECBAgQIECAAAECBAgQICAA9QwQIECAAAECBAgQIECAAAECBAgQIFBYAQFoYZtWxQgQIECAAAECBAgQIECAAAECBAgQEIB6BggQIECAAAECBAgQIECAAAECBAgQKKyAALSwTatiBAgQIECAAAECBAgQIECAAAECBAgIQD0DBAgQIECAAAECBAgQIECAAAECBAgUVkAAWtimVTECBAgQIECAAAECBAgQIECAAAECBASgngECBAgQIECAAAECBAgQIECAAAECBAorIAAtbNOqGAECBAgQIECAAAECBAgQIECAAAECAlDPAAECBAgQIECAAAECBAgQIECAAAEChRUQgBa2aVWMAAECBAgQIECAAAECBAgQIECAAAEBqGeAAAECBAgQIECAAAECBAgQIECAAIHCCghAC9u0KkaAAAECBAgQIECAAAECBAgQIECAQHcEBAgQIECAAAECBAi0vcDEiRPT6NGj05tvvpnGjRuXpk+f3vY30QZXnHfeedOQIUPS4MGD08CBA1O3bt3a4KouQYAAAQIECBD4QkAA+oWFJQIECBAgQIAAAQItLvDZZ5+lUaNGpVtuuSW9/vrrWeAZwedHH33U4tdq7yfs2rVrGjRoUBaIRii66qqrpt133z0NGzasvd+6+yNAgAABAgQ6sECXmaXSge/frRMgQIAAAQIECBBodwIzZsxId911V7r88svTNddckyZMmDDbPfbsPVdaoP/ANH//RdL8/QakrgXtGfnJpI/Sh++8lX1N+vC9VNv/fqy77rppxIgRadddd00DBgyYzcoKAgQIECBAgMCXERCAfhk9xxIgQIAAAQIECBCoEHj66afTxRdfnK688sr01ltvlbcsuvTy6SubbJsWGbp0WmDAwLRg6WuueeYrb+8sC9OnTU0Txr+dPnx3XPrg7bHpuYfuSU/9+4405dOPM4LoIbrZZpulPffcM+sZ2rNnz85Co54ECBAgQIBAKwoIQFsR16kJECBAgAABAgQ6h8Ann3ySjj/++PTrX/86Re/PKP0GLZa+sul2abVNt08LL7Zk54BoRi2nfPpJ+t8D/0r//edNpUD03hQhaZQVV1wxC5PXXHPNZpzVIQQIECBAgACBLwQEoF9YWCJAgAABAgQIECDQZIG777477bfffumll15KXUo9GNfdbre01la7pMWWXbnJ5+rsB3z80YT0xN3/SHdedVEaP+b1FD1CDzvssHTCCSekueaaq7PzqD8BAgQIECDQTAEBaDPhHEaAAAECBAgQINC5BWISo6OOOiqdd955GcTAYcPT7kednIYss1LnhmmB2k+d8ln6xyVnpbuuvjjNLPWoXWqppdKFF16YNt544xY4u1MQIECAAAECnU1AANrZWlx9CRAgQIAAAQIEvrTAAw88kE3Y8+abb6Zu3XukzfY6MG024oBs+Uuf3AnKAqNfeDpdeeox6a1Xns/WHXzwwemss87KeoaWd7JAgAABAgQIEGhAQADaAJDNBAgQIECAAAECBCoFnnrqqbT++uuniRMnll5zXyXtfuQv0yLDlq7cxXILCsSYoP+8/IJ0+19+n40PetBBB6VzzjmnBa/gVAQIECBAgEDRBQSg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ndGvpPFj30h9F140DVpqudSzV+8vZTKgNGP8r//1wpc6RxzcUuf50jfiBAQIECBAgACBegQEoPXg2ESAAAECBAgQIEBgTgv07jNPWmzZlbOvOX0vrk+AAAECBAgQ6IgCJkHqiK3mngkQIECAAAECBAgQIECAAAECBAgQaJSAALRRTHYiQIAAAQIECBAgQIAAAQIECBAgQKAjCghAO2KruWcCBAgQIECAAAECBAgQIECAAAECBBolIABtFJOdCBAgQIAAAQIECBAgQIAAAQIECBDoiAIC0I7Yau6ZAAECBAgQIECAAAECBAgQIECAAIFGCQhAG8VkJwIECBAgQIAAAQIECBAgQIAAAQIEOqKAALQjtpp7JkCAAAECBAgQIECAAAECBAgQIECgUQIC0EYx2YkAAQIECBAgQIAAAQIECBAgQIAAgY4oIADtiK3mngkQIECAAAECBAgQIECAAAECBAgQaJSAALRRTHYiQIAAAQIECBAgQIAAAQIECBAgQKAjCghAO2KruWcCBAgQIECAAAECBAgQIECAAAECBBolIABtFJOdCBAgQIAAAQIECBAgQIAAAQIECBDoiAIC0I7Yau6ZAAECBAgQIECAAAECBAgQIECAAIFGCXRv1F52IkCAAAECBAgQIECAQIXAJ5M+Sm+98lyav9/CaaFBi1VsqX/x1acfTR9/NDH1Hzw0DRgyrP6dbSVAgAABAgQItICAALQFEJ2CAAECBAgQIECAQFMELvjRvum5h+9NXz/kuLTB10c26tAZ06enh269Lj32z7+nd8e8lj6dPCktttzKadiKq6fl194oDVlmpUadZ/yYN9I/Lz8vjX7hf+m9sW+k+fsvkoat8JU0tHSeVTfeOvWaa+56zzN54ofpzyf8IL3w6P3l/eZdsF/a7ciT0vLrbFJeV9tCXPucH+yVZs6ckY646KbadrGOAAECBAgQINDiAgLQFid1QgIECBAgQIAAAQJ1C/z7hsuy8LPuPWbf8uG741KEpuNee7HGxhceuS/F1+1/Oift/qNfpTU237HG9uoPd151Ubr5ol+nGdOnlTe988bLKb7+M+qa9ODNV6XvnHxhmnve+cvbKxemfPZp+u0hu6V3R7+aevaeKy2x8prpg7fHpLdffzlddOwBacTRp6Y1ttip8pAay7f+6ew0Y8b0tNqm26WBw4bX2OYDAQIECBAg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oP/ANN9C/VPXbt1rOVvHXxW9OWMW9w/feSv7PqG0/EEsvzM2Tfrw/XIFl1hiibTHHnukESNGpOWXX7683gIBAgQIECBA4MsKCEC/rKDjCRAgQIAAAQIECNQhEL1C4/X4K664It1zzz117NV5Vy+88MLZ2J4Req6zzjqdF0LNCRAgQIAAgVYVEIC2Kq+TEyBAgAABAgQIEJglMGnSpPTGG2+k0aNHpzfffLPG93HjxqUYB7OIZd55502DBw9OQ4YMKX/PlwcNGpS6dOlSxGqrEwECBAgQINCOBASg7agx3AoBAgQIECBAgAABAgQIECBAgAABAi0r0LVlT+dsBAgQIECAAAECBAgQIECAAAECBAgQaD8CAtD20xbuhAABAgQIECBAgAABAgQIECBAgACBFhYQgLYwqNMRIECAAAECBAgQIECAAAECBAgQINB+BASg7act3AkBAgQIECBAgAABAgQIECBAgAABAi0sIABtYVCnI0CAAAECBAgQIECAAAECBAgQIECg/QgIQNtPW7gTAgQIECBAgAABAgQIECBAgAABAgRaWEAA2sKgTkeAAAECBAgQIECAAAECBAie0x4jAABAAElEQVQQIECAQPsREIC2n7ZwJwQIECBAgAABAgQIECBAgAABAgQItLCAALSFQZ2OAAECBAgQIECAAAECBAgQIECAAIH2I9C9/dyKOyFAgAABAgQIFEtgxowZ6bbbbks33HBDeuWVV9LHH39crAp+Xpt55503Lb300mmXXXZJG264YSHrqFIE2lLgxRdfTJdffnl6/PHH03vvvZdmzpzZlpdv9rX8Lmg2nQMJECBAoJUFupT+Zdox/m3ayhBOT4AAAQIECBBoSYHXX389jRgxIt1///0tedp2f65tttkm/fGPf0z9+vVr9/fqBgm0N4H4o8mPf/zjdNppp6Xp06e3t9tr0v1svfXW6U9/+pPfBU1SszMBAgQItJaAALS1ZJ2XAAECBAgQ6LQC77//flp77bXTSy+9lAYNGpQOPPDAtPrqq6foHVXE8uGHH6YHHnggnXvuuemDDz5Ia665Zrr33ntTr169ilhddSLQagKHHXZYOvPMM1O3bt3SyJEjU/xBYeGFF05du3aMkcvy3wXnnXdeit+D8Xvv3//+d+rdu3ermTkxAQIECBBojIAAtDFK9iFAgAABAgQINEHg6KOPTqecckr2P/933HFHWmCBBZpwdMfddcyYMdkr8PG6/9lnn50OPvjgjlsZd06gjQWeeeaZtOKKK6YePXqkUaNGpa997WttfActd7mxY8dmvwtefvnldNZZZ6Xvf//7LXdyZyJAgAABAs0Q6Bh/SmxGxRxCgAABAgQIEJhTAn/729+yS8f/+HeW8DMqvOiii6Zf/vKXWd1zg+yDfxAg0KDA9ddfn431uffee3fo8DMqGj3fTz755KzOfhc02PR2IECAAIE2EBCAtgGySxAgQIAAAQKdS+CNN97IKvyVr3ylc1W8VNu8zrlBpwNQYQLNFMh/ZvKfoWaept0cltcjr1e7uTE3QoAAAQKdUsAs8J2y2VWaAAECBAgQaE2BfI7JGMevs5Xu3Wf952VM5tJWJSaLeeGFF9K7776blllmmWzMxLa6tusQaCmB/Gcm/xlqqfPOqfPk9cjrNafuw3UJECBAgEAICEA9BwQIECBAgAABAh1O4J577kmXXnppevLJJ9P//ve/9Omnn5br0Ldv37T88suneJV43333TV26dClvq1747ne/m+LV47zEZC2vvfZa/rHO70OHDq1xzZ122inFxC+VJSaxuf3228urYlbsSy65pPy5toWnnnoqrbTSSrVt6pTrpk2bltZdd930yCOPlOsfE26ts8465c+VCw8//HD6wx/+ULmq3uWYoGyVVVapdZ+49vnnn5/uv//+9Oijj6Zx48Zl+8bEPnvssUc22VetB1pJgAABAgQItDsBAWi7axI3RIAAAQIECBAgUJfAZ599ln7yk5+kX//616munmUx+3TMPB1fEThGMFlXqDhhwoT09ttvly/X2Nmq45jK0DXOU11iRuzKc8fnukpMGhOTZ8WkWbGszBKIMWUrw8+GXG6++eYstGxov3z7VlttVWsA+s4776Rdd9013X333fmu2fcI3uPrnHPOySb3iQBdIUCAAAECBNq/gDFA238buUMCBAgQIECAAIGSwNNPP531ujv99NPrDD+roaL33mqrrZZuuumm6k3t4nMEur/61a+yV/f//Oc/N7pe7eLmW/km/vvf/6YTTzyxSVd57LHHmrR/bTu/9957aY011pgt/Kzcd8qUKSl6jx533HGVqy0TIECAAAEC7VRAANpOG8ZtESBAgAABAgQIfCEQvS132GGHFK+IV5d55503bbjhhmmzzTbLZp+u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xOvGCgECjReIsDCGTYjfH3fffXc2dm0MaxDjujbl1f3GX7Hl96z+XRCTd7XnMXhbXsAZCRAgQKC9CghA22vLuC8CBAgQIECgQwtEr6d49TNegY8w4+mnn+7Q9Wno5iP4jPEpTzzxxP9n7z7g7Kjq/gH/AgQllCQktBR675EmXUBa6E06UgUBQZASpCsIiCDlRQTllRp6R4ooKFIUFCnSa0ghIRASIAFC++8Z3nv/d2/ubjZ7M5m7u8/5fMKdOzNnzplnloR8OWdOrLzyylM73XECBGoILLPMMtnvFSeeeGL2bto333wz0q+OVEq/F6QR8IMGDepIXddXAgQIEOjEAgLQTvxw3RoBAgQIECBQrMB6660XDzzwQEyYMCELMUorehfbq+nfehrZmkaqtXXhoenfA1ck0HkE+vbtGxdffHFccMEF2e8baTG1aVkIqkgJvxcUqa9tAgQIEGhNQADamo5jBAgQIECAAIHpINCzZ89sVe/pcCmXIECgiwikKfHp1Rnpl0KAAAECBAjUJ2ARpPr81CZAgAABAgQIECBAgAABAgQIECBAoIEFBKAN/HB0jQABAgQIECBAgAABAgQIECBAgACB+gQEoPX5qU2AAAECBAgQIECAAAECBAgQIECAQAMLCEAb+OHoGgECBAgQIECAAAECBAgQIECAAAEC9QkIQOvzU5sAAQIECBAgQIAAAQIECBAgQIAAgQYWEIA28MPRNQIECBAgQIAAAQIECBAgQIAAAQIE6hMQgNbnpzYBAgQIECBAgAABAgQIECBAgAABAg0sIABt4IejawQIECBAgAABAgQIECBAgAABAgQI1CcgAK3PT20CBAgQIECAAAECBAgQIECAAAECBBpYQADawA9H1wgQIECAAAECBAgQIECAAAECBAgQqE9AAFqfn9oECBAgQIAAAQIECBAgQIAAAQIECDSwgAC0gR+OrhEgQIAAAQIECBAgQIAAAQIECBAgUJ+AALQ+P7UJECBAgAABAgQIECBAgAABAgQIEGhgAQFoAz8cXSNAgAABAgQIECBAgAABAgQIECBAoD4BAWh9fmoTIECAAAECBAgQIECAAAECBAgQINDAAgLQBn44ukaAAAECBAgQIECAAAECBAgQIECAQH0CAtD6/NQmQIAAAQIECBAgQIAAAQIECBAgQKCBBQSgDfxwdI0AAQIECBAgQIAAAQIECBAgQIAAgfoEBKD1+alNgAABAgQIECBAgAABAgQIECBAgEADCwhAG/jh6BoBAgQIECBAgAABAgQIECBAgAABAvUJCEDr81ObAAECBAgQIECAAAECBAgQIECAAIEGFhCANvDD0TUCBAgQIECAAAECBAgQIECAAAECBOoTEIDW56c2AQIECBAgQIAAAQIECBAgQIAAAQINLCAAbeCHo2sECBAgQIAAAQIECBAgQIAAAQIECNQnIACtz09tAgQIECBAgAABAgQIECBAgAABAgQaWEAA2sAPR9cIECBAgAABAgQIECBAgAABAgQIEKhPQABan5/aBAgQIECAAAECBAgQIECAAAECBAg0sIAAtIEfjq4RIECAAAECBAgQIECAAAECBAgQIFCfgAC0Pj+1CRAgQIAAAQIECBAgQIAAAQIECBBoYAEBaAM/HF0jQIAAAQIECBAgQIAAAQIECBAgQKA+AQFofX5qEyBAgAABAgQIECBAgAABAgQIECDQwAIC0AZ+OLpGgAABAgQIECBAgAABAgQIECBAgEB9AgLQ+vzUJkCAAAECBAgQIECAAAECBAgQIECggQUEoA38cHSNAAECBAgQIECAAAECBAgQIECAAIH6BASg9fmpTYAAAQIECBAgQIAAAQIECBAgQIBAAwsIQBv44egaAQIECBAgQIAAAQIECBAgQIAAAQL1CQhA6/NTmwABAgQIECBAgAABAgQIECBAgACBBhYQgDbww9E1AgQIECBAgAABAgQIECBAgAABAgTqExCA1uenNgECBAgQIECAAAECBAgQIECAAAECDSwgAG3gh6NrBAgQIECAAAECBAgQIECAAAECBAjUJyAArc9PbQIECBAgQIAAAQIECBAgQIAAAQIEGlhAANrAD0fXCBAgQIAAAQIECBAgQIAAAQIECBCoT0AAWp+f2gQIECBAgAABAgQIECBAgAABAgQINLCAALSBH46uESBAgAABAgQIECBAgAABAgQIECBQn4AAtD4/tQkQIECAAAECBAgQIECAAAECBAgQaGABAWgDPxxdI0CAAAECBAgQIECAAAECBAgQIECgPgEBaH1+ahMgQIAAAQIECBAgQIAAAQIECBAg0MACAtAGfji6RoAAAQIECBAgQIAAAQIECBAgQIBAfQIC0Pr81CZAgAABAgQIECBAgAABAgQIECBAoIEFBKAN/HB0jQABAgQIECBAgAABAgQIECBAgACB+gQEoPX5qU2AAAECBAgQIECAAAECBAgQIECAQAMLCEAb+OHoGgECBAgQIECAAAECBAgQIECAAAEC9QkIQOvzU5sAAQIECBAgQIAAAQIECBAgQIAAgQYWEIA28MPRNQIECBAgQIAAAQIECBAgQIAAAQIE6hMQgNbnpzYBAgQIECBAgAABAgQIECBAgAABAg0sIABt4IejawQIECBAgAABAgQIECBAgAABAgQI1CcgAK3PT20CBAgQIECAAAECBAgQIECAAAECBBpYQADawA9H1wgQIECAAAECBAgQIECAAAECBAgQqE9AAFqfn9oECBAgQIAAAQIECBAgQIAAAQIECDSwgAC0gR+OrhEgQIAAAQIECBAgQIAAAQIECBAgUJ+AALQ+P7UJECBAgAABAgQIECBAgAABAgQIEGhgAQFoAz8cXSNAgAABAgQIECBAgAABAgQIECBAoD4BAWh9fmoTIECAAAECBAgQIECAAAECBAgQINDAAgLQBn44ukaAAAECBAgQIECAAAECBAgQIECAQH0CAtD6/NQmQIAAAQIECBAgQIAAAQIECBAgQKCBBQSgDfxwdI0AAQIECBAgQIAAAQIECBAgQIAAgfoEBKD1+alNgAABAgQIECBAgAABAgQIECBAgEADCwhAG/jh6BoBAgQIECBAgAABAgQIECBAgAABAvUJCEDr81ObAAECBAgQIECAAAECBAgQIECAAIEGFhCANvDD0TUCBAgQIECAAAECBAgQIECAAAECBOoTEIDW56c2AQIECBAgQIAAAQIECBAgQIAAAQINLCAAbeCHo2sECBAgQIAAAQIECBAgQIAAAQIECNQnIACtz09tAgQIECBAgAABAgQIECBAgAABAgQaWEAA2sAPR9cIECBAgAABAgQIECBAgAABAgQIEKhPQABan5/aBAgQIECAAAECBAgQIECAAAECBAg0sIAAtIEfjq4RIECAAAECBAgQIECAAAECBAgQIFCfgAC0Pj+1CRAgQIAAAQIECBAgQIAAAQIECBBoYAEBaAM/HF0jQIAAAQIECBAgQIAAAQIECBAgQKA+AQFofX5qEyBAgAABAgQIECBAgAABAgQIECDQwAIC0AZ+OLpGgAABAgQIECBAgAABAgQIECBAgEB9AgLQ+vzUJkCAAAECBAgQIECAAAECBAgQIECggQUEoA38cHSNAAECBAgQIECAAAECBAgQIECAAIH6BASg9fmpTYAAAQIECBAgQIAAAQIECBAgQIBAAwsIQBv44egaAQIECBAgQIAAAQIECBAgQIAAAQL1CQhA6/NTmwABAgQIECBAgAABAgQIECBAgACBBhYQgDbww9E1AgQIECBAgAABAgQIECBAgAABAgTqExCA1uenNgECBAgQIECAAAECBAgQIECAAAECDSwgAG3gh6NrBAgQIECAAAECBAgQIECAAAECBAjUJyAArc9PbQIECBAgQIAAAQIECBAgQIAAAQIEGlhAANrAD0fXCBAgQIAAAQIECBAgQIAAAQIECBCoT0AAWp+f2gQIECBAgAABAgQIECBAgAABAgQINLCAALSBH46uESBAgAABAgQIECBAgAABAgQIECBQn4AAtD4/tQkQIECAAAECBAgQIECAAAECBAgQaGABAWgDPxxdI0CAAAECBAgQIECAAAECBAgQIECgPgEBaH1+ahMgQIAAAQIECBAgQIAAAQIECBAg0MACAtAGfji6RoAAAQIECBAgQIAAAQIECBAgQIBAfQIC0Pr81CZAgAABAgQIECBAgAABAgQIECBAoIEFBKAN/HB0jQABAgQIECBAgAABAgQIECBAgACB+gQEoPX5qU2AAAECBAgQIECAAAECBAgQIECAQAMLCEAb+OHoGgECBAgQIECAAAECBAgQIECAAAEC9QkIQOvzU5sAAQIECBAgQIAAAQIECBAgQIAAgQYWEIA28MPRNQIECBAgQIAAAQIECBAgQIAAAQIE6hMQgNbnpzYBAgQIECBAgAABAgQIECBAgAABAg0sIABt4IejawQIECBAgAABAgQIECBAgAABAgQI1CcgAK3PT20CBAgQIECAAAECBAgQIECAAAECBBpYQADawA9H1wgQIECAAAECBAgQIECAAAECBAgQqE9AAFqfn9oECBAgQIAAAQIECBAgQIAAAQIECDSwgAC0gR+OrhEgQIAAAQIECBAgQIAAAQIECBAgUJ+AALQ+P7UJECBAgAABAgQIECBAgAABAgQIEGhgAQFoAz8cXSNAgAABAgQIECBAgAABAgQIECBAoD6BWeqrrjYBAgQIEOjcAu+//36MGDEixo0bV/eNvv7669k13nrrrfjb3/5W9/V69eoVAwYMiD59+tR9LRcgQIAAAQIECBAgQIBAZxXo9lVT6aw3574IECBAgEBbBD7//PO4//7747HHHovhw4dngWfpc+LEiW25RKHnzDbbbDFw4MAsDC19rr766rHZZpvFrLPOWmjfNE6AAAECBAgQqBSYMGFCpP+J27Nnzxg/fnzlIdsECBDITUAAmhutCxMgQIBAIwuk///36KOPxtChQ+PGG2+MsWPH1uzu7HPMGfMv0D/m7tO35vEid45/f1y8PWpEfPThBzW7kf5ysdNOO8Wuu+4a66+/fsw0kzff1ISykwABAgQIEJhhAgLQGUatIQIEKgQEoBUYNgkQIECg8ws899xzcfXVV8e1114bw4YNK9/wYkssHRttvlUMGLhQLNBvQMzXr3/2Ocecc5XPadSNiRM/itFNQejoUSOzz5HD34oH7787XnzumXKX+/fvHzvvvHPsscceMWjQoPJ+GwQIECBAgACBGSkgAJ2R2toiQKAkIAAtSfgkQIAAgU4tkP5j+6ijjorf//735ftcoP+AGLzNTrHldt+LpZdbsby/s2y89sqLcdctN8Rdt14fI956s3xbu+22W5x//vnRt2/jjWotd9IGAQIECBAg0CkFBKCd8rG6KQINLyAAbfhHpIMECBAgUK/AHXfcEQcddFC8/fbb0b3pnZjb77xnU+i5c6yyxlrRrVu3ei/fIeo//eQTWRB689Ar4uOPJ2Xh54UXXhi77LJLh+i/ThIgQIAAAQKdQ0AA2jmeo7sg0NEEBKAd7YnpLwECBAi0WSC91/Owww6L6667Lquz8qprxOnnXByLLrFUm6/R2U5MI0FPPOqQ+MfDf81ubeutt46LL744+vXr19lu1f0QIECAAAECDSggAG3Ah6JLBLqAgNUQusBDdosECBDoigK33HJLLLPMMln4OdtsPeKnPzs7rrntz106/Ew/BwMWXDj+cMMf42dn/0+k95um0bHJKb0XVSFAgAABAgQIECBAgEBnFDACtDM+VfdEgACBLi5w++23x/bbbx9ffvllrLXehlnY179pcSOlucA7o9+OU4YcFg/+6e7swJVXXhl77rln85N8I0CAAAECBAhMRwEjQKcjpksRINBmASNA20zlRAIECBDoCAIPP/xwttp5Cj8PPuK4uOy6O0P4WfvJzTv/AvGby2+MY04+Izthn332iXvvvbf2yfYSIECAAAECBAgQIECggwoI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izF9b499s2A0Vf7qq6/i/P9rb9+DDo855/raoXThtAr9G6+9EgstslhULq5UOj6tn++P+9q35D2t9Z1PgAABAgQIECBAgACBogUEoEU/Ae0TIECAQLsEll566Xj44Yfj9VdfblfomEZZ3n/37VnbJ5x+TvQbMHCa+5HezXn0ofvG559/HostsXQcedzXQeg0X6iiwoqDVo30q6WSFll6+YX/xtx95ok9mwLTUhk+7I044sA9s6nzpX3LrrBynHH+pe2a1l+6xhtNvqkstdRSpV0+CRAgQIAAAQIECBAg0KEETIHvUI9LZwkQIECgJFAK5F5/9aXSrjZ/prDwtBOOys7fZIttY5sdd2tz3coTz/75TyMFhLPMMkv88n8ui7Sae54lrQj/P786LWvigB/9JHr0mD3bHvHWm/G9LdbPws80InTNdTeIvvPMF88/+1TstPm6zULRae1fCphTSYGzQoAAAQIECBAgQIAAgY4oYARoR3xq+kyAAAEC5UDuzabp3tNSUoh4zI/2i0kTP8qmiP/k+J9HmjZeXT766MPyrs8mTy6fM3NT2Dn77HPEQw/cF0MvvzQ7Z5+mqegDFly4fE65YtNGqlsq6Zqltno0XSMFp9NSbrvh6njz9VezqfG77nVAueolF5wd48e91zSKdcG49o4HsuMTm+5v/122iqf+/XicdcqQuPKW+8rnT8tGKWAuBc7TUte5BAgQIECAAAECBAgQaASBbk3vEvuqETqiDwQIECBAYFoEXn311VhiiSVigf4D4oEn2j4KNC0qtO5Ki05LU83OXW3NdePKm++NU449LK6/6rJmx6blyxVN11i96VptLZObgtTN114xRo0cHiefeX7sstf+WdWPJ02K1ZdeIJuGf0zTQkn7HPj/F0V6+MH744Ddt83Ou+PBJ2KJpZZta3Pl87bZaI1syv0TTzwRq67a8tT8cgUbBAgQIECAAIFWBCZMmBC9evWK9H7x8eOn/J/QrVR1iAABAu0WMAW+3XQqEiBAgECRAossskh079493h45Ij768IMiuzJD2r7h6v/Nws/+AxeKHXb9frnN4cNez8LPtGP5lb5V3p82lltxUPn7W2+8Xt5u60YKXd98/esRtkaAtlXNeQQIECBAgAABAgQINJrAtM29a7Te6w8BAgQIdFmBmWeeOdZZZ5148MEH47orfx/7H3Jkmyxma3pv5kGHHzvVc9Pq56URnmmBo40Hb5PVGbDgQtnnehtuGr3n7jvV66SFll575cXsvJ333K9cp3/TdPW2ljTK85Lzf5mdfshPfpoFv6W6b48aUdpsWhipeX96zd0nW9k+TfZI7wmd1pIWipr86acxaNCgmHPOOae1uvMJECBAgAABAgQIECDQEAIC0IZ4DDpBgAABAu0RGDJkSBaA/uG3F8Tu+xwUs/XoMdXLpPd3Hn7sSVM9Ly1uVApAl1p2+SnqbLjpFpF+Ta289eZr5QD0+wccGossvuTUqkxxfOjll0Saur/wYkvE1jvs2ux4r959yt8//+yz8nba+PSTT6L0pps5pjHATCvbX3rhr7LrHXfccc2u6wsBAgQIECBAgAABAgQ6koAp8B3paekrAQIECDQT2GSTTWKNNdaIce+NjTRFvDOWNL3/9xedm93aj446IdLI18rSf+D/H0n6zpi3Kw/F2HdGl78PXHja3nt6583XxqgRb8UyyywTO+ywQ/k6NggQIECAAAECBAgQINDRBASgHe2J6S8BAgQINBM44YQTsu+XXfzrbLp2s4Od4Mvll14Y498fF0stu0JsvvWUQWTfeebLVn9Pt3rfXbc1u+M//fHr77PN1iOWXHq5Zsda+/LFF19EWlk+leOPPz5mmsl/LrTm5RgBAgQIECBAgAABAo0t4G80jf189I4AAQIEpiKw5ZZbZu+oHDtmdNx07RVTObtjHU7B5+WXXJh1+rCjT8ze51nrDg475sRsd3pn5+/+55xI0/fT9m/OPSPbv/+hR0av3nPXqlpz3z233xTD3ngtFl988dhll11qnmMnAQIECBAgQIAAAQIEOoqAALSjPCn9JECAAIEWBUqjQM/9xUnxwn+fbvG8jnYgTX2f+NGHscLKq7T6vtGttt8lttt5z/jyyy8jGQxeb1D89IiDYtKkifHdzbeKfQ/6cZtvPYWnp590dHZ+evdn9ZT7Nl/IiQQIECBAgAABAgQIEGgQgW5NiyN81SB90Q0CBAgQINBugd122y2uvfbaSFPCh97xlxi40CLtvlYjVEzB5147bBYffzwpTjz93Fhz3Q2m2q377ro1Hrjvj/H6qy9lCyatu8HGUyya1NpF3hn9duy61QYxauTwSCNrb7vtNgFoa2COESBAgAABAtMsMGHChOjVq1f07Nkzxo8fP831VSBAgEB7BASg7VFThwABAgQaTuCzphXQt9hii7j//vtjwaYFf1II2qfvvA3Xz0bt0IcfTIjdt904XnnxuVhzzTXjz3/+c/To0aNRu6tfBAgQIECAQAcVEIB20Aen2wQ6uIAp8B38Aeo+AQIECHwt0L1797jllltilVVWibfefD0O3GP7mDjxIzxtEPj0k0/i4O/vlIWfadX3u+66S/jZBjenECBAgAABAgQIECDQMQQEoB3jOeklAQIECLRBYI455oi77747W7znuWf+k4V6744d04aaXfeUtNDS4QfsHv/65yPRv3//uO+++2Luudu+YFLXlXPnBAgQIECAAAECBAh0FAEBaEd5UvpJgAABAm0SmHfeebMQb7755ovHH30otlx/lbjtxmvaVLernfSnP96W+fztL/dm7+JK4efAgQO7GoP7JUCAAAECBAgQIECgkwsIQDv5A3Z7BAgQ6IoCiy66aDzxxBOx2WabxYTx78dxh/8gDtht2xg1YnhX5Jjinse+MzoO22/XbOTne+++E+uvv37mtdxyy01xrh0ECBAgQIAAAQIECBDo6AIC0I7+BPWfAAECBGoKpJGM99xzT1xxxRXRu3fvePiv98fWG6waQy+/NL766quadbrCzltvuDob9Xn/PXdEemXAxRdfHA8++GD22oCucP/ukQABAgQIECBAgACBridgFfiu98zdMQECBLqcwJgxY+LQQw+Nm266Kbv3fgMWjC23+15s0fRryaU7/6jHN159Of54241x163Xx7A3XssMBg8eHL/97W9Nee9y/za4YQIECBAgUKyAVeCL9dc6ga4qIADtqk/efRMgQKALCqRV4o888sgYNmxY+e6XaApAS2Fo/6ZgtLOUMW+PirvvuCn+eOsNkRaEKpV+/frFWWedFXvssUdpl08CBAgQIECAwAwTEIDOMGoNESBQISAArcCwSYAAAQKdXyBNf//73/8eQ4cOjRtvvDHGjRtXvumll1sxBi64cMzff0DMv0D/mL/fgFig6dd8Tdu95+4T3bp1K5/bCBtpBfe3R42IMW+P/Ppz1NefI4cPi+effao81X+uueaKHXfcMXbbbbfYYIMNYqaZvAGnEZ6fPhAgQIAAga4oIADtik/dPRMoXkAAWvwz0AMCBAgQKEjgs88+y1aMT2Ho7bffHpMmTSqoJ9O/2W984xux1VZbZaFnmu6evisECBAgQIAAgaIFBKBFPwHtE+iaAgLQrvnc3TUBAgQIVAlMnDgxnnnmmRg+fHiMGDFiis/KkaJVVQv72qtXrxgwYED2Hs+06FNpO32uuOKKMeeccxbWNw0TIECAAAECBGoJCEBrqdhHgEDeAgLQvIVdnwABAgQIECBAgAABAgQIEMgEBKB+EAgQKELAS8CKUNcmAQIECBAgQIAAAQIECBAgQIAAAQIzREAAOkOYNUKAAAECBAgQIECAAAECBAgQIECAQBECAtAi1LVJgAABAgQIECBAgAABAgQIECBAgMAMERCAzhBmjRAgQIAAAQIECBAgQIAAAQIECBAgUISAALQIdW0SIECAAAECBAgQIECAAAECBAgQIDBDBASgM4RZIwQIECBAgAABAgQIECBAgAABAgQIFCEgAC1CXZsECBAgQIAAAQIECBAgQIAAAQIECMwQAQHoDGHWCAECBAgQIECAAAECBAgQIECAAAECRQgIQItQ1yYBAgQIECBAgAABAgQIECBAgAABAjNEQAA6Q5g1QoAAAQIECBAgQIAAAQIECBAgQIBAEQIC0CLUtUmAAAECBAgQIECAAAECBAgQIECAwAwREIDOEGaNECBAgAABAgQIECBAgAABAgQIECBQhIAAtAh1bRIgQIAAAQIECBAgQIAAAQIECBAgMEMEBKAzhFkjBAgQIECAAAECBAgQIECAAAECBAgUISAALUJdmwQIECBAgAABAgQIECBAgAABAgQIzBCBWWZIKxohQIAAgYYVGDduXDz33HPRu3fvWHLJJWPWWWdt2L7qGAECBAgQIECAAAECBAgQmFYBI0CnVcz5BAgQ6OACkyZNitNOOy222GKLGDhwYPTp0yfWW2+9WGGFFWL22WePpZdeOvbaa6948803a97pX//615h//vmb/brkkktqnpt2Dhs2rNm5pbrHHHNMi3Xee++9WGCBBZrVO/nkk1s8vz0Hnn766WbXT/1KQXBlufnmm6c459NPP608xXYLAhtttFF069at/Gv06NEtnNl895gxY+K4446LjTfeOBZZZJHo0aNHLLvssrHddtvFWWedFR9//HHzCi18S8/3qKOOig022CAL95dYYonYdddd4/zzz4/Jkye3UMtuAgQIECBAgAABAgQ6o4ARoJ3xqbonAgQItCDw+OOPx5577hkvv/xyzTM+//zzeOmll7JfKfw76aST4sgjj4zu3buXz1955ZVj7Nix8eWXX5b3pVD0wAMPLH+v3Pjzn/8cKdSqLnfddVf88pe/rN6dff/HP/4R1YFZCminZ0n3Wt2vtK+yfPLJJ1OcU3ncdm2Be++9Nx544IHaB1vZe+KJJ8a5554bKaSvLC+88EKkX7fddltcfPHFccEFF8TWW29deUqz7SuuuCIOOuigSM+vVMaPHx+vvvpqXHfdddmv9PPdr1+/0mGfBAgQIECAAAECBAh0YgEjQDvxw3VrBAgQKAmksPKUU06Jtddeu8Xws3Ru6TOFUEOGDIkNN9wwPvvss9Lu6NWrVzZatLyjaSMFli2V+++/v+ahFGhVB5ClE2tdL41SVRpfID3Xvffee5o7evbZZ2cjk6vDz+oLpRHFaTToww8/XH0o+56uk9qvDD+rT0w/X6usskqMHDmy+pDvBAgQIECAAAECBAh0QgEBaCd8qG6JAAEC1QK///3v49RTT43qEY5pinKaGrzlllvGoEGD4hvf+EZ11SxoOvroo5vtX3fddZt9T9Pla4WZX331VasjAf/2t781u07pS3UAmqblzzvvvKXDPqejQHpG99xzT2y++ebxzDPP1HXlp556KptyXutnobULP/LII9m098pzZppppvj2t78d3/3ud2OWWZpPWEmB/h577BEffPBBZZV44403slHLlTvTddLP64ABAyp3ZyOM0xR5hQABAgQIECBAgACBzi8gAO38z9gdEiDQxQXS1N/jjz9+CoU0FT69azNNh7/zzjvjySefzKYIp/ckVpc05fiVV14p764OQNOB6tAy7UvvYUzT5VsqDz744BSHUriVpupXFqM/KzWmz/ZHH30UF110USyzzDIxePDgSNPWK19rMC2tfPHFF3HGGWfEGmusUTMIn9q1rrrqqkjXKJUUxKfXKjz22GORRhCnkZr77LNP6XD2mUaCptcrVJb0c1o58nOuueaKZ599Nh566KHsXbRHHHFE5enZVPiW3nXb7ERfCBAgQIAAAQIECBDo0AIC0A79+HSeAAECUxdIU9/ffffdZiemd29eeeWV2eIwlQfSKLlrrrkmWyymcn8aJfi73/2uvGudddYpb5c2agWg1QFVGnFaWVLIVV2ef/75KUb2CUCrldr/PY2S/MlPfpKNiDz00EOz9722/2oRv/3tb2OppZaKn/70p+1eXKj6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XVnQmEZQtlbSAkYvvPBCtiJ7mtI+ZMiQ7B2StepUT4N//vnnm522wgorNFvxvHSwelr8fffdVzqUfa6zzjpRa9p6CvXStPdSSeekMDQFW+l9l2kK+ZZbbhnVi91MrxGgKTBLozNPP/30UheyzzSV/eGHH262r/rLaqutlk3rfvfdd+Ohhx6KE088MQv10tTu6vLBBx/E5ZdfXr27zd/T/W6zzTbxwAMPZKNj99tvv5oLA6XQ86677soWjXr22WfbfP08TjzyyCOjOvxMo3xTaL/GGmu02mStsL+08FplxcpwPu1fZpllKg/bJkCAAAECBAgQIECgEwoIQDvhQ3VLBAgQKAmkEZEpDKwsKeS66qqrKnc1205ThNOCOdWlpfdYVgeg1fWqg87S8Zb2l463NP29enr9DjvskAW01VPxq6fT1wpTS21Ny+ftt9+ehXHpHZXpFQCV5fDDD2/x3ZqlgDaFp2m0anJLU9DTAlBp4agU7FZP455egWTqZ1pJffjw4XHaaadN95XmKw3au3399dfH+eef36x63759swA3hehTKyuttNIUCyM98cQTU1RLr0qoLCmUVggQIECAAAECBAgQ6NwCAtDO/XzdHQECBOK8886bYjRkWg38hBNOmOKdmcOGDYttt902nnrqqWZyCyywQGy33XbN9pW+pACperRl6Vj6rJ7+XjqWps5/85vfLH2d4rOlADS9m7SyVAed6VgK+tKoxspS632Qlcfbur3WWmtlp6YRluecc06zaukdnmmF8sqSpvanIC/9Sve8xRZbRDqvsiS/NFqzOuirnGZfeX57t1Mfjj/++HjzzTfjmmuuidVXX729l5qu9dJq67VC93PPPTebnp5GzNb69eGHH5b7kV6rkEYNV5a0iFLlc//Tn/6U3XvlOTvuuGPlV9sECBAgQIAAAQIECHRCAQFoJ3yobokAAQKVAostttgU76dMU+DTFO4UGqV3RB5wwAHZZ5oOXD0VPV0rTTHv3r175WXL2ym8aylIS3XWX3/98rmVGyn8bGn0aJpmXmv6fqq/+OKLV14mGyF40003ZSMv0zsk03TpnXbaKRtVWXnixIkTK79Ol+00ijUtKFRZUsCYpq+XyiabbJJNzy99T31MiyKlkayllcrTvjSt/7HHHiudln2WwtZmO6fDl/Rc0uJR6fUGqc30vtE0KrWokn4WP/rooymaT++hTe/nbOnXnnvu2axOer9qZXnuueci+acRz+l9p+ndsZUl/bvRUtBeeZ5tAgQIECBAgAABAgQ6toAAtGM/P70nQIBAmwSOO+64SCuEV5cU1KXV19P06PSZFvOpLmn18u9///vVu5t9bynITAsozT777M3OrfzS0jT4NFKypUWLNt1008pLZNsp8FxooYViwQUXzN6pmYK96pIW/cmjnH322c36OmbMmGyaeamttNhTdVCX3rG68cYbZwF0WugpBdEpkKwsaWRtCibzLukZpfeXvvHGG9mCSHm3V339tODT1VdfXb27Xd+Tc7qfypJ+rlOQml43kEaRVpY05X56vRu28rq2CRAgQIAAAQIECBBoLAEBaGM9D70hQIBALgJpkZ00wjBNe04rmLelzDrrrJGC07R6+dRKSwFoSwFn6XotHW9tVF5692atEHTEiBExcuTI7NJpBGkatVpZRo8enS0GVLlvemwvu+yy2QjaymulYK1yAZ40Lb5WAD1p0qRIi0ZNmDChsnoW5t58882tvlqgWYXp8GXAgAFt/tmYDs2VL5FGwlZOUy8faMdGes9resfq5ptv3mrtNAL2oosuyl5H0OqJDhIgQIAAAQIECBAg0CkEBKCd4jG6CQIECLRNII0yfOaZZ7IRnWm6e61RliksPeigg7IA7xe/+EWbLpymate6VksBZ+miaZp7nz59Sl/Ln60FoCnkuvXWW7MV1KvfPZqCrc022yy7x7RyffXU/BQA51HSKNnKRZgmT54caUXzUkk2Q4cOzd5L2tI7UdO56Z2f6Z2tL730UgwcOLBUvVN/Vk/7r/dme/bsmTmnVxGkFeQrS/rZSYF1GhV68MEHVx6yTYAAAQIECBAgQIBAJxbo1vQeuK868f25NQIEGkggjTxMI93Gjx8fKaRQihdIU97TSuNpEZp+/frFoosuGv379+8w04LTeyNffvnleP3117Pp22kRoepQtHjlKXuQ/h1IU/LTYk1pFGiavr/wwgvHvPPOO+XJ9tQlkJzTwlkpaE+Be2VQXdeFVW63QAqiU/GfoO0mVJEAAQIdWiD9fSD9vSD9fSD9N5FCgACBGSEgAJ0RytogQCATEID6QSBAgAABAaifAQIECHRtAQFo137+7p5AUQKmwBclr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYlr10CBAgQIECAAAECBAgQIECAAAECBHIXEIDmTqwBAgQIECBAgAABAgQIECBAgAABAgSKEhCAFiWvXQIECBAgQIAAAQIECBAgQIAAAQIEchcQgOZOrAECBAgQIECAAAECBAgQIECAAAECBIoSEIAWJa9dAgQIECBAgAABAgQIECBAgAABAgRyFxCA5k6sAQIECBAgQIAAAQIECBAgQIAAAQIEihIQgBYl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8XG4e8oKUYACFIgPAXkIXrdunf58kM8JGStOkowdnadgMTVpUnZkzJwNGbNkh4+8Plt2S+8eH6d/bhl3QkMQFHAJQVcv45r6M5YDr1zC2ROHVUOef3UZ6dKlQ6NGjfT7fu3atdnd/bmyzEABCjirwLVr13QQdPbs2di6davJ4OKaHh7Z88HVK4v6y6T+MsNN/bl6ZkZaz4xIniKVmTcxLDx59AB3bwbi7o2rlj+9HKCWAxF88RQeP7inL1M+z+RzQZ4L5HOCgc/EcPd4DRT47wQYAP3vrHkmCiQ6gcDAQMybNw9z5szBtm3bEt31xeWCSpQoob/cNG/eHLlz545LUTyWAhSggNMJ3L9/H8uXL9fB0JUrV0J+dErMycXFBfXq1dPv+2+//TbSpEmTmC+X10YBClAg0QlcuHBBPxNIMPTQoUOJ7vrickGVK1eGPBM0bdoUmTJliktRPJYCFEjCAgyAJuGbx0unQHwKXLlyBadPn4a/akF5UbWqtH69dOlSonv4Tam65WTLlk21Vs2hx+6xfs2bNy+DnvH5n4NlUYACTi0QEhKCEydO2HwuWH9GGC1FXzSStOyUsdqs3+9lXf4KFSoEd/f/piXqi64ny6cABSiQ0AISDD179myEZwJ5Rrh8+bIaU9/SjTyhr9M4v/wIlj179kg/I/Lnz4+sWbMaWflKAQo4sQADoE5881l1ClCAAhSgAAUoQAEKUIACFKAABShAAQo4ukByR68g60cBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM5771lzClCAAhSgAAUoQAEKUIACFKAABShAAQo4vAADoA5/i1lBClCAAhSgAAUoQAEKUIACFKAABShAAQo4rwADoM577//fjh0TAAAAIAjr39oeuAjMT+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CjhAf7dXToAAAQIECBAgQIAAAQIECBAgQCAv4ADNTyyQAAECBAgQIECAAAECBAgQIECAwK+AA/R3e+UECBAgQIAAAQIECBAgQIAAAQIE8gIO0PzEAgkQIECAAAECBAgQIECAAAECBAj8CgzVS3Cp9PWxdAAAAABJRU5ErkJggg==" width="33%" /></p>
<div class="page-break-after"></div>
</div>
<div id="classification-trees" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Classification Trees</h1>
<p>A <em>classification tree</em> is very similar to a regression tree, except that it is used to predict a categorical response.</p>
<p><br /><br /><br /></p>
<p>For a classification tree, we predict that each observation belongs to the <em>most commonly occurring class</em> of training observation in the region to which it belongs.</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>The task of growing a classification tree is quite similar to the task of growing a regression tree.</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>It turns out that classification error is not sensitive enough.</p>
<p><br /><br /><br /><br /><br /><br /><br /></p>
<p>When building a classification tree, either the Gini index or the entropy are typically used to evaluate the quality of a particular split.</p>
<div class="page-break-after"></div>
</div>
<div id="trees-vs.-linear-models" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Trees vs. Linear Models</h1>
<p>Regression and classification trees have a very different feel from the more classical approaches for regression and classification.</p>
<p><br /><br /><br /><br /><br /><br /><br /></p>
<p>Which method is better?</p>
<p><br /><br /><br /><br /></p>
<div id="advantages-and-disadvantages-of-trees" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Advantages and Disadvantages of Trees</h2>
<div class="page-break-after"></div>
</div>
</div>
<div id="bagging" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Bagging</h1>
<p>Decision trees suffer from <em>high variance</em>.</p>
<p><br /><br /><br /><br /></p>
<p><em>Bootstrap aggregation</em> or <em>bagging</em> is a general-purpose procedure for reducing the variance of a statistical learning method, particularly useful for trees.</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>So a natural way to reduce the variance is to take many training sets from the population, build a separate prediction model using each training set, and average the resulting predictions.</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>Of course, this is not practical because we generally do not have access to multiple training sets.</p>
<div class="page-break-after"></div>
<p>While bagging can improve predictions for many regression methods, it’s particularly useful for decision trees.</p>
<p><br /><br /><br /><br /></p>
<p>These trees are grown deep and not pruned.</p>
<p><br /><br /><br /><br /></p>
<p>How can bagging be extended to a classification problem?</p>
<p><br /><br /><br /><br /></p>
<div id="out-of-bag-error" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Out-of-Bag Error</h2>
<p>There is a very straightforward way to estimate the test error of a bagged model, without the need to perform cross-validation.</p>
<div class="page-break-after"></div>
</div>
<div id="interpretation" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Interpretation</h2>
<div class="page-break-after"></div>
</div>
</div>
<div id="random-forests" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Random Forests</h1>
<p><em>Random forests</em> provide an improvement over bagged trees by a small tweak that decorrelates the trees.</p>
<p><br /></p>
<p>As with bagged trees, we build a number of decision trees on bootstrapped training samples.</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>In other words, in building a random forest, at each split in the tree, the algorithm is not allowed to consider a majority of the predictors.</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>The main difference between bagging and random forests is the choice of predictor subset size <span class="math inline">\(m\)</span>.</p>
<div class="page-break-after"></div>
</div>
<div id="boosting" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Boosting</h1>
<p><em>Boosting</em> is another approach for improving the prediction results from a decision tree.</p>
<p><br /><br /><br /></p>
<p>While bagging involves creating multiple copies of the original training data set using the bootstrap and fitting a separate decision tree on each copy,</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>Boosting does not involve bootstrap sampling, instead each tree is fit on a modified version of the original data set.</p>
<div class="page-break-after"></div>
<p>Boosting has three tuning parameters:</p>
<p><br /></p>
<ol style="list-style-type: decimal">
<li><p><br /><br /><br /><br /><br /><br /><br /><br /><br /></p></li>
<li><p><br /><br /><br /><br /><br /><br /><br /><br /><br /></p></li>
<li><p><br /><br /><br /><br /><br /><br /><br /><br /><br /></p></li>
</ol>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
