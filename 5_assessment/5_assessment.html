<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Chapter 5: Assessing Model Accuracy" />






<meta name="description" content="Chapter 5: Assessing Model Accuracy">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","output":{"pagedown::html_paged":{"self_contained":true,"css":["../style/my-style-page.css","default-fonts","default-page","default"],"number_sections":true}},"title":"Chapter 5: Assessing Model Accuracy"}
</script>

<title>Chapter 5: Assessing Model Accuracy</title>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  let beforePaged = PagedConfig.before;
  window.PagedConfig.before = async () => {
    if (beforePaged) await beforePaged();
    return new Promise((resolve, reject) => {
      var script = document.createElement("script");
      script.type = "text/javascript";
      var src = `https://mathjax.rstudio.com/latest/MathJax.js` + "?config=TeX-MML-AM_CHTML";
      if (location.protocol !== "file:" && /^https?:/.test(src))
        src = src.replace(/^https?:/, '');
      script.src = src;
      window.MathJax = {
        AuthorInit: () => {
          MathJax.Hub.Register.StartupHook("Begin", () => {
            MathJax.Hub.Queue(resolve);
          });
        }
      };
      document.getElementsByTagName("head")[0].appendChild(script);
    });
  };
})();
</script>

<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: local('Old Standard TT Regular'), local('OldStandardTT-Regular'), url(data:font/ttf;base64,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AYoAPgIcACwC9AA+Ap4APgKeAD4DRgA+AwIAPgMCAD4CvABGArwARgK8AEYCvABGArwARgK8AEYCvABGBBgARgKoAD4CqAA+ArwARgLMAD4CbABYAsoASAMMADQDDAA0AwwANAMMADQDDAA0AwQALAQsACYC7gAuAtgAKgLYACoCjABEAe4ALgHuAC4B7gAuAe4ALgHuAC4B7gAuAe4ALgK8AC4CAAAWAbQAMAG0ADACCgAwAfQAMAHMADABzAAwAcwAMAHMADABzAAwAUoAHAIcADQCIAAcAQ4AJgEOACYBDgAmARoABwEaAAsBDv/0AUD/2gIIABwBDgAcAXQAHAMaACYCHAAmAhwAJgHwADAB8AAwAfAAMAHwADAB8AAwAfAAMAHwADAC/gAwAgYAHAH0ABoB9gAwAZoAJgGyADQCDgAcAV4AHAIWACACFgAgAhYAIAIWACACFgAgAhIAEgMIABICCAAiAhIAEgISABICEgASAbgAKAISABwCEgAcAXwAPgF8AEYCRAAwAkQAeAJEAEoCRABIAkQAOAJEAFYCRABQAkQAWgJEADwCRABOAXwAHgF8AFQBfAA0AXwARAF8ACwBfAA2AXwANgF8ADwBfAAoAXwAMgF8AB4BfABUAXwANAF8AEQBfAAsAXwANgF8ADYBfAA8AXwAKAF8ADIBfAAeAXwAVAF8ADQBfABEAXwALAF8ADYBfAA2AXwAPAF8ACgBfAAyAFL/gAM0AFQDNABUAzQARAH2AEgBwgA4ARgATgH0AIgBGABOARgASANIAE4BGABOARgATgKsAFEBGABOAdYAQAHWACIBigBWAPAAVgEYAEgBwgA4AggAAAGkAGgBpABUAXwAeAF8AEYBcgBiAXIAMAPoADwCbAA8AXIAPAFyADwB4ABsAeAAcgFKAGwBSgBbAdIASAHSAEYB0gBIARgARgEYAEgBGABIARgAAACkAAAAAAAAAkQAcAJEADQCRAA+AkQAIgLQAEACRAAOAjAAMAOsADADrAAwA6wAnAOsADADrAAwA6wAUAOsAFQDrAAwApQAMAJEADACXgA+A1wAYAF4ADABeAAwAzQAMAMSADYCHABAAoAAZAM0ADADNAAwA9QAHgJEAJoBHAB4ARwAeAJEAD4BBAAsAawALADIACgAyAAoAXEAZAGCAGQBzgBkAeQAZAFxAGQBzABk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) format('truetype');
}
body {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;
}
blockquote {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '', 'SimKai', 'DFKai-SB', 'NSimSun', serif;
}
code {
font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;
}
pre, code {
font-size: .95em;
}
</style>
<style type="text/css">
@page {
size: 6in 9in; 
}
@page :blank {
}

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: counter(page);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: counter(page);
}
@top-left {
content: element(runningH2Title);
white-space: nowrap !important;
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
background-image: var(--front-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.front-cover {
break-after: recto;
}

.front-page {
counter-reset: page;
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:right {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.back-cover {
break-before: verso;
}
.pagedjs_page:last-of-type {
background-image: var(--back-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.level1 {
break-before: recto;
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

.main .level1:first-child h1 {
counter-reset: page;
}

caption {
break-inside: avoid;
break-after: avoid;
}
</style>
<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: hidden;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = window.location.hash.replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	global.PagedPolyfill = factory();
}(typeof self !== 'undefined' ? self : this, function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n.default || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function"){
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if(element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, []
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		let after = node;

		if (after.nextSibling) {
			if (limiter && node === limiter) {
				return;
			}
			after = after.nextSibling;
		} else {
			while (after) {
				after = after.parentNode;
				if (limiter && after === limiter) {
					after = undefined;
					break;
				}
				if (after && after.nextSibling) {
					after = after.nextSibling;
					break;
				}
			}
		}

		return after;
	}

	function nodeBefore(node, limiter) {
		let before = node;
		if (before.previousSibling) {
			if (limiter && node === limiter) {
				return;
			}
			before = before.previousSibling;
		} else {
			while (before) {
				before = before.parentNode;
				if (limiter && before === limiter) {
					before = undefined;
					break;
				}
				if (before && before.previousSibling) {
					before = before.previousSibling;
					break;
				}
			}
		}

		return before;
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after);
		}

		return after;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				(node.dataset.page || node.dataset.afterPage)
			 ) {
			return true;
		}

		return false;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

	  /**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
	  triggerSync(){
	    var args = arguments;
	    var context = this.context;
	    var results = [];

	    this.hooks.forEach(function(task) {
	      var executing = task.apply(context, args);

	      results.push(executing);
	    });


	    return results;
	  }

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, maxChars) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.maxChars = maxChars || MAX_CHARS_PER_BREAK;
		}

		async renderTo(wrapper, source, breakToken, bounds=this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			while (!done && !newBreakToken) {
				next = walker.next();
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset=0) {
			return {
				node,
				offset
			};
		}

		shouldBreak(node) {
			let previousSibling = node.previousSibling;
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node);
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow=true, rebuild=true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function() {
						let { width, height } = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function(e) {
						let { width, height } = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let { width, height } = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if(window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						renderedNode = findElement(prevValidNode(temp), rendered);
						return;
					}

					node = findElement(renderedNode, source);
					offset = 0;
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					node = child(parent, index);
					offset = 0;
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return {
				node,
				offset
			};

		}

		findBreakToken(rendered, source, bounds=this.bounds, extract=true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);

				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});


				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds=this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let { width } = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds=this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end =  Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.floor(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						if (isElement(node) ) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.setStartBefore(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.setStartBefore(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.setStartBefore(node);
							break;
						}

					}

					if (!range && isText(node) &&
							node.textContent.trim().length &&
							window.getComputedStyle(node.parentNode)["break-inside"] !== "avoid") {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if(left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right < end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds=this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if(!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer);

			return extracted;
		}

		hyphenateAtBreak(startContainer) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length-1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (/^\w|\u00AD$/.test(prevLetter)) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += "\u2011";
				}
			}
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum+1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute('id', id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if(e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function() {
				if(this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element &&this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver( entries => {

				if (!this.listening) {
					return;
				}

				for (let entry of entries) {
					const cr = entry.contentRect;

					if (cr.height > prevHeight) {
						this.checkOverflowAfterResize(contents);
						prevHeight = wrapper.getBoundingClientRect().height;
					} else if (cr.height < prevHeight ) { // TODO: calc line height && (prevHeight - cr.height) >= 22
						this.checkUnderflowAfterResize(contents);
						prevHeight = cr.height;
					}
				}
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			// let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);
			this.removeEmpty(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);
			this.removeEmpty(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				{ acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		removeEmpty(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_TEXT,
				{ acceptNode: function(node) {
					// Only remove more than a single space
					if (node.textContent.length > 1 && !node.textContent.trim()) {

						// Don't touch whitespace if text is preformated
						let parent = node.parentNode;
						let pre = isElement(parent) && parent.closest("pre");
						if (pre) {
							return NodeFilter.FILTER_REJECT;
						}

						return NodeFilter.FILTER_ACCEPT;
					} else {
						return NodeFilter.FILTER_REJECT;
					}
				} },
				false
			);

			let node;
			let current;
			node = treeWalker.nextNode();
			while(node) {
				current = node;
				node = treeWalker.nextNode();
				// if (!current.nextSibling || (current.nextSibling && current.nextSibling.nodeType === 1)) {
				current.parentNode.removeChild(current);
				// }
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		// isWrapper(element) {
		//   return wrappersRegex.test(element.nodeName);
		// }

		isText(node) {
			return node.tagName === "TAG";
		}

		isElement(node) {
			return node.nodeType === 1;
		}

		hasChildren(node) {
			return node.childNodes && node.childNodes.length;
		}


		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo) {
			// this.preview = preview;

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this._total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", content);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);

			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt);

			let done = false;
			let result;

			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && (true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}
		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/

		get total() {
			return this._total;
		}

		set total(num) {
			this.pagesArea.style.setProperty("--pagedjs-page-count", num);
			this._total = num;
		}

		loadFonts() {
			let fontPromises = [];
			document.fonts.forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//            item        item        item        item
	//          /------\    /------\    /------\    /------\
	//          | data |    | data |    | data |    | data |
	//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
	//          | next-+--->| next-+--->| next-+--->| next-+--> null
	//          \------/    \------/    \------/    \------/
	//             ^                                    ^
	//             |                list                |
	//             |              /------\              |
	//             \--------------+-head |              |
	//                            | tail-+--------------/
	//                            \------/
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var list = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var CssSyntaxError = function(message, source, offset, line, column) {
	    var error = createCustomError('CssSyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var error = CssSyntaxError;

	// token types (note: value shouldn't intersect with used char codes)
	var WHITESPACE = 1;
	var IDENTIFIER = 2;
	var NUMBER = 3;
	var STRING = 4;
	var COMMENT = 5;
	var PUNCTUATOR = 6;
	var CDO = 7;
	var CDC = 8;
	var ATKEYWORD = 14;
	var FUNCTION = 15;
	var URL$1 = 16;
	var RAW = 17;

	var TAB = 9;
	var N = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var TYPE = {
	    WhiteSpace:   WHITESPACE,
	    Identifier:   IDENTIFIER,
	    Number:           NUMBER,
	    String:           STRING,
	    Comment:         COMMENT,
	    Punctuator:   PUNCTUATOR,
	    CDO:                 CDO,
	    CDC:                 CDC,
	    AtKeyword:     ATKEYWORD,
	    Function:       FUNCTION,
	    Url:                 URL$1,
	    Raw:                 RAW,

	    ExclamationMark:      33,  // !
	    QuotationMark:        34,  // "
	    NumberSign:           35,  // #
	    DollarSign:           36,  // $
	    PercentSign:          37,  // %
	    Ampersand:            38,  // &
	    Apostrophe:           39,  // '
	    LeftParenthesis:      40,  // (
	    RightParenthesis:     41,  // )
	    Asterisk:             42,  // *
	    PlusSign:             43,  // +
	    Comma:                44,  // ,
	    HyphenMinus:          45,  // -
	    FullStop:             46,  // .
	    Solidus:              47,  // /
	    Colon:                58,  // :
	    Semicolon:            59,  // ;
	    LessThanSign:         60,  // <
	    EqualsSign:           61,  // =
	    GreaterThanSign:      62,  // >
	    QuestionMark:         63,  // ?
	    CommercialAt:         64,  // @
	    LeftSquareBracket:    91,  // [
	    Backslash:            92,  // \
	    RightSquareBracket:   93,  // ]
	    CircumflexAccent:     94,  // ^
	    LowLine:              95,  // _
	    GraveAccent:          96,  // `
	    LeftCurlyBracket:    123,  // {
	    VerticalLine:        124,  // |
	    RightCurlyBracket:   125,  // }
	    Tilde:               126   // ~
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we a maps for 0..127 codes only
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported
	var SYMBOL_TYPE = new SafeUint32Array(0x80);
	var PUNCTUATION = new SafeUint32Array(0x80);
	var STOP_URL_RAW = new SafeUint32Array(0x80);

	for (var i = 0; i < SYMBOL_TYPE.length; i++) {
	    SYMBOL_TYPE[i] = IDENTIFIER;
	}

	// fill categories
	[
	    TYPE.ExclamationMark,    // !
	    TYPE.QuotationMark,      // "
	    TYPE.NumberSign,         // #
	    TYPE.DollarSign,         // $
	    TYPE.PercentSign,        // %
	    TYPE.Ampersand,          // &
	    TYPE.Apostrophe,         // '
	    TYPE.LeftParenthesis,    // (
	    TYPE.RightParenthesis,   // )
	    TYPE.Asterisk,           // *
	    TYPE.PlusSign,           // +
	    TYPE.Comma,              // ,
	    TYPE.HyphenMinus,        // -
	    TYPE.FullStop,           // .
	    TYPE.Solidus,            // /
	    TYPE.Colon,              // :
	    TYPE.Semicolon,          // ;
	    TYPE.LessThanSign,       // <
	    TYPE.EqualsSign,         // =
	    TYPE.GreaterThanSign,    // >
	    TYPE.QuestionMark,       // ?
	    TYPE.CommercialAt,       // @
	    TYPE.LeftSquareBracket,  // [
	    // TYPE.Backslash,          // \
	    TYPE.RightSquareBracket, // ]
	    TYPE.CircumflexAccent,   // ^
	    // TYPE.LowLine,            // _
	    TYPE.GraveAccent,        // `
	    TYPE.LeftCurlyBracket,   // {
	    TYPE.VerticalLine,       // |
	    TYPE.RightCurlyBracket,  // }
	    TYPE.Tilde               // ~
	].forEach(function(key) {
	    SYMBOL_TYPE[Number(key)] = PUNCTUATOR;
	    PUNCTUATION[Number(key)] = PUNCTUATOR;
	});

	for (var i = 48; i <= 57; i++) {
	    SYMBOL_TYPE[i] = NUMBER;
	}

	SYMBOL_TYPE[SPACE] = WHITESPACE;
	SYMBOL_TYPE[TAB] = WHITESPACE;
	SYMBOL_TYPE[N] = WHITESPACE;
	SYMBOL_TYPE[R] = WHITESPACE;
	SYMBOL_TYPE[F] = WHITESPACE;

	SYMBOL_TYPE[TYPE.Apostrophe] = STRING;
	SYMBOL_TYPE[TYPE.QuotationMark] = STRING;

	STOP_URL_RAW[SPACE] = 1;
	STOP_URL_RAW[TAB] = 1;
	STOP_URL_RAW[N] = 1;
	STOP_URL_RAW[R] = 1;
	STOP_URL_RAW[F] = 1;
	STOP_URL_RAW[TYPE.Apostrophe] = 1;
	STOP_URL_RAW[TYPE.QuotationMark] = 1;
	STOP_URL_RAW[TYPE.LeftParenthesis] = 1;
	STOP_URL_RAW[TYPE.RightParenthesis] = 1;

	// whitespace is punctuation ...
	PUNCTUATION[SPACE] = PUNCTUATOR;
	PUNCTUATION[TAB] = PUNCTUATOR;
	PUNCTUATION[N] = PUNCTUATOR;
	PUNCTUATION[R] = PUNCTUATOR;
	PUNCTUATION[F] = PUNCTUATOR;
	// ... hyper minus is not
	PUNCTUATION[TYPE.HyphenMinus] = 0;

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME,

	    SYMBOL_TYPE: SYMBOL_TYPE,
	    PUNCTUATION: PUNCTUATION,
	    STOP_URL_RAW: STOP_URL_RAW
	};

	var PUNCTUATION$1 = _const.PUNCTUATION;
	var STOP_URL_RAW$1 = _const.STOP_URL_RAW;
	var TYPE$1 = _const.TYPE;
	var FULLSTOP = TYPE$1.FullStop;
	var PLUSSIGN = TYPE$1.PlusSign;
	var HYPHENMINUS = TYPE$1.HyphenMinus;
	var PUNCTUATOR$1 = TYPE$1.Punctuator;
	var TAB$1 = 9;
	var N$1 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var BACK_SLASH = 92;
	var E = 101; // 'e'.charCodeAt(0)

	function firstCharOffset(source) {
	    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	    if (source.charCodeAt(0) === 0xFEFF ||  // UTF-16BE
	        source.charCodeAt(0) === 0xFFFE) {  // UTF-16LE
	        return 1;
	    }

	    return 0;
	}

	function isHex(code) {
	    return (code >= 48 && code <= 57) || // 0 .. 9
	           (code >= 65 && code <= 70) || // A .. F
	           (code >= 97 && code <= 102);  // a .. f
	}

	function isNumber(code) {
	    return code >= 48 && code <= 57;
	}

	function isWhiteSpace(code) {
	    return code === SPACE$1 || code === TAB$1 || isNewline(code);
	}

	function isNewline(code) {
	    return code === R$1 || code === N$1 || code === F$1;
	}

	function getNewlineLength(source, offset, code) {
	    if (isNewline(code)) {
	        if (code === R$1 && offset + 1 < source.length && source.charCodeAt(offset + 1) === N$1) {
	            return 2;
	        }

	        return 1;
	    }

	    return 0;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (code >= 65 && code <= 90) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var refCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (testCode >= 65 && testCode <= 90) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== refCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    while (offset >= 0 && isWhiteSpace(source.charCodeAt(offset))) {
	        offset--;
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    while (offset < source.length && isWhiteSpace(source.charCodeAt(offset))) {
	        offset++;
	    }

	    return offset;
	}

	function findCommentEnd(source, offset) {
	    var commentEnd = source.indexOf('*/', offset);

	    if (commentEnd === -1) {
	        return source.length;
	    }

	    return commentEnd + 2;
	}

	function findStringEnd(source, offset, quote) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // TODO: bad string
	        if (code === BACK_SLASH) {
	            offset++;
	        } else if (code === quote) {
	            offset++;
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    while (offset < source.length && isNumber(source.charCodeAt(offset))) {
	        offset++;
	    }

	    return offset;
	}

	function findNumberEnd(source, offset, allowFraction) {
	    var code;

	    offset = findDecimalNumberEnd(source, offset);

	    // fraction: .\d+
	    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP) {
	        code = source.charCodeAt(offset + 1);

	        if (isNumber(code)) {
	            offset = findDecimalNumberEnd(source, offset + 1);
	        }
	    }

	    // exponent: e[+-]\d+
	    if (offset + 1 < source.length) {
	        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`
	            code = source.charCodeAt(offset + 1);

	            if (code === PLUSSIGN || code === HYPHENMINUS) {
	                if (offset + 2 < source.length) {
	                    code = source.charCodeAt(offset + 2);
	                }
	            }

	            if (isNumber(code)) {
	                offset = findDecimalNumberEnd(source, offset + 2);
	            }
	        }
	    }

	    return offset;
	}

	// skip escaped unicode sequence that can ends with space
	// [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
	function findEscapeEnd(source, offset) {
	    for (var i = 0; i < 7 && offset + i < source.length; i++) {
	        var code = source.charCodeAt(offset + i);

	        if (i !== 6 && isHex(code)) {
	            continue;
	        }

	        if (i > 0) {
	            offset += i - 1 + getNewlineLength(source, offset + i, code);
	            if (code === SPACE$1 || code === TAB$1) {
	                offset++;
	            }
	        }

	        break;
	    }

	    return offset;
	}

	function findIdentifierEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        if (code === BACK_SLASH) {
	            offset = findEscapeEnd(source, offset + 1);
	        } else if (code < 0x80 && PUNCTUATION$1[code] === PUNCTUATOR$1) {
	            break;
	        }
	    }

	    return offset;
	}

	function findUrlRawEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        if (code === BACK_SLASH) {
	            offset = findEscapeEnd(source, offset + 1);
	        } else if (code < 0x80 && STOP_URL_RAW$1[code] === 1) {
	            break;
	        }
	    }

	    return offset;
	}

	var utils = {
	    firstCharOffset: firstCharOffset,

	    isHex: isHex,
	    isNumber: isNumber,
	    isWhiteSpace: isWhiteSpace,
	    isNewline: isNewline,
	    getNewlineLength: getNewlineLength,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd,
	    findCommentEnd: findCommentEnd,
	    findStringEnd: findStringEnd,
	    findDecimalNumberEnd: findDecimalNumberEnd,
	    findNumberEnd: findNumberEnd,
	    findEscapeEnd: findEscapeEnd,
	    findIdentifierEnd: findIdentifierEnd,
	    findUrlRawEnd: findUrlRawEnd
	};

	var TYPE$2 = _const.TYPE;
	var NAME$1 = _const.NAME;
	var SYMBOL_TYPE$1 = _const.SYMBOL_TYPE;


	var firstCharOffset$1 = utils.firstCharOffset;
	var cmpStr$1 = utils.cmpStr;
	var isNumber$1 = utils.isNumber;
	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var findCommentEnd$1 = utils.findCommentEnd;
	var findStringEnd$1 = utils.findStringEnd;
	var findNumberEnd$1 = utils.findNumberEnd;
	var findIdentifierEnd$1 = utils.findIdentifierEnd;
	var findUrlRawEnd$1 = utils.findUrlRawEnd;

	var NULL = 0;
	var WHITESPACE$1 = TYPE$2.WhiteSpace;
	var IDENTIFIER$1 = TYPE$2.Identifier;
	var NUMBER$1 = TYPE$2.Number;
	var STRING$1 = TYPE$2.String;
	var COMMENT$1 = TYPE$2.Comment;
	var PUNCTUATOR$2 = TYPE$2.Punctuator;
	var CDO$1 = TYPE$2.CDO;
	var CDC$1 = TYPE$2.CDC;
	var ATKEYWORD$1 = TYPE$2.AtKeyword;
	var FUNCTION$1 = TYPE$2.Function;
	var URL$2 = TYPE$2.Url;
	var RAW$1 = TYPE$2.Raw;

	var N$2 = 10;
	var F$2 = 12;
	var R$2 = 13;
	var STAR = TYPE$2.Asterisk;
	var SLASH = TYPE$2.Solidus;
	var FULLSTOP$1 = TYPE$2.FullStop;
	var PLUSSIGN$1 = TYPE$2.PlusSign;
	var HYPHENMINUS$1 = TYPE$2.HyphenMinus;
	var GREATERTHANSIGN = TYPE$2.GreaterThanSign;
	var LESSTHANSIGN = TYPE$2.LessThanSign;
	var EXCLAMATIONMARK = TYPE$2.ExclamationMark;
	var COMMERCIALAT = TYPE$2.CommercialAt;
	var QUOTATIONMARK = TYPE$2.QuotationMark;
	var APOSTROPHE = TYPE$2.Apostrophe;
	var LEFTPARENTHESIS = TYPE$2.LeftParenthesis;
	var RIGHTPARENTHESIS = TYPE$2.RightParenthesis;
	var LEFTCURLYBRACKET = TYPE$2.LeftCurlyBracket;
	var RIGHTCURLYBRACKET = TYPE$2.RightCurlyBracket;
	var LEFTSQUAREBRACKET = TYPE$2.LeftSquareBracket;
	var RIGHTSQUAREBRACKET = TYPE$2.RightSquareBracket;

	var MIN_BUFFER_SIZE = 16 * 1024;
	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;
	var SafeUint32Array$1 = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	function computeLinesAndColumns(tokenizer, source) {
	    var sourceLength = source.length;
	    var start = firstCharOffset$1(source);
	    var lines = tokenizer.lines;
	    var line = tokenizer.startLine;
	    var columns = tokenizer.columns;
	    var column = tokenizer.startColumn;

	    if (lines === null || lines.length < sourceLength + 1) {
	        lines = new SafeUint32Array$1(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));
	        columns = new SafeUint32Array$1(lines.length);
	    }

	    for (var i = start; i < sourceLength; i++) {
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$2 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$2) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    tokenizer.linesAnsColumnsComputed = true;
	    tokenizer.lines = lines;
	    tokenizer.columns = columns;
	}

	function tokenLayout(tokenizer, source, startPos) {
	    var sourceLength = source.length;
	    var offsetAndType = tokenizer.offsetAndType;
	    var balance = tokenizer.balance;
	    var tokenCount = 0;
	    var prevType = 0;
	    var offset = startPos;
	    var anchor = 0;
	    var balanceCloseCode = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {
	        offsetAndType = new SafeUint32Array$1(sourceLength + 1024);
	        balance = new SafeUint32Array$1(sourceLength + 1024);
	    }

	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = code < 0x80 ? SYMBOL_TYPE$1[code] : IDENTIFIER$1;

	        balance[tokenCount] = sourceLength;

	        switch (type) {
	            case WHITESPACE$1:
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            case PUNCTUATOR$2:
	                switch (code) {
	                    case balanceCloseCode:
	                        balancePrev = balanceStart & OFFSET_MASK;
	                        balanceStart = balance[balancePrev];
	                        balanceCloseCode = balanceStart >> TYPE_SHIFT;
	                        balance[tokenCount] = balancePrev;
	                        balance[balancePrev++] = tokenCount;
	                        for (; balancePrev < tokenCount; balancePrev++) {
	                            if (balance[balancePrev] === sourceLength) {
	                                balance[balancePrev] = tokenCount;
	                            }
	                        }
	                        break;

	                    case LEFTSQUAREBRACKET:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTSQUAREBRACKET;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;

	                    case LEFTCURLYBRACKET:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTCURLYBRACKET;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;

	                    case LEFTPARENTHESIS:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTPARENTHESIS;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;
	                }

	                // /*
	                if (code === STAR && prevType === SLASH) {
	                    type = COMMENT$1;
	                    offset = findCommentEnd$1(source, offset + 1);
	                    tokenCount--; // rewrite prev token
	                    break;
	                }

	                // edge case for -.123 and +.123
	                if (code === FULLSTOP$1 && (prevType === PLUSSIGN$1 || prevType === HYPHENMINUS$1)) {
	                    if (offset + 1 < sourceLength && isNumber$1(source.charCodeAt(offset + 1))) {
	                        type = NUMBER$1;
	                        offset = findNumberEnd$1(source, offset + 2, false);
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // <!--
	                if (code === EXCLAMATIONMARK && prevType === LESSTHANSIGN) {
	                    if (offset + 2 < sourceLength &&
	                        source.charCodeAt(offset + 1) === HYPHENMINUS$1 &&
	                        source.charCodeAt(offset + 2) === HYPHENMINUS$1) {
	                        type = CDO$1;
	                        offset = offset + 3;
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // -->
	                if (code === HYPHENMINUS$1 && prevType === HYPHENMINUS$1) {
	                    if (offset + 1 < sourceLength && source.charCodeAt(offset + 1) === GREATERTHANSIGN) {
	                        type = CDC$1;
	                        offset = offset + 2;
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // ident(
	                if (code === LEFTPARENTHESIS && prevType === IDENTIFIER$1) {
	                    offset = offset + 1;
	                    tokenCount--; // rewrite prev token
	                    balance[tokenCount] = balance[tokenCount + 1];
	                    balanceStart--;

	                    // 4 char length identifier and equal to `url(` (case insensitive)
	                    if (offset - anchor === 4 && cmpStr$1(source, anchor, offset, 'url(')) {
	                        // special case for url() because it can contain any symbols sequence with few exceptions
	                        anchor = findWhiteSpaceEnd$1(source, offset);
	                        code = source.charCodeAt(anchor);
	                        if (code !== LEFTPARENTHESIS &&
	                            code !== RIGHTPARENTHESIS &&
	                            code !== QUOTATIONMARK &&
	                            code !== APOSTROPHE) {
	                            // url(
	                            offsetAndType[tokenCount++] = (URL$2 << TYPE_SHIFT) | offset;
	                            balance[tokenCount] = sourceLength;

	                            // ws*
	                            if (anchor !== offset) {
	                                offsetAndType[tokenCount++] = (WHITESPACE$1 << TYPE_SHIFT) | anchor;
	                                balance[tokenCount] = sourceLength;
	                            }

	                            // raw
	                            type = RAW$1;
	                            offset = findUrlRawEnd$1(source, anchor);
	                        } else {
	                            type = URL$2;
	                        }
	                    } else {
	                        type = FUNCTION$1;
	                    }
	                    break;
	                }

	                type = code;
	                offset = offset + 1;
	                break;

	            case NUMBER$1:
	                offset = findNumberEnd$1(source, offset + 1, prevType !== FULLSTOP$1);

	                // merge number with a preceding dot, dash or plus
	                if (prevType === FULLSTOP$1 ||
	                    prevType === HYPHENMINUS$1 ||
	                    prevType === PLUSSIGN$1) {
	                    tokenCount--; // rewrite prev token
	                }

	                break;

	            case STRING$1:
	                offset = findStringEnd$1(source, offset + 1, code);
	                break;

	            default:
	                anchor = offset;
	                offset = findIdentifierEnd$1(source, offset);

	                // merge identifier with a preceding dash
	                if (prevType === HYPHENMINUS$1) {
	                    // rewrite prev token
	                    tokenCount--;
	                    // restore prev prev token type
	                    // for case @-prefix-ident
	                    prevType = tokenCount === 0 ? 0 : offsetAndType[tokenCount - 1] >> TYPE_SHIFT;
	                }

	                if (prevType === COMMERCIALAT) {
	                    // rewrite prev token and change type to <at-keyword-token>
	                    tokenCount--;
	                    type = ATKEYWORD$1;
	                }
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
	        prevType = type;
	    }

	    // finalize arrays
	    offsetAndType[tokenCount] = offset;
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    tokenizer.offsetAndType = offsetAndType;
	    tokenizer.tokenCount = tokenCount;
	    tokenizer.balance = balance;
	}

	//
	// tokenizer
	//

	var Tokenizer = function(source, startOffset, startLine, startColumn) {
	    this.offsetAndType = null;
	    this.balance = null;
	    this.lines = null;
	    this.columns = null;

	    this.setSource(source, startOffset, startLine, startColumn);
	};

	Tokenizer.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        var safeSource = String(source || '');
	        var start = firstCharOffset$1(safeSource);

	        this.source = safeSource;
	        this.firstCharOffset = start;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAnsColumnsComputed = false;

	        this.eof = false;
	        this.currentToken = -1;
	        this.tokenType = 0;
	        this.tokenStart = start;
	        this.tokenEnd = start;

	        tokenLayout(this, safeSource, start);
	        this.next();
	    },

	    lookupType: function(offset) {
	        offset += this.currentToken;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return NULL;
	    },
	    lookupNonWSType: function(offset) {
	        offset += this.currentToken;

	        for (var type; offset < this.tokenCount; offset++) {
	            type = this.offsetAndType[offset] >> TYPE_SHIFT;

	            if (type !== WHITESPACE$1) {
	                return type;
	            }
	        }

	        return NULL;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.currentToken;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenNum) {
	        if (tokenNum === this.currentToken) {
	            return this.tokenStart;
	        }

	        if (tokenNum > 0) {
	            return tokenNum < this.tokenCount
	                ? this.offsetAndType[tokenNum - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },
	    getOffsetExcludeWS: function() {
	        if (this.currentToken > 0) {
	            if ((this.offsetAndType[this.currentToken - 1] >> TYPE_SHIFT) === WHITESPACE$1) {
	                return this.currentToken > 1
	                    ? this.offsetAndType[this.currentToken - 2] & OFFSET_MASK
	                    : this.firstCharOffset;
	            }
	        }
	        return this.tokenStart;
	    },
	    getRawLength: function(startToken, endTokenType1, endTokenType2, includeTokenType2) {
	        var cursor = startToken;
	        var balanceEnd;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // belance end points to offset before start
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            // check token is stop type
	            switch (this.offsetAndType[cursor] >> TYPE_SHIFT) {
	                case endTokenType1:
	                    break loop;

	                case endTokenType2:
	                    if (includeTokenType2) {
	                        cursor++;
	                    }
	                    break loop;

	                default:
	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }

	        }

	        return cursor - this.currentToken;
	    },
	    isBalanceEdge: function(pos) {
	        var balanceStart = this.balance[this.currentToken];
	        return balanceStart < pos;
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE$1) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE$1 || this.tokenType === COMMENT$1) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.currentToken + tokenCount;

	        if (next < this.tokenCount) {
	            this.currentToken = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.currentToken = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.currentToken + 1;

	        if (next < this.tokenCount) {
	            this.currentToken = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.currentToken = this.tokenCount;
	            this.eof = true;
	            this.tokenType = NULL;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    eat: function(tokenType) {
	        if (this.tokenType !== tokenType) {
	            var offset = this.tokenStart;
	            var message = NAME$1[tokenType] + ' is expected';

	            // tweak message and offset
	            if (tokenType === IDENTIFIER$1) {
	                // when identifier is expected but there is a function or url
	                if (this.tokenType === FUNCTION$1 || this.tokenType === URL$2) {
	                    offset = this.tokenEnd - 1;
	                    message += ' but function found';
	                }
	            } else {
	                // when test type is part of another token show error for current position + 1
	                // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                if (this.source.charCodeAt(this.tokenStart) === tokenType) {
	                    offset = offset + 1;
	                }
	            }

	            this.error(message, offset);
	        }

	        this.next();
	    },
	    eatNonWS: function(tokenType) {
	        this.skipWS();
	        this.eat(tokenType);
	    },

	    consume: function(tokenType) {
	        var value = this.getTokenValue();

	        this.eat(tokenType);

	        return value;
	    },
	    consumeFunctionName: function() {
	        var name = this.source.substring(this.tokenStart, this.tokenEnd - 1);

	        this.eat(FUNCTION$1);

	        return name;
	    },
	    consumeNonWS: function(tokenType) {
	        this.skipWS();

	        return this.consume(tokenType);
	    },

	    expectIdentifier: function(name) {
	        if (this.tokenType !== IDENTIFIER$1 || cmpStr$1(this.source, this.tokenStart, this.tokenEnd, name) === false) {
	            this.error('Identifier `' + name + '` is expected');
	        }

	        this.next();
	    },

	    getLocation: function(offset, filename) {
	        if (!this.linesAnsColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	        }

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },

	    getLocationRange: function(start, end, filename) {
	        if (!this.linesAnsColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	        }

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    },

	    error: function(message, offset) {
	        var location = typeof offset !== 'undefined' && offset < this.source.length
	            ? this.getLocation(offset)
	            : this.eof
	                ? this.getLocation(findWhiteSpaceStart$1(this.source, this.source.length - 1))
	                : this.getLocation(this.tokenStart);

	        throw new error(
	            message || 'Unexpected input',
	            this.source,
	            location.offset,
	            location.line,
	            location.column
	        );
	    },

	    dump: function() {
	        var offset = 0;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	// extend with error class
	Tokenizer.CssSyntaxError = error;

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    Tokenizer[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(utils).forEach(function(key) {
	    Tokenizer[key] = utils[key];
	});

	// warm up tokenizer to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	new Tokenizer('\n\r\r\n\f<!---->//""\'\'/*\r\n\f*/1a;.\\31\t\+2{url(a);func();+1.2e3 -.4e-5 .6e+7}').getLocation();

	var Tokenizer_1 = Tokenizer;

	var tokenizer = Tokenizer_1;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateSequence(node, forceBraces, decorate) {
	    var result = node.terms.map(function(term) {
	        return generate(term, forceBraces, decorate);
	    }).join(node.combinator === ' ' ? ' ' : ' ' + node.combinator + ' ');

	    if (node.explicit || forceBraces) {
	        result = (result[0] !== ',' ? '[ ' : '[') + result + ' ]';
	    }

	    return result;
	}

	function generate(node, forceBraces, decorate) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, forceBraces, decorate) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, forceBraces, decorate) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, forceBraces, decorate);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = 0;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    if (node === null) {
	        mismatchOffset = css.length;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, lexer, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error$1 = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS$2 = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS$2 &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS$2;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS$2 &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS$2) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var findIdentifierEnd$2 = utils.findIdentifierEnd;
	var findNumberEnd$2 = utils.findNumberEnd;
	var findDecimalNumberEnd$1 = utils.findDecimalNumberEnd;
	var isHex$1 = utils.isHex;

	var SYMBOL_TYPE$2 = _const.SYMBOL_TYPE;
	var IDENTIFIER$2 = _const.TYPE.Identifier;
	var PLUSSIGN$2 = _const.TYPE.PlusSign;
	var HYPHENMINUS$3 = _const.TYPE.HyphenMinus;
	var NUMBERSIGN = _const.TYPE.NumberSign;

	var PERCENTAGE = {
	    '%': true
	};

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	function consumeFunction(token, addTokenToMatch, getNextToken) {
	    var length = 1;
	    var cursor;

	    do {
	        cursor = getNextToken(length++);
	    } while (cursor !== null && cursor.node !== token.node);

	    if (cursor === null) {
	        return false;
	    }

	    while (true) {
	        // consume tokens until cursor
	        if (addTokenToMatch() === cursor) {
	            break;
	        }
	    }

	    return true;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(token, addTokenToMatch, getNextToken) {
	    if (token === null) {
	        return false;
	    }

	    var name = token.value.toLowerCase();
	    if (name !== 'calc(' &&
	        name !== '-moz-calc(' &&
	        name !== '-webkit-calc(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function attr$1(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'attr(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function expression(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'expression(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function url(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'url(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function idSelector(token, addTokenToMatch) {
	    if (token === null) {
	        return false;
	    }

	    if (token.value.charCodeAt(0) !== NUMBERSIGN) {
	        return false;
	    }

	    if (consumeIdentifier(token.value, 1) !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function isNumber$2(str) {
	    return /^[-+]?(\d+|\d*\.\d+)([eE][-+]?\d+)?$/.test(str);
	}

	function consumeNumber(str, allowFraction) {
	    var code = str.charCodeAt(0);

	    return findNumberEnd$2(str, code === PLUSSIGN$2 || code === HYPHENMINUS$3 ? 1 : 0, allowFraction);
	}

	function consumeIdentifier(str, offset) {
	    var code = str.charCodeAt(offset);

	    if (code < 0x80 && SYMBOL_TYPE$2[code] !== IDENTIFIER$2 && code !== HYPHENMINUS$3) {
	        return offset;
	    }

	    return findIdentifierEnd$2(str, offset + 1);
	}

	function astNode(type) {
	    return function(token, addTokenToMatch) {
	        if (token === null || token.node.type !== type) {
	            return false;
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function dimension(type) {
	    return function(token, addTokenToMatch, getNextToken) {
	        if (calc(token, addTokenToMatch, getNextToken)) {
	            return true;
	        }

	        if (token === null) {
	            return false;
	        }

	        var numberEnd = consumeNumber(token.value, true);
	        if (numberEnd === 0) {
	            return false;
	        }

	        if (type) {
	            if (!type.hasOwnProperty(token.value.substr(numberEnd).toLowerCase())) {
	                return false;
	            }
	        } else {
	            var unitEnd = consumeIdentifier(token.value, numberEnd);
	            if (unitEnd === numberEnd || unitEnd !== token.value.length) {
	                return false;
	            }
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function zeroUnitlessDimension(type) {
	    var isDimension = dimension(type);

	    return function(token, addTokenToMatch, getNextToken) {
	        if (isDimension(token, addTokenToMatch, getNextToken)) {
	            return true;
	        }

	        if (token === null || Number(token.value) !== 0) {
	            return false;
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function number(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = consumeNumber(token.value, true);
	    if (numberEnd !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function numberZeroOne(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null || !isNumber$2(token.value)) {
	        return false;
	    }

	    var value = Number(token.value);
	    if (value < 0 || value > 1) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function numberOneOrGreater(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null || !isNumber$2(token.value)) {
	        return false;
	    }

	    var value = Number(token.value);
	    if (value < 1) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	// TODO: fail on 10e-2
	function integer(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = consumeNumber(token.value, false);
	    if (numberEnd !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	// TODO: fail on 10e-2
	function positiveInteger(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = findDecimalNumberEnd$1(token.value, 0);
	    if (numberEnd !== token.value.length || token.value.charCodeAt(0) === HYPHENMINUS$3) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function hexColor(token, addTokenToMatch) {
	    if (token === null || token.value.charCodeAt(0) !== NUMBERSIGN) {
	        return false;
	    }

	    var length = token.value.length - 1;

	    // valid length is 3, 4, 6 and 8 (+1 for #)
	    if (length !== 3 && length !== 4 && length !== 6 && length !== 8) {
	        return false;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHex$1(token.value.charCodeAt(i))) {
	            return false;
	        }
	    }

	    addTokenToMatch();
	    return true;
	}

	// https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	// https://drafts.csswg.org/css-values-4/#identifier-value
	function customIdent(token, addTokenToMatch) {
	    if (token === null) {
	        return false;
	    }

	    var identEnd = consumeIdentifier(token.value, 0);
	    if (identEnd !== token.value.length) {
	        return false;
	    }

	    var name = token.value.toLowerCase();

	    //  3.2. Author-defined Identifiers: the <custom-ident> type
	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (name === 'unset' || name === 'initial' || name === 'inherit') {
	        return false;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (name === 'default') {
	        return false;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)

	    addTokenToMatch();
	    return true;
	}

	var generic = {
	    'angle': zeroUnitlessDimension(ANGLE),
	    'attr()': attr$1,
	    'custom-ident': customIdent,
	    'decibel': dimension(DECIBEL),
	    'dimension': dimension(),
	    'frequency': dimension(FREQUENCY),
	    'flex': dimension(FLEX),
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'ident': astNode('Identifier'),
	    'integer': integer,
	    'length': zeroUnitlessDimension(LENGTH),
	    'number': number,
	    'number-zero-one': numberZeroOne,
	    'number-one-or-greater': numberOneOrGreater,
	    'percentage': dimension(PERCENTAGE),
	    'positive-integer': positiveInteger,
	    'resolution': dimension(RESOLUTION),
	    'semitones': dimension(SEMITONES),
	    'string': astNode('String'),
	    'time': dimension(TIME),
	    'unicode-range': astNode('UnicodeRange'),
	    'url': url,

	    // old IE stuff
	    'progid': astNode('Raw'),
	    'expression': expression
	};

	var SyntaxParseError = function(message, input, offset) {
	    var error = createCustomError('SyntaxParseError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var error$2 = {
	    SyntaxParseError: SyntaxParseError
	};

	var SyntaxParseError$1 = error$2.SyntaxParseError;

	var TAB$2 = 9;
	var N$3 = 10;
	var F$3 = 12;
	var R$3 = 13;
	var SPACE$2 = 32;

	var Tokenizer$1 = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer$1.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R$3 && code !== N$3 && code !== F$3 && code !== SPACE$2 && code !== TAB$2) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new SyntaxParseError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer$1;

	var TAB$3 = 9;
	var N$4 = 10;
	var F$4 = 12;
	var R$4 = 13;
	var SPACE$3 = 32;
	var EXCLAMATIONMARK$1 = 33;    // !
	var NUMBERSIGN$1 = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE$1 = 39;         // '
	var LEFTPARENTHESIS$1 = 40;    // (
	var RIGHTPARENTHESIS$1 = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$3 = 43;           // +
	var COMMA = 44;              // ,
	var LESSTHANSIGN$1 = 60;       // <
	var GREATERTHANSIGN$1 = 62;    // >
	var QUESTIONMARK = 63;       // ?
	var COMMERCIALAT$1 = 64;       // @
	var LEFTSQUAREBRACKET$1 = 91;  // [
	var RIGHTSQUAREBRACKET$1 = 93; // ]
	var LEFTCURLYBRACKET$1 = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET$1 = 125; // }
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos + 1)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET$1);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET$1) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET$1);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$3:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN$1:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET$1) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET$1:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN$1);
	    tokenizer.eat(APOSTROPHE$1);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE$1);
	    tokenizer.eat(GREATERTHANSIGN$1);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	function readType(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN$1);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS$1 &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS$1) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    tokenizer.eat(GREATERTHANSIGN$1);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS$1) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET$1);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET$1);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK$1) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET$1:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET$1:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN$1:
	            return tokenizer.nextCharCode() === APOSTROPHE$1
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE$1:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$3:
	        case TAB$3:
	        case N$4:
	        case R$4:
	        case F$4:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT$1:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$3:
	        case QUESTIONMARK:
	        case NUMBERSIGN$1:
	        case EXCLAMATIONMARK$1:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET$1:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(str) {
	    var tokenizer = new tokenizer$1(str);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== str.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node, context);
	};

	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = null;
	        var tokens = [];

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                if (tokens.length > 0) {
	                    switch (curNode.type) {
	                        case 'Dimension':
	                        case 'HexColor':
	                        case 'IdSelector':
	                        case 'Percentage':
	                            if (prev.node === curNode) {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;

	                        case 'Function':
	                        case 'PseudoClassSelector':
	                        case 'PseudoElementSelector':
	                        case 'Url':
	                            if (chunk === '(') {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;

	                        case 'Atrule':
	                            if (prev.node === curNode && prev.value === '@') {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;
	                    }
	                }

	                tokens.push(prev = {
	                    value: chunk,
	                    node: curNode
	                });
	            },
	            result: function() {
	                return tokens;
	            }
	        };
	    }
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$2 = 40;  // (
	var RIGHTPARENTHESIS$2 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$2 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$2
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;

	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 10000;
	var totalIterationCount = 0;

	function mapList(list, fn) {
	    var result = [];

	    while (list) {
	        result.unshift(fn(list));
	        list = list.prev;
	    }

	    return result;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    token = token.value.charAt(token.value.length - 1);

	    return (
	        token === ',' ||
	        token === '(' ||
	        token === '[' ||
	        token === '/'
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    token = token.value.charAt(0);

	    return (
	        token === ')' ||
	        token === ']' ||
	        token === '/'
	    );
	}

	function internalMatch(tokens, syntax, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenCursor++;
	            token = tokenCursor < tokens.length ? tokens[tokenCursor] : null;
	        } while (token !== null && !/\S/.test(token.value));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenCursor + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function pushThenStack(nextSyntax) {
	        thenStack = {
	            nextSyntax: nextSyntax,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextSyntax) {
	        elseStack = {
	            nextSyntax: nextSyntax,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenCursor: tokenCursor,
	            token: token,
	            prev: elseStack
	        };
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: syntax.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();

	        if (tokenCursor > longestMatch) {
	            longestMatch = tokenCursor;
	        }

	        return matchStack.token;
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: syntax,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: syntax.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    var iterationCount = 0;
	    var exitReason = EXIT_REASON_MATCH;

	    var matchStack = { type: 'Stub', syntax: null, token: null, tokenCursor: -1, prev: null };
	    var longestMatch = 0;
	    var tokenCursor = -1;
	    var token = null;

	    moveToNextToken();

	    while (true) {
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? x.type + '!' + x.syntax.name : null),
	        //         elseStack: mapList(elseStack, x => x.id),
	        //         thenStack: mapList(thenStack, x => x.id),
	        //         token: token && token.value,
	        //         tokenCursor,
	        //         syntax
	        //     }, { depth: null })
	        // );

	        // prevent infinite loop
	        if (++iterationCount === ITERATION_LIMIT) {
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            break;
	        }

	        if (syntax === MATCH$1) {
	            if (thenStack === null) {
	                // turn to MISMATCH when some tokens left unmatched
	                if (token !== null) {
	                    // doesn't mismatch if just one token left and it's an IE hack
	                    if (tokenCursor !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                        syntax = MISMATCH$1;
	                        continue;
	                    }
	                }

	                // break the main loop, return a result - MATCH
	                exitReason = EXIT_REASON_MATCH;
	                break;
	            }

	            // go to next syntax (`then` branch)
	            syntax = thenStack.nextSyntax;

	            // check match is not empty
	            if (syntax === DISALLOW_EMPTY$1) {
	                if (thenStack.matchStack.token === matchStack.token) {
	                    syntax = MISMATCH$1;
	                    continue;
	                } else {
	                    syntax = MATCH$1;
	                }
	            }

	            // close syntax if needed
	            while (syntaxStack !== null && thenStack.syntaxStack !== syntaxStack) {
	                closeSyntax();
	            }

	            // pop stack
	            thenStack = thenStack.prev;
	            continue;
	        }

	        if (syntax === MISMATCH$1) {
	            if (elseStack === null) {
	                // break the main loop, return a result - MISMATCH
	                exitReason = EXIT_REASON_MISMATCH;
	                break;
	            }

	            // go to next syntax (`else` branch)
	            syntax = elseStack.nextSyntax;

	            // restore all the rest stack states
	            thenStack = elseStack.thenStack;
	            syntaxStack = elseStack.syntaxStack;
	            matchStack = elseStack.matchStack;
	            tokenCursor = elseStack.tokenCursor;
	            token = elseStack.token;

	            // pop stack
	            elseStack = elseStack.prev;
	            continue;
	        }

	        switch (syntax.type) {
	            case 'MatchGraph':
	                syntax = syntax.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (syntax.else !== MISMATCH$1) {
	                    pushElseStack(syntax.else);
	                }

	                if (syntax.then !== MATCH$1) {
	                    pushThenStack(syntax.then);
	                }

	                syntax = syntax.match;
	                break;

	            case 'MatchOnce':
	                syntax = {
	                    type: 'MatchOnceBuffer',
	                    terms: syntax.terms,
	                    all: syntax.all,
	                    matchStack: matchStack,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                if (syntax.index === syntax.terms.length) {
	                    // if no matches during a cycle
	                    if (syntax.matchStack === matchStack) {
	                        // no matches at all or it's required all terms to be matched
	                        if (syntax.mask === 0 || syntax.all) {
	                            syntax = MISMATCH$1;
	                            break;
	                        }

	                        // a partial match is ok
	                        syntax = MATCH$1;
	                        break;
	                    } else {
	                        // start trying to match from the start
	                        syntax.index = 0;
	                        syntax.matchStack = matchStack;
	                    }
	                }

	                for (; syntax.index < syntax.terms.length; syntax.index++) {
	                    if ((syntax.mask & (1 << syntax.index)) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(syntax);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            buffer: syntax
	                        });

	                        // match
	                        syntax = syntax.terms[syntax.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                syntax = syntax.buffer;

	                var newMask = syntax.mask | (1 << (syntax.index - 1));

	                // all terms are matched
	                if (newMask === (1 << syntax.terms.length) - 1) {
	                    syntax = MATCH$1;
	                    continue;
	                }

	                syntax = {
	                    type: 'MatchOnceBuffer',
	                    terms: syntax.terms,
	                    all: syntax.all,
	                    matchStack: syntax.matchStack,
	                    index: syntax.index,
	                    mask: newMask
	                };

	                break;

	            case 'Enum':
	                var name = token !== null ? token.value.toLowerCase() : '';

	                // drop \0 and \9 hack from keyword name
	                if (name.indexOf('\\') !== -1) {
	                    name = name.replace(/\\[09].*$/, '');
	                }

	                if (hasOwnProperty$1.call(syntax.map, name)) {
	                    syntax = syntax.map[name];
	                } else {
	                    syntax = MISMATCH$1;
	                }

	                break;

	            case 'Generic':
	                syntax = syntax.fn(token, addTokenToMatch, getNextToken) ? MATCH$1 : MISMATCH$1;
	                break;

	            case 'Type':
	            case 'Property':
	                openSyntax();

	                var syntaxDict = syntax.type === 'Type' ? 'types' : 'properties';

	                if (hasOwnProperty$1.call(syntaxes, syntaxDict) && syntaxes[syntaxDict][syntax.name]) {
	                    syntax = syntaxes[syntaxDict][syntax.name].match;
	                } else {
	                    syntax = undefined;
	                }

	                if (!syntax) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (syntaxStack.syntax.type === 'Type'
	                            ? '<' + syntaxStack.syntax.name + '>'
	                            : '<\'' + syntaxStack.syntax.name + '\'>')
	                    );
	                }

	                break;

	            case 'Keyword':
	                var name = syntax.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (keywordName.toLowerCase() === name) {
	                        addTokenToMatch();

	                        syntax = MATCH$1;
	                        break;
	                    }
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && token.value.toLowerCase() === syntax.name) {
	                    addTokenToMatch();

	                    syntax = MATCH$1;
	                    break;
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === syntax.value) {
	                    addTokenToMatch();

	                    syntax = MATCH$1;
	                    break;
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.value === ',') {
	                    if (isCommaContextStart(matchStack.token)) {
	                        syntax = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        syntax = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    syntax = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            // case 'String':
	            // TODO: strings with length other than 1 char

	            default:
	                throw new Error('Unknown node type: ' + syntax.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    if (exitReason === EXIT_REASON_MATCH) {
	        while (syntaxStack !== null) {
	            closeSyntax();
	        }
	    } else {
	        matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph$$1, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph$$1, syntaxes || {});

	    if (matchResult.match !== null) {
	        matchResult.match = mapList(matchResult.match, function(item) {
	            if (item.type === OPEN_SYNTAX || item.type === CLOSE_SYNTAX) {
	                return { type: item.type, syntax: item.syntax };
	            }

	            return {
	                syntax: item.syntax,
	                token: item.token && item.token.value,
	                node: item.token && item.token.node
	            };
	        }).slice(1);
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph$$1, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph$$1, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var cursor = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph$$1.syntax || null,
	        match: []
	    };
	    var stack = [host];

	    // revert a list
	    var prev = null;
	    var next = null;
	    while (cursor !== null) {
	        next = cursor.prev;
	        cursor.prev = prev;
	        prev = cursor;
	        cursor = next;
	    }

	    // init the cursor to start with 2nd item since 1st is a stub item
	    cursor = prev.prev;

	    // build a tree
	    while (cursor !== null && cursor.syntax !== null) {
	        var entry = cursor;

	        switch (entry.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: entry.syntax,
	                    match: []
	                });
	                stack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                stack.pop();
	                host = stack[stack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: entry.syntax || null,
	                    token: entry.token.value,
	                    node: entry.token.node
	                });
	        }

	        cursor = cursor.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list$$1) {
	                if (node === start) {
	                    var nodes = new list();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list$$1,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof list;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error$1.SyntaxReferenceError;
	var MatchError$1 = error$1.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords = buildMatchGraph$1(parse_1('inherit | initial | unset'));
	var cssWideKeywordsWithExpression = buildMatchGraph$1(parse_1('inherit | initial | unset | <expression>'));

	function dumpMapSyntax(map, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst ? map[name].syntax : generate_1(map[name].syntax);
	        }
	    }

	    return result;
	}

	function valueHasVar(value) {
	    var hasVar = false;

	    this.syntax.walk(value, function(node) {
	        if (node.type === 'Function' && node.name.toLowerCase() === 'var') {
	            hasVar = true;
	        }
	    });

	    return hasVar;
	}

	function buildMatchResult(match$$1, error, iterations) {
	    return {
	        matched: match$$1,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, node, useCommon) {
	    if (!node) {
	        return buildMatchResult(null, new Error('Node is undefined'));
	    }

	    if (valueHasVar.call(lexer, node)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    var tokens = lexer.syntax.generate(node, astToTokens);
	    var result;

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, lexer, syntax.syntax, node, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure$$1) {
	    this.valueCommonSyntax = cssWideKeywords;
	    this.syntax = syntax;
	    this.generic = false;
	    this.properties = {};
	    this.types = {};
	    this.structure = structure$$1 || getStructureFromConfig(config);

	    if (config) {
	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure$$1 = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure$$1.hasOwnProperty(node.type)) {
	                structure$$1[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic.expression) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (!syntax || !syntax.type) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (!syntax.match) {
	            syntax = this.createDescriptor(syntax);
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var grammar = {
	    SyntaxParseError: error$2.SyntaxParseError,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var TYPE$3 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$3.WhiteSpace;
	var COMMENT$2 = TYPE$3.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var noop$3 = function() {};

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new tokenizer(),
	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new list();
	        },
	        createSingleNodeList: function(node) {
	            return new list().appendData(node);
	        },
	        getFirstListNode: function(list$$1) {
	            return list$$1 && list$$1.first();
	        },
	        getLastListNode: function(list$$1) {
	            return list$$1.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.currentToken;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.scanner.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list$$1) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list$$1);
	                var tail = this.getLastListNode(list$$1);
	                return this.scanner.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        parser.scanner.setSource(source, options.offset, options.line, options.column);
	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.scanner.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var binarySearch = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;

	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	  // This function terminates when one of the following is true:
	  //
	  //   1. We find the exact element we are looking for.
	  //
	  //   2. We did not find the exact element, but we can return the index of
	  //      the next-closest element.
	  //
	  //   3. We did not find the exact element, and there is no next-closest
	  //      element than the one we are searching for, so we return -1.
	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
	  if (cmp === 0) {
	    // Found the element we are looking for.
	    return mid;
	  }
	  else if (cmp > 0) {
	    // Our needle is greater than aHaystack[mid].
	    if (aHigh - mid > 1) {
	      // The element is in the upper half.
	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // The exact needle element was not found in this haystack. Determine if
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return aHigh < aHaystack.length ? aHigh : -1;
	    } else {
	      return mid;
	    }
	  }
	  else {
	    // Our needle is less than aHaystack[mid].
	    if (mid - aLow > 1) {
	      // The element is in the lower half.
	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return mid;
	    } else {
	      return aLow < 0 ? -1 : aLow;
	    }
	  }
	}

	/**
	 * This is an implementation of binary search which will always try and return
	 * the index of the closest element if there is no exact hit. This is because
	 * mappings between original and generated line/col pairs are single points,
	 * and there is an implicit region between each of them, so a miss just means
	 * that you aren't on the very start of a region.
	 *
	 * @param aNeedle The element you are looking for.
	 * @param aHaystack The array that is being searched.
	 * @param aCompare A function which takes the needle and an element in the
	 *     array and returns -1, 0, or 1 depending on whether the needle is less
	 *     than, equal to, or greater than the element, respectively.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	 */
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	  if (aHaystack.length === 0) {
	    return -1;
	  }

	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	  if (index < 0) {
	    return -1;
	  }

	  // We have found either the exact element, or the next-closest element than
	  // the one we are searching for. However, there may be more than one such
	  // element. Make sure we always return the smallest of these.
	  while (index - 1 >= 0) {
	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	      break;
	    }
	    --index;
	  }

	  return index;
	};
	});
	var binarySearch_1 = binarySearch.GREATEST_LOWER_BOUND;
	var binarySearch_2 = binarySearch.LEAST_UPPER_BOUND;
	var binarySearch_3 = binarySearch.search;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	var quickSort_1 = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};

	var quickSort = {
		quickSort: quickSort_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$2 = arraySet.ArraySet;

	var quickSort$1 = quickSort.quickSort;

	function SourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap)
	    : new BasicSourceMapConsumer(sourceMap);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      if (source != null && sourceRoot != null) {
	        source = util.join(sourceRoot, source);
	      }
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: Optional. the column number in the original source.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    if (this.sourceRoot != null) {
	      needle.source = util.relative(this.sourceRoot, needle.source);
	    }
	    if (!this._sources.has(needle.source)) {
	      return [];
	    }
	    needle.source = this._sources.indexOf(needle.source);

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	var SourceMapConsumer_1 = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The only parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet$2.fromArray(names.map(String), true);
	  this._sources = ArraySet$2.fromArray(sources, true);

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._sources.toArray().map(function (s) {
	      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	    }, this);
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64Vlq.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort$1(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          if (this.sourceRoot != null) {
	            source = util.join(this.sourceRoot, source);
	          }
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    if (this.sourceRoot != null) {
	      aSource = util.relative(this.sourceRoot, aSource);
	    }

	    if (this._sources.has(aSource)) {
	      return this.sourcesContent[this._sources.indexOf(aSource)];
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + aSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    if (this.sourceRoot != null) {
	      source = util.relative(this.sourceRoot, source);
	    }
	    if (!this._sources.has(source)) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	    source = this._sources.indexOf(source);

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The only parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet$2();
	  this._names = new ArraySet$2();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        if (section.consumer.sourceRoot !== null) {
	          source = util.join(section.consumer.sourceRoot, source);
	        }
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = section.consumer._names.at(mapping.name);
	        this._names.add(name);
	        name = this._names.indexOf(name);

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort$1(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
	  };

	var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

	var sourceMapConsumer = {
		SourceMapConsumer: SourceMapConsumer_1,
		BasicSourceMapConsumer: BasicSourceMapConsumer_1,
		IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;


	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex];
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex];
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator$1(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	var SourceNode_1 = SourceNode;

	var sourceNode = {
		SourceNode: SourceNode_1
	};

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
	var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
	var SourceNode$1 = sourceNode.SourceNode;

	var sourceMap = {
		SourceMapGenerator: SourceMapGenerator$2,
		SourceMapConsumer: SourceMapConsumer$1,
		SourceNode: SourceNode$1
	};

	var SourceMapGenerator$3 = sourceMap.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap$1 = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$3();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap$1(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof list === false) {
	                        node.children = new list().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof list) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = reverse ? config.fields.slice().reverse() : config.fields;
	    var body = fields.map(function(field) {
	        var ref = 'node.' + field.name;
	        var line;

	        if (field.type === 'list') {
	            line = reverse
	                ? ref + '.forEachRight(walk);'
	                : ref + '.forEach(walk);';
	        } else {
	            line = 'walk(' + ref + ');';
	        }

	        if (field.nullable) {
	            line = 'if (' + ref + ') {\n    ' + line + '}';
	        }

	        return line;
	    });

	    if (config.context) {
	        body = [].concat(
	            'var old = context.' + config.context + ';',
	            'context.' + config.context + ' = node;',
	            body,
	            'context.' + config.context + ' = old;'
	        );
	    }

	    return new Function('node', 'context', 'walk', body.join('\n'));
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    return function walk(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof list) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        var res = {};
	        for (var key in value) {
	            if (hasOwnProperty$5.call(value, key)) {
	                res[key] = value[key];
	            }
	        }
	        return res;
	    } else {
	        return value;
	    }
	}

	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function assign$1(dest, src) {
	    for (var key in src) {
	        dest[key] = src[key];
	    }

	    return dest;
	}

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: list,
	        Tokenizer: tokenizer,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        grammar: grammar,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        parse: parse,
	        walk: walk,
	        generate: generate,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, assign$1)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var appearance = {
		syntax: "auto | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var border = {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	};
	var opacity = {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var quotes = {
		syntax: "none | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var rotate = {
		syntax: "none | [ x | y | z | <number>{3} ]? && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-timing-function": {
		syntax: "<single-timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		appearance: appearance,
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		border: border,
		"border-block-end": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-end-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-bottom": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-inline-end": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-left": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-style": {
		syntax: "<br-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-width": {
		syntax: "<br-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-after": {
		syntax: "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-before": {
		syntax: "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		margin: margin,
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-block-end": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-block-start": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-inline-end": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-inline-start": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angle",
		percentages: "no",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-style": {
		syntax: "auto | <br-style>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-width": {
		syntax: "<br-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "<'overflow'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overflow-inline": {
		syntax: "<'overflow'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		padding: padding,
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		scale: scale,
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"scroll-snap-type": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"shape-image-threshold": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-timing-function": {
		syntax: "<single-transition-timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		default: properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"br-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"br-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color> <length-percentage>?"
	},
		"color-stop-list": {
		syntax: "<color-stop>#{2,}"
	},
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | subgrid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> {\n  <feature-value-declaration-list>\n}"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frames-timing-function": {
		syntax: "frames(<integer>)"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( [ [ <image> | <string> ]? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <border-radius> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number> [, <number> ]{5,5} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number> [, <number> ]{15,15} )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> {\n  <declaration-list>\n}"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( <angle> )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , <angle> )"
	},
		"rotateX()": {
		syntax: "rotateX( <angle> )"
	},
		"rotateY()": {
		syntax: "rotateY( <angle> )"
	},
		"rotateZ()": {
		syntax: "rotateZ( <angle> )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> [, <number> ]? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( <angle> [, <angle> ]? )"
	},
		"skewX()": {
		syntax: "skewX( <angle> )"
	},
		"skewY()": {
		syntax: "skewY( <angle> )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function> | <frames-timing-function>"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <single-transition-timing-function> || <time>"
	},
		"single-transition-timing-function": {
		syntax: "<single-timing-function>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, [ start | end ] ]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> [, <length-percentage> ]? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | integer | color | url | integer | number | length | angle | time | frequency | em | ex | px | rem | vw | vh | vmin | vmax | mm | q | cm | in | pt | pc | deg | grad | rad | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> [, <declaration-value> ]? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		attachment: attachment,
		box: box,
		color: color$1,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		default: syntaxes
	});

	var properties$3 = {
		"--*": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-line-clamp": {
			comment: "non-standard and deprecated but may still using by some sites",
			syntax: "<positive-integer>"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-mask-clip": {
			comment: "change type to <-webkit-mask-clip-style> since it differ from <mask-clip>, extra space between [ and ,",
			syntax: "<-webkit-mask-clip-style> [, <-webkit-mask-clip-style> ]*"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			refenrences: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "none | inline | block | list-item | inline-list-item | inline-block | inline-table | table | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | flex | inline-flex | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter>"
		},
		font: {
			comment: "extend with non-standard fonts",
			syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar | <-non-standard-font>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		"line-height-step": {
			comment: "fix extra spaces around",
			syntax: "none | <length>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "visible | hidden | scroll | auto | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"transform-origin": {
			comment: "move first group to the end since less collecting",
			syntax: "[ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>? | [ <length-percentage> | left | center | right | top | bottom ]"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<unicode-range>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"word-break": {
			comment: "extend with non-standard keywords",
			syntax: "normal | break-all | keep-all | <-non-standard-word-break>"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to duoble sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			preferences: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-non-standard-word-break": {
			comment: "non-standard keywords https://css-tricks.com/almanac/properties/w/word-break/",
			syntax: "break-word"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter": {
			syntax: "[ <progid> | FlipH | FlipV ]+"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr()": {
			comment: "drop it since it's a generic",
			syntax: null
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"inset()": {
			comment: "changed <border-radius> to <'border-radius'>",
			syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added -webkit-gradient() since may to be used for legacy support",
			syntax: "<-legacy-gradient> | <linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"matrix()": {
			comment: "redundant max",
			syntax: "matrix( <number> [, <number> ]{5} )"
		},
		"matrix3d()": {
			comment: "redundant max",
			syntax: "matrix3d( <number> [, <number> ]{15} )"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "replaced <ident> to list of colors according to https://www.w3.org/TR/css-color-4/#named-colors",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		"outline-radius": {
			comment: "missed, looks like it's a similar to <border-radius> https://developer.mozilla.org/en/docs/Web/CSS/-moz-outline-radius",
			syntax: "<border-radius>"
		},
		paint: {
			comment: "simplified SVG syntax (omit <icccolor>, replace <funciri> for <url>) https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | currentColor | <color> | <url> [ none | currentColor | <color> ]?"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( [ [ <top>, <right>, <bottom>, <left> ] | [ <top> <right> <bottom> <left> ] ] )"
		},
		"single-transition": {
			comment: "moved <single-transition-timing-function> in the beginning to avoid wrong match to <single-transition-property>",
			syntax: "<single-transition-timing-function> || [ none | <single-transition-property> ] || <time> || <time>"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		"var()": {
			comment: "drop it since it's a generic (also syntax is incorrect and can't be parsed)",
			syntax: null
		},
		"an-plus-b": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-type": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-block": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-declaration": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-block-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-declaration-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"general-enclosed": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"keyframe-block": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"keyframe-block-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-plain": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-range": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-value": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-and": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-condition": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-not": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-or": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-in-parens": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-feature": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-condition-without-or": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-query": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-query-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		nth: {
			comment: "syntax has <an-plus-b> that doesn't support currently, drop for now",
			syntax: null
		},
		"page-selector": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-selector-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-body": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-margin-box": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-margin-box-type": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"pseudo-page": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		properties: properties$3,
		syntaxes: syntaxes$2,
		default: patch
	});

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    properties: buildDictionary(mdnProperties, patch$2.properties),
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes)
	};

	var cmpChar$1 = tokenizer.cmpChar;
	var isNumber$3 = tokenizer.isNumber;
	var TYPE$4 = tokenizer.TYPE;

	var IDENTIFIER$3 = TYPE$4.Identifier;
	var NUMBER$2 = TYPE$4.Number;
	var PLUSSIGN$4 = TYPE$4.PlusSign;
	var HYPHENMINUS$4 = TYPE$4.HyphenMinus;
	var N$5 = 110; // 'n'.charCodeAt(0)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function checkTokenIsInteger(scanner, disallowSign) {
	    var pos = scanner.tokenStart;

	    if (scanner.source.charCodeAt(pos) === PLUSSIGN$4 ||
	        scanner.source.charCodeAt(pos) === HYPHENMINUS$4) {
	        if (disallowSign) {
	            scanner.error();
	        }
	        pos++;
	    }

	    for (; pos < scanner.tokenEnd; pos++) {
	        if (!isNumber$3(scanner.source.charCodeAt(pos))) {
	            scanner.error('Unexpected input', pos);
	        }
	    }
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = start;
	        var prefix = '';
	        var a = null;
	        var b = null;

	        if (this.scanner.tokenType === NUMBER$2 ||
	            this.scanner.tokenType === PLUSSIGN$4) {
	            checkTokenIsInteger(this.scanner, ALLOW_SIGN);
	            prefix = this.scanner.getTokenValue();
	            this.scanner.next();
	            end = this.scanner.tokenStart;
	        }

	        if (this.scanner.tokenType === IDENTIFIER$3) {
	            var bStart = this.scanner.tokenStart;

	            if (cmpChar$1(this.scanner.source, bStart, HYPHENMINUS$4)) {
	                if (prefix === '') {
	                    prefix = '-';
	                    bStart++;
	                } else {
	                    this.scanner.error('Unexpected hyphen minus');
	                }
	            }

	            if (!cmpChar$1(this.scanner.source, bStart, N$5)) {
	                this.scanner.error();
	            }

	            a = prefix === ''  ? '1'  :
	                prefix === '+' ? '+1' :
	                prefix === '-' ? '-1' :
	                prefix;

	            var len = this.scanner.tokenEnd - bStart;
	            if (len > 1) {
	                // ..n-..
	                if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS$4) {
	                    this.scanner.error('Unexpected input', bStart + 1);
	                }

	                if (len > 2) {
	                    // ..n-{number}..
	                    this.scanner.tokenStart = bStart + 2;
	                } else {
	                    // ..n- {number}
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                }

	                checkTokenIsInteger(this.scanner, DISALLOW_SIGN);
	                b = '-' + this.scanner.getTokenValue();
	                this.scanner.next();
	                end = this.scanner.tokenStart;
	            } else {
	                prefix = '';
	                this.scanner.next();
	                end = this.scanner.tokenStart;
	                this.scanner.skipSC();

	                if (this.scanner.tokenType === HYPHENMINUS$4 ||
	                    this.scanner.tokenType === PLUSSIGN$4) {
	                    prefix = this.scanner.getTokenValue();
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                }

	                if (this.scanner.tokenType === NUMBER$2) {
	                    checkTokenIsInteger(this.scanner, prefix !== '');

	                    if (!isNumber$3(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
	                        prefix = this.scanner.source.charAt(this.scanner.tokenStart);
	                        this.scanner.tokenStart++;
	                    }

	                    if (prefix === '') {
	                        // should be an operator before number
	                        this.scanner.error();
	                    } else if (prefix === '+') {
	                        // plus is using by default
	                        prefix = '';
	                    }

	                    b = prefix + this.scanner.getTokenValue();

	                    this.scanner.next();
	                    end = this.scanner.tokenStart;
	                } else {
	                    if (prefix) {
	                        this.scanner.eat(NUMBER$2);
	                    }
	                }
	            }
	        } else {
	            if (prefix === '' || prefix === '+') { // no number
	                this.scanner.error(
	                    'Number or identifier is expected',
	                    this.scanner.tokenStart + (
	                        this.scanner.tokenType === PLUSSIGN$4 ||
	                        this.scanner.tokenType === HYPHENMINUS$4
	                    )
	                );
	            }

	            b = prefix;
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, end),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' :
	                node.a ===  '1' ?  'n' :
	                node.a === '-1' ? '-n' :
	                node.a + 'n'
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$5 = tokenizer.TYPE;

	var ATKEYWORD$2 = TYPE$5.AtKeyword;
	var SEMICOLON = TYPE$5.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$5.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$5.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, SEMICOLON, LEFTCURLYBRACKET$2, false, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$2) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$2 ||
	            type === ATKEYWORD$2) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.scanner.eat(ATKEYWORD$2);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.currentToken);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$2:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$6 = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$6.Semicolon;
	var LEFTCURLYBRACKET$3 = TYPE$6.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$3 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.scanner.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$7 = tokenizer.TYPE;

	var IDENTIFIER$4 = TYPE$7.Identifier;
	var STRING$2 = TYPE$7.String;
	var DOLLARSIGN = TYPE$7.DollarSign;
	var ASTERISK$1 = TYPE$7.Asterisk;
	var COLON = TYPE$7.Colon;
	var EQUALSSIGN = TYPE$7.EqualsSign;
	var LEFTSQUAREBRACKET$2 = TYPE$7.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$7.RightSquareBracket;
	var CIRCUMFLEXACCENT = TYPE$7.CircumflexAccent;
	var VERTICALLINE$1 = TYPE$7.VerticalLine;
	var TILDE = TYPE$7.Tilde;

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.scanner.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdentifier = false;
	    var checkColon = true;

	    if (this.scanner.tokenType === ASTERISK$1) {
	        expectIdentifier = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (this.scanner.tokenType !== VERTICALLINE$1) {
	        this.scanner.eat(IDENTIFIER$4);
	    }

	    if (this.scanner.tokenType === VERTICALLINE$1) {
	        if (this.scanner.lookupType(1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.scanner.eat(IDENTIFIER$4);
	        } else if (expectIdentifier) {
	            this.scanner.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdentifier) {
	        this.scanner.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.scanner.eat(IDENTIFIER$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var tokenType = this.scanner.tokenType;

	    if (tokenType !== EQUALSSIGN &&        // =
	        tokenType !== TILDE &&             // ~=
	        tokenType !== CIRCUMFLEXACCENT &&  // ^=
	        tokenType !== DOLLARSIGN &&        // $=
	        tokenType !== ASTERISK$1 &&          // *=
	        tokenType !== VERTICALLINE$1         // |=
	    ) {
	        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    if (tokenType === EQUALSSIGN) {
	        this.scanner.next();
	    } else {
	        this.scanner.next();
	        this.scanner.eat(EQUALSSIGN);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' S* attrib_name ']'
	// '[' S* attrib_name S* attrib_matcher S* [ IDENT | STRING ] S* attrib_flags? S* ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.scanner.eat(LEFTSQUAREBRACKET$2);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$2) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENTIFIER$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING$2
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENTIFIER$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.scanner.eat(RIGHTSQUAREBRACKET$2);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$8 = tokenizer.TYPE;

	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var COMMENT$3 = TYPE$8.Comment;
	var SEMICOLON$2 = TYPE$8.Semicolon;
	var ATKEYWORD$3 = TYPE$8.AtKeyword;
	var LEFTCURLYBRACKET$4 = TYPE$8.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$3 = TYPE$8.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, 0, 0, false, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, 0, SEMICOLON$2, true, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.currentToken);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.scanner.eat(LEFTCURLYBRACKET$4);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$3:
	                    break scan;

	                case WHITESPACE$3:
	                case COMMENT$3:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$3:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTCURLYBRACKET$3);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$9 = tokenizer.TYPE;
	var LEFTSQUAREBRACKET$3 = TYPE$9.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$3 = TYPE$9.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.scanner.eat(LEFTSQUAREBRACKET$3);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTSQUAREBRACKET$3);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC$2 = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(CDC$2); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO$2 = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(CDO$2); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$a = tokenizer.TYPE;
	var IDENTIFIER$5 = TYPE$a.Identifier;
	var FULLSTOP$2 = TYPE$a.FullStop;

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        this.scanner.eat(FULLSTOP$2);

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$b = tokenizer.TYPE;

	var PLUSSIGN$5 = TYPE$b.PlusSign;
	var SOLIDUS = TYPE$b.Solidus;
	var GREATERTHANSIGN$2 = TYPE$b.GreaterThanSign;
	var TILDE$1 = TYPE$b.Tilde;

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        switch (this.scanner.tokenType) {
	            case GREATERTHANSIGN$2:
	            case PLUSSIGN$5:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();
	                this.scanner.expectIdentifier('deep');
	                this.scanner.eat(SOLIDUS);
	                break;

	            default:
	                this.scanner.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$c = tokenizer.TYPE;

	var ASTERISK$2 = TYPE$c.Asterisk;
	var SOLIDUS$1 = TYPE$c.Solidus;

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        this.scanner.next();

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$d = tokenizer.TYPE;

	var IDENTIFIER$6 = TYPE$d.Identifier;
	var COLON$1 = TYPE$d.Colon;
	var EXCLAMATIONMARK$2 = TYPE$d.ExclamationMark;
	var SOLIDUS$2 = TYPE$d.Solidus;
	var ASTERISK$3 = TYPE$d.Asterisk;
	var DOLLARSIGN$1 = TYPE$d.DollarSign;
	var HYPHENMINUS$5 = TYPE$d.HyphenMinus;
	var SEMICOLON$3 = TYPE$d.Semicolon;
	var PLUSSIGN$6 = TYPE$d.PlusSign;
	var NUMBERSIGN$2 = TYPE$d.NumberSign;

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, EXCLAMATIONMARK$2, SEMICOLON$3, false, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, EXCLAMATIONMARK$2, SEMICOLON$3, false, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.currentToken;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.tokenType !== EXCLAMATIONMARK$2 &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.scanner.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.currentToken;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.scanner.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.currentToken);
	        }

	        if (this.scanner.tokenType === EXCLAMATIONMARK$2) {
	            important = getImportant(this.scanner);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.scanner.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;
	    var prefix = 0;

	    // hacks
	    switch (this.scanner.tokenType) {
	        case ASTERISK$3:
	        case DOLLARSIGN$1:
	        case PLUSSIGN$6:
	        case NUMBERSIGN$2:
	            prefix = 1;
	            break;

	        // TODO: not sure we should support this hack
	        case SOLIDUS$2:
	            prefix = this.scanner.lookupType(1) === SOLIDUS$2 ? 2 : 1;
	            break;
	    }

	    if (this.scanner.lookupType(prefix) === HYPHENMINUS$5) {
	        prefix++;
	    }

	    if (prefix) {
	        this.scanner.skip(prefix);
	    }

	    this.scanner.eat(IDENTIFIER$6);

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant(scanner) {
	    scanner.eat(EXCLAMATIONMARK$2);
	    scanner.skipSC();

	    var important = scanner.consume(IDENTIFIER$6);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$e = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$4 = TYPE$e.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, 0, SEMICOLON$4, true, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$4:
	                case COMMENT$4:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var NUMBER$3 = tokenizer.TYPE.Number;

	// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
	function readUnit(scanner) {
	    var unit = scanner.getTokenValue();
	    var backSlashPos = unit.indexOf('\\');

	    if (backSlashPos > 0) {
	        // patch token offset
	        scanner.tokenStart += backSlashPos;

	        // return part before backslash
	        return unit.substring(0, backSlashPos);
	    }

	    // no backslash in unit name
	    scanner.next();

	    return unit;
	}

	// number ident
	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value = this.scanner.consume(NUMBER$3);
	        var unit = readUnit(this.scanner);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value,
	            unit: unit
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$f = tokenizer.TYPE;
	var RIGHTPARENTHESIS$3 = TYPE$f.RightParenthesis;

	// <function-token> <sequence> ')'
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.scanner.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTPARENTHESIS$3);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var isHex$2 = tokenizer.isHex;
	var TYPE$g = tokenizer.TYPE;

	var IDENTIFIER$7 = TYPE$g.Identifier;
	var NUMBER$4 = TYPE$g.Number;
	var NUMBERSIGN$3 = TYPE$g.NumberSign;

	function consumeHexSequence(scanner, required) {
	    if (!isHex$2(scanner.source.charCodeAt(scanner.tokenStart))) {
	        if (required) {
	            scanner.error('Unexpected input', scanner.tokenStart);
	        } else {
	            return;
	        }
	    }

	    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
	        var code = scanner.source.charCodeAt(pos);

	        // break on non-hex char
	        if (!isHex$2(code)) {
	            // break token, exclude symbol
	            scanner.tokenStart = pos;
	            return;
	        }
	    }

	    // token is full hex sequence, go to next token
	    scanner.next();
	}

	// # ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(NUMBERSIGN$3);

	        scan:
	        switch (this.scanner.tokenType) {
	            case NUMBER$4:
	                consumeHexSequence(this.scanner, true);

	                // if token is identifier then number consists of hex only,
	                // try to add identifier to result
	                if (this.scanner.tokenType === IDENTIFIER$7) {
	                    consumeHexSequence(this.scanner, false);
	                }

	                break;

	            case IDENTIFIER$7:
	                consumeHexSequence(this.scanner, true);
	                break;

	            default:
	                this.scanner.error('Number or identifier is expected');
	        }

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1) // skip #
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$h = tokenizer.TYPE;
	var IDENTIFIER$8 = TYPE$h.Identifier;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;
	var IDENTIFIER$9 = TYPE$i.Identifier;
	var NUMBERSIGN$4 = TYPE$i.NumberSign;

	// '#' ident
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        this.scanner.eat(NUMBERSIGN$4);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$9)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$j = tokenizer.TYPE;

	var IDENTIFIER$a = TYPE$j.Identifier;
	var NUMBER$5 = TYPE$j.Number;
	var LEFTPARENTHESIS$3 = TYPE$j.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$j.RightParenthesis;
	var COLON$2 = TYPE$j.Colon;
	var SOLIDUS$3 = TYPE$j.Solidus;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.scanner.eat(LEFTPARENTHESIS$3);
	        this.scanner.skipSC();

	        name = this.scanner.consume(IDENTIFIER$a);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$4) {
	            this.scanner.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$5:
	                    if (this.scanner.lookupType(1) === IDENTIFIER$a) {
	                        value = this.Dimension();
	                    } else if (this.scanner.lookupNonWSType(1) === SOLIDUS$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case IDENTIFIER$a:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.scanner.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.scanner.eat(RIGHTPARENTHESIS$4);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$k = tokenizer.TYPE;

	var WHITESPACE$5 = TYPE$k.WhiteSpace;
	var COMMENT$5 = TYPE$k.Comment;
	var IDENTIFIER$b = TYPE$k.Identifier;
	var LEFTPARENTHESIS$4 = TYPE$k.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$5:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$5:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENTIFIER$b:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$4:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.scanner.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	// https://drafts.csswg.org/css-syntax-3/#the-anb-type
	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$6 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.scanner.consume(NUMBER$6)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$l = tokenizer.TYPE;
	var LEFTPARENTHESIS$5 = TYPE$l.LeftParenthesis;
	var RIGHTPARENTHESIS$5 = TYPE$l.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.scanner.eat(LEFTPARENTHESIS$5);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTPARENTHESIS$5);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var NUMBER$7 = TYPE$m.Number;
	var PERCENTSIGN = TYPE$m.PercentSign;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var number = this.scanner.consume(NUMBER$7);

	        this.scanner.eat(PERCENTSIGN);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: number
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$n = tokenizer.TYPE;

	var IDENTIFIER$c = TYPE$n.Identifier;
	var FUNCTION$2 = TYPE$n.Function;
	var COLON$3 = TYPE$n.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$n.RightParenthesis;

	// : ident [ '(' .. ')' ]?
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.scanner.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.scanner.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
	                );
	            }

	            this.scanner.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.scanner.consume(IDENTIFIER$c);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENTIFIER$d = TYPE$o.Identifier;
	var FUNCTION$3 = TYPE$o.Function;
	var COLON$4 = TYPE$o.Colon;
	var RIGHTPARENTHESIS$7 = TYPE$o.RightParenthesis;

	// :: ident [ '(' .. ')' ]?
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.scanner.eat(COLON$4);
	        this.scanner.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$3) {
	            name = this.scanner.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
	                );
	            }

	            this.scanner.eat(RIGHTPARENTHESIS$7);
	        } else {
	            name = this.scanner.consume(IDENTIFIER$d);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isNumber$4 = tokenizer.isNumber;
	var TYPE$p = tokenizer.TYPE;
	var NUMBER$8 = TYPE$p.Number;
	var SOLIDUS$4 = TYPE$p.Solidus;
	var FULLSTOP$3 = TYPE$p.FullStop;

	// Terms of <ratio> should to be a positive number (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without exponent part.
	// Additional checks may to be applied on lexer validation.
	function consumeNumber$1(scanner) {
	    var value = scanner.consumeNonWS(NUMBER$8);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isNumber$4(code) && code !== FULLSTOP$3) {
	            scanner.error('Unsigned number is expected', scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        scanner.error('Zero number is not allowed', scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$1(this.scanner);
	        var right;

	        this.scanner.eatNonWS(SOLIDUS$4);
	        right = consumeNumber$1(this.scanner);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, endTokenType1, endTokenType2, includeTokenType2, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(
	                startToken,
	                endTokenType1,
	                endTokenType2,
	                includeTokenType2
	            )
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = this.scanner.getOffsetExcludeWS();
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var LEFTCURLYBRACKET$5 = TYPE$q.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, LEFTCURLYBRACKET$5, 0, false, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$5) {
	        this.scanner.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.currentToken;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.scanner.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var COMMA$2 = TYPE$r.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$3 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.scanner.consume(STRING$3)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var WHITESPACE$6 = TYPE$s.WhiteSpace;
	var COMMENT$6 = TYPE$s.Comment;
	var EXCLAMATIONMARK$3 = TYPE$s.ExclamationMark;
	var ATKEYWORD$4 = TYPE$s.AtKeyword;
	var CDO$3 = TYPE$s.CDO;
	var CDC$3 = TYPE$s.CDC;

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, 0, 0, false, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$6:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$3: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$3: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // 2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$4:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$t = tokenizer.TYPE;

	var IDENTIFIER$e = TYPE$t.Identifier;
	var ASTERISK$4 = TYPE$t.Asterisk;
	var VERTICALLINE$2 = TYPE$t.VerticalLine;

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENTIFIER$e &&
	        this.scanner.tokenType !== ASTERISK$4) {
	        this.scanner.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.tokenType === VERTICALLINE$2) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.tokenType === VERTICALLINE$2) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHex$3 = tokenizer.isHex;
	var TYPE$u = tokenizer.TYPE;

	var IDENTIFIER$f = TYPE$u.Identifier;
	var NUMBER$9 = TYPE$u.Number;
	var PLUSSIGN$7 = TYPE$u.PlusSign;
	var HYPHENMINUS$6 = TYPE$u.HyphenMinus;
	var FULLSTOP$4 = TYPE$u.FullStop;
	var QUESTIONMARK$1 = TYPE$u.QuestionMark;

	function scanUnicodeNumber(scanner) {
	    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
	        var code = scanner.source.charCodeAt(pos);

	        // break on fullstop or hyperminus/plussign after exponent
	        if (code === FULLSTOP$4 || code === PLUSSIGN$7) {
	            // break token, exclude symbol
	            scanner.tokenStart = pos;
	            return false;
	        }
	    }

	    return true;
	}

	// https://drafts.csswg.org/css-syntax-3/#urange
	function scanUnicodeRange(scanner) {
	    var hexStart = scanner.tokenStart + 1; // skip +
	    var hexLength = 0;

	    scan: {
	        if (scanner.tokenType === NUMBER$9) {
	            if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP$4 && scanUnicodeNumber(scanner)) {
	                scanner.next();
	            } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS$6) {
	                break scan;
	            }
	        } else {
	            scanner.next(); // PLUSSIGN
	        }

	        if (scanner.tokenType === HYPHENMINUS$6) {
	            scanner.next();
	        }

	        if (scanner.tokenType === NUMBER$9) {
	            scanner.next();
	        }

	        if (scanner.tokenType === IDENTIFIER$f) {
	            scanner.next();
	        }

	        if (scanner.tokenStart === hexStart) {
	            scanner.error('Unexpected input', hexStart);
	        }
	    }

	    // validate for U+x{1,6} or U+x{1,6}-x{1,6}
	    // where x is [0-9a-fA-F]
	    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {
	        var code = scanner.source.charCodeAt(i);

	        if (isHex$3(code) === false && (code !== HYPHENMINUS$6 || wasHyphenMinus)) {
	            scanner.error('Unexpected input', i);
	        }

	        if (code === HYPHENMINUS$6) {
	            // hex sequence shouldn't be an empty
	            if (hexLength === 0) {
	                scanner.error('Unexpected input', i);
	            }

	            wasHyphenMinus = true;
	            hexLength = 0;
	        } else {
	            hexLength++;

	            // too long hex sequence
	            if (hexLength > 6) {
	                scanner.error('Too long hex sequence', i);
	            }
	        }

	    }

	    // check we have a non-zero sequence
	    if (hexLength === 0) {
	        scanner.error('Unexpected input', i - 1);
	    }

	    // U+abc???
	    if (!wasHyphenMinus) {
	        // consume as many U+003F QUESTION MARK (?) code points as possible
	        for (; hexLength < 6 && !scanner.eof; scanner.next()) {
	            if (scanner.tokenType !== QUESTIONMARK$1) {
	                break;
	            }

	            hexLength++;
	        }
	    }
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next(); // U or u
	        scanUnicodeRange(this.scanner);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$v = tokenizer.TYPE;

	var STRING$4 = TYPE$v.String;
	var URL$3 = TYPE$v.Url;
	var RAW$2 = TYPE$v.Raw;
	var RIGHTPARENTHESIS$8 = TYPE$v.RightParenthesis;

	// url '(' S* (string | raw) S* ')'
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        this.scanner.eat(URL$3);
	        this.scanner.skipSC();

	        switch (this.scanner.tokenType) {
	            case STRING$4:
	                value = this.String();
	                break;

	            case RAW$2:
	                value = this.Raw(this.scanner.currentToken, 0, RAW$2, true, false);
	                break;

	            default:
	                this.scanner.error('String or Raw is expected');
	        }

	        this.scanner.skipSC();
	        this.scanner.eat(RIGHTPARENTHESIS$8);

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$7 = tokenizer.TYPE.WhiteSpace;
	var SPACE$4 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.scanner.eat(WHITESPACE$7);
	        return SPACE$4;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.scanner.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$w = tokenizer.TYPE;

	var IDENTIFIER$g = TYPE$w.Identifier;
	var STRING$5 = TYPE$w.String;
	var NUMBER$a = TYPE$w.Number;
	var FUNCTION$4 = TYPE$w.Function;
	var URL$4 = TYPE$w.Url;
	var NUMBERSIGN$5 = TYPE$w.NumberSign;
	var LEFTPARENTHESIS$6 = TYPE$w.LeftParenthesis;
	var LEFTSQUAREBRACKET$4 = TYPE$w.LeftSquareBracket;
	var PLUSSIGN$8 = TYPE$w.PlusSign;
	var HYPHENMINUS$7 = TYPE$w.HyphenMinus;
	var COMMA$3 = TYPE$w.Comma;
	var SOLIDUS$5 = TYPE$w.Solidus;
	var ASTERISK$5 = TYPE$w.Asterisk;
	var PERCENTSIGN$1 = TYPE$w.PercentSign;
	var BACKSLASH = TYPE$w.Backslash;
	var U = 117; // 'u'.charCodeAt(0)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case NUMBERSIGN$5:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case SOLIDUS$5:
	        case ASTERISK$5:
	        case PLUSSIGN$8:
	        case HYPHENMINUS$7:
	            return this.Operator();

	        case LEFTPARENTHESIS$6:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$4:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$5:
	            return this.String();

	        case NUMBER$a:
	            switch (this.scanner.lookupType(1)) {
	                case PERCENTSIGN$1:
	                    return this.Percentage();

	                case IDENTIFIER$g:
	                    // edge case: number with folowing \0 and \9 hack shouldn't to be a Dimension
	                    if (cmpChar$2(this.scanner.source, this.scanner.tokenEnd, BACKSLASH)) {
	                        return this.Number();
	                    } else {
	                        return this.Dimension();
	                    }

	                default:
	                    return this.Number();
	            }

	        case FUNCTION$4:
	            return this.Function(this.readSequence, context.recognizer);

	        case URL$4:
	            return this.Url();

	        case IDENTIFIER$g:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$2(this.scanner.source, this.scanner.tokenStart, U) &&
	                cmpChar$2(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$8)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$x = tokenizer.TYPE;

	var IDENTIFIER$h = TYPE$x.Identifier;
	var NUMBER$b = TYPE$x.Number;
	var NUMBERSIGN$6 = TYPE$x.NumberSign;
	var LEFTSQUAREBRACKET$5 = TYPE$x.LeftSquareBracket;
	var PLUSSIGN$9 = TYPE$x.PlusSign;
	var SOLIDUS$6 = TYPE$x.Solidus;
	var ASTERISK$6 = TYPE$x.Asterisk;
	var FULLSTOP$5 = TYPE$x.FullStop;
	var COLON$5 = TYPE$x.Colon;
	var GREATERTHANSIGN$3 = TYPE$x.GreaterThanSign;
	var VERTICALLINE$3 = TYPE$x.VerticalLine;
	var TILDE$2 = TYPE$x.Tilde;

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case PLUSSIGN$9:
	        case GREATERTHANSIGN$3:
	        case TILDE$2:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Combinator();

	        case SOLIDUS$6:  // /deep/
	            return this.Combinator();

	        case FULLSTOP$5:
	            return this.ClassSelector();

	        case LEFTSQUAREBRACKET$5:
	            return this.AttributeSelector();

	        case NUMBERSIGN$6:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENTIFIER$h:
	        case ASTERISK$6:
	        case VERTICALLINE$3:
	            return this.TypeSelector();

	        case NUMBER$b:
	            return this.Percentage();
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression '(' raw ')'
	var expression$1 = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.currentToken, 0, 0, false, false)
	    );
	};

	var TYPE$y = tokenizer.TYPE;

	var IDENTIFIER$i = TYPE$y.Identifier;
	var COMMA$4 = TYPE$y.Comma;
	var SEMICOLON$5 = TYPE$y.Semicolon;
	var HYPHENMINUS$8 = TYPE$y.HyphenMinus;
	var EXCLAMATIONMARK$4 = TYPE$y.ExclamationMark;

	// var '(' ident (',' <value>? )? ')'
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    var identStart = this.scanner.tokenStart;

	    this.scanner.eat(HYPHENMINUS$8);
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS$8) {
	        this.scanner.error('HyphenMinus is expected');
	    }
	    this.scanner.eat(IDENTIFIER$i);

	    children.push({
	        type: 'Identifier',
	        loc: this.getLocation(identStart, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(identStart)
	    });

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$4, SEMICOLON$5, false, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression$1,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var STRING$6 = TYPE$z.String;
	var IDENTIFIER$j = TYPE$z.Identifier;
	var URL$5 = TYPE$z.Url;
	var LEFTPARENTHESIS$7 = TYPE$z.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$6:
	                    children.push(this.String());
	                    break;

	                case URL$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.scanner.error('String or url() is expected');
	            }

	            if (this.scanner.lookupNonWSType(0) === IDENTIFIER$j ||
	                this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS$7) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$A = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$A.WhiteSpace;
	var COMMENT$7 = TYPE$A.Comment;
	var IDENTIFIER$k = TYPE$A.Identifier;
	var FUNCTION$5 = TYPE$A.Function;
	var LEFTPARENTHESIS$8 = TYPE$A.LeftParenthesis;
	var HYPHENMINUS$9 = TYPE$A.HyphenMinus;
	var COLON$6 = TYPE$A.Colon;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.currentToken, 0, 0, false, false)
	    );
	}

	function parentheses() {
	    var index = 0;

	    this.scanner.skipSC();

	    // TODO: make it simplier
	    if (this.scanner.tokenType === IDENTIFIER$k) {
	        index = 1;
	    } else if (this.scanner.tokenType === HYPHENMINUS$9 &&
	               this.scanner.lookupType(1) === IDENTIFIER$k) {
	        index = 2;
	    }

	    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$8:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$7:
	                this.scanner.next();
	                continue;

	            case FUNCTION$5:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENTIFIER$k:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$8:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.scanner.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}

		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let href = node.value.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					node.value.value = url.toString();
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-bleed-top: 0;
	--pagedjs-bleed-right: 0;
	--pagedjs-bleed-bottom: 0;
	--pagedjs-bleed-left: 0;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}


.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

img {
	height: auto;
}

@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: var(--pagedjs-width);
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || 'get', url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials=='include';

			request.onload = () => {
	 			// Chrome returns a status code of 0 for local files
	 			const status = request.status === 0 && url.startsWith('file://') ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "mm"
			},
			height: {
				value: 14,
				unit: "mm"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "mm"
			},
			height: {
				value: 17,
				unit: "mm"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;

			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin : {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclartations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;


				if ((width && height) &&
						(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed);

					this.emit("size", { width, height, orientation, format, bleed });
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclartations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);
					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);
					} else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									default:
										// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;
		}

		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let {value, unit} = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					margins.push(node);
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages && !pages["*"].added) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
				pages["*"].added = true;
			}
			// Add :left & :right
			if (":left" in pages && !pages[":left"].added) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
				pages[":left"].added = true;
			}
			if (":right" in pages && !pages[":right"].added) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
				pages[":right"].added = true;
			}
			// Add :first & :blank
			if (":first" in pages && !pages[":first"].first) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
				pages[":first"].added = true;
			}
			if (":blank" in pages && !pages[":blank"].added) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
				pages[":blank"].added = true;
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth && !pages[pg].added) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
					pages[pg].added = true;
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name && !pages[pg].added) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
					pages[pg].added = true;
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};
			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());

			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}

			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);
				}
			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent$$1 = false;

				if(block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent$$1 = false;
							} else {
								hasContent$$1 = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
							 loc === "top-center" ||
							 loc === "top-right" ||
							 loc === "bottom-left" ||
							 loc === "bottom-center" ||
							 loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
							 loc === "left-middle" ||
							 loc === "left-bottom" ||
							 loc === "right-top" ||
							 loc === "right-middle" ||
							 loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent$$1
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if(content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(bleedTop, bleedRight, bleedBottom, bleedLeft, pageWidthVar, pageHeightVar);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			rules.push(wVar, hVar);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let dimensions = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});


			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if(centerWidth === "none" || centerWidth === "auto") {
						if(!leftContent && !rightContent){
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						}else if(leftContent){
							if(!rightContent){
								if(leftWidth !== "none" && leftWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								}else{
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							}else{
								if(leftWidth !== "none" && leftWidth !== "auto"){
									if(rightWidth !== "none" && rightWidth !== "auto"){
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									}else{
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								}else{
									if(rightWidth !== "none" && rightWidth !== "auto"){
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									}else{
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if(newcenterWidth > 40){
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										}else{
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						}else{
							if(rightWidth !== "none" && rightWidth !== "auto"){
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							}else{
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					}else if(centerWidth !== "none" && centerWidth !== "auto"){
						if(leftContent && leftWidth !== "none" && leftWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						}else if(rightContent && rightWidth !== "none" && rightWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						}else{
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				}else{
					if(leftContent){
						if(!rightContent){
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						}else{
							if(leftWidth !== "none" && leftWidth !== "auto"){
								if(rightWidth !== "none" && rightWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								}else{
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							}else{
								if(rightWidth !== "none" && rightWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								}else{
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth  + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					}else{
						if(rightWidth !== "none" && rightWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						}else{
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if(middleHeight === "none" || middleHeight === "auto") {
						if(!topContent && !bottomContent){
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						}else if(topContent){
							if(!bottomContent){
								if(topHeight !== "none" && topHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							}else{
								if(topHeight !== "none" && topHeight !== "auto"){
									if(bottomHeight !== "none" && bottomHeight !== "auto"){
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									}else{
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								}else{
									if(bottomHeight !== "none" && bottomHeight !== "auto"){
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						}else{
							if(bottomHeight !== "none" && bottomHeight !== "auto"){
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					}else{
						if(topContent && topHeight !== "none" && topHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = topHeight +" " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						}else if(bottomContent && bottomHeight !== "none" && bottomHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						}else{
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				}else{
					if(topContent){
						if(!bottomContent){
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						}else{
							if(topHeight !== "none" && topHeight !== "auto"){
								if(bottomHeight !== "none" && bottomHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								}else{
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							}else{
								if(bottomHeight !== "none" && bottomHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								}else{
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					}else{
						if(bottomHeight !== "none" && bottomHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						}else{
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator="+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child$$1 = declaration.value.children.first();
				let value = child$$1.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter$$1 = elementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter$$1) {
								nodeAfter$$1.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter$$1 = elementAfter(elements[i], parsed);

							if (nodeAfter$$1) {
								nodeAfter$$1.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			splits.forEach((split) => {
				let ref = split.dataset.ref;
				let from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}

					this.handleAlignment(from);
				}
			});
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			if (align === "justify" && alignLast === "auto") {
				node.style["text-align-last"] = "justify";
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number: number || 1
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				this.addCounterValues(parsed, counter);
			}
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (var i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
				}
			}
		}

		addCounterValues(parsed, counter) {
			let counterName = counter.name;
			let elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;

			for (var i = 0; i < elements.length; i++) {
				element = elements[i];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					count = parseInt(reset);
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");

					this.styleSheet.insertRule(`[data-ref="${element.dataset.ref}"] { counter-reset: ${counterName} ${count} }`, this.styleSheet.cssRules.length);
					this.styleSheet.insertRule(`[data-ref="${element.dataset.ref}"] { counter-increment: ${counterName} ${increment}}`, this.styleSheet.cssRules.length);

					count += parseInt(increment);

					element.setAttribute("data-counter-"+counterName+"-value", count);
				}

			}
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				let value = reset.datasetCounterPageReset;
				this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-reset: page ${value} }`, this.styleSheet.cssRules.length);
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
				list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + 1);
			}
		}

	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier: identifier,
					value: value,
					selector: selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

				funcNode.children.append(funcNode.children.createItem({
					type: "Identifier",
					loc: null,
					name: "--pagedjs-string-" + identifier
				}));
			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.stringSetSelectors)) {
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					let cssVar;
					if (set.value === "content" || set.value === "content()" || set.value === "content(text)") {
						cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --pagedjs-string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--pagedjs-string-${name}`, `"${cssVar}"`);
						set.first = cssVar;
						fragment.style.setProperty(`--pagedjs-string-${name}`, `"${set.first}"`);
					} else {
						console.warn(set.value + "needs css replacement");
					}
				} else {
					// Use the previous values
					if (set.first) {
						fragment.style.setProperty(`--pagedjs-string-${name}`, `"${set.first}"`);
					}
				}
			}
		}
	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (var i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								pg += 1;

								if (pages[i].contains( element )){
									break;
								}
							}

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${psuedo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${psuedo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				selector.split(",").forEach((s) => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach((name) => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						if (target.style === "content") {
							let selector = UUID();
							selected.setAttribute("data-target-text", selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}

							let textContent = element.textContent.trim().replace(/["']/g, (match) => {
								return "\\" + match;
							}).replace(/[\n]/g, (match) => {
								return "\\00000A";
							});

							// this.styleSheet.insertRule(`[data-target-text="${selector}"]${psuedo} { content: "${element.textContent}" }`, this.styleSheet.cssRules.length);
							this.styleSheet.insertRule(`[data-target-text="${selector}"]${psuedo} { ${target.variable}: "${textContent}" }`, this.styleSheet.cssRules.length);

						}
					} else {
						console.warn("missed target", val);
					}
				});

			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		if (typeof Symbol !== 'function') return false;
		try { } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor() {
			// this.preview = this.getParams("preview") !== "false";

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker();

			// Hooks
			this.hooks = {};

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			let counter = 0;
			this.chunker.on("page", (page) => {
				counter += 1;
				this.emit("page", page);
				if (typeof window.PuppeteerLogger !== "undefined") {
					window.PuppeteerLogger("page", counter);
				}
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();
			let msg = "Rendering " + flow.total + " pages took " + (endTime - startTime) + " milliseconds.";

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", msg, this.size.width && this.size.width.value + this.size.width.unit, this.size.height && this.size.height.value + this.size.height.unit, this.size.orientation, this.size.format);
			if (typeof window.onPagesRendered !== "undefined") {
				window.onPagesRendered(msg, this.size.width && this.size.width.value + this.size.width.unit, this.size.height && this.size.height.value + this.size.height.unit, this.size.orientation, this.size.format);
			}

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);



	var Paged = /*#__PURE__*/Object.freeze({
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined
	};

	let previewer = new Previewer(config.content, config.stylesheets, config.renderTo);


	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview();
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

}));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      const abbreviations = content.querySelectorAll('abbr');
      if(abbreviations.length === 0) return;
      const loaTitle = 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });
}
</script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<style type="text/css">@page {
size: 8.5in 11in; 
}
@page :blank {
}
.pagedjs_page {
--pagedjs-pagebox-width: 8.5in;
--pagedjs-pagebox-height: 11in;
}
.level1 {
break-before: avoid;
}
.red {
color: red;
}
.yourturn {
color: blue;
font-size: 2em;
}
.pagebreak {
break-after: always;
}</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Chapter 5: Assessing Model Accuracy</h1>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p>One of the key aims of this course is to introduce you to a wide range of statistical learning techniques. Why so many? Why not just the best one?</p>
<p><br /><br /><br /><br /></p>
<p>Hence, its important to decide for any given set of data which method produces the best results.</p>
<p><br /><br /></p>
<p><img src="data:image/png;base64,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" /></p>
<p><a href="https://xkcd.com/1838/" class="uri">https://xkcd.com/1838/</a></p>
<div id="measuring-quality-of-fit" class="section level1">
<h1><span class="header-section-number">1</span> Measuring Quality of Fit</h1>
<p>With linear regression we talked about some ways to measure fit of the model</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>In general, we need a way to measure fit and compare <em>across models</em>.</p>
<p><br /></p>
<p>One way could be to measure how well its predictions match the observed data. In a regression session, the most commonly used measure is the <em>mean-squared error (MSE)</em></p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>We dont really care how well our methods work on the training data.</p>
<p><br /></p>
<p>Instead, we are interested in the accuracy of the predictions that we obtain when we apply our method to previously unseen data. Why?</p>
<div class="page-break-after"></div>
<p>So how do we select a method that minimizes the test MSE?</p>
<p><br /><br /></p>
<p>But what if we dont have a test set available?</p>
<p><br /><br /><br /><br /></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAJACAYAAABMocy1AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAABUCgAwAEAAAAAQAAAkAAAAAAzKugZgAAQABJREFUeAHs3QmczdX/x/H3nc2+lERakKRkK2vJFuFvKSKkQqRFP0UrUqRCG8mvlPplj3ZCJLLvW4iSaBHJkuzLzL33f873unf2MWPmjpk7r9Nj3O893/M93+95fr/NnfnMWVxek0RCAAEEEEAAAQQQQAABBBBAAAEEEEAAAQRCUCAsBNtEkxBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAUeAACgPAgIIIIAAAggggAACCCCAAAIIIIAAAgiErAAB0JC9tTQMAQQQQAABBBBAAAEEEEAAAQQQQAABBAiA8gwggAACCCCAAAIIIIAAAggggAACCCCAQMgKEAAN2VtLwxBAAAEEEEAAAQQQQAABBBBAAAEEEECAACjPAAIIIIAAAggggAACCCCAAAIIIIAAAgiErAAB0JC9tTQMAQQQQAABBBBAAAEEEEAAAQQQQAABBAiA8gwggAACCCCAAAIIIIAAAggggAACCCCAQMgKEAAN2VtLwxBAAAEEEEAAAQQQQAABBBBAAAEEEECAACjPAAIIIIAAAggggAACCCCAAAIIIIAAAgiErAAB0JC9tTQMAQQQQAABBBBAAAEEEEAAAQQQQAABBAiA8gwggAACCCCAAAIIIIAAAggggAACCCCAQMgKEAAN2VtLwxBAAAEEEEAAAQQQQAABBBBAAAEEEEAgAoLgCqxcuVI7d+4M2kk8Hk+gbpfLJftFQiBYAl6vV/aLZy1YwtTrF/A/a/73YWH8vc5vwWtwBPyfpzxrwfGl1lgB/7Nmc/g8jXVhKzgC/s9TnrXg+FJrrID/WbM5PG+xLmwFT8B+nvKsBc83q9ZcrVo1lSpV6pwujwDoObGl/qApU6bo66+/Tv0BlEQAAQQQQAABBBBAAAEEEEAAAQQQQACBeAIvv/wyAdB4IlnszfXXX69x48YF5aoOHjyokydPOnVfdNFFioyMDMp5qBQBK3D69GkdOHBAPGs8D8EW8D9r9jx58uRR4cKFg31K6s/hAvv27XM+Q3nWcviDkAnNt89aTEyMc6bixYs7vVcy4bScIocKHD9+XIcOHVKxYsVED/cc+hBkUrP9z5o9XYECBZQ/f/5MOjOnyakCe/bscZ4znrWc8QTYuFeNGjXS1Vh6gKaLL3UH2x82cuXKlbrCaSxl67XDDWyy2wRA0whI8TQJ2CEG9jnjWUsTG4XPQcD/rNlD/c/cOVTDIQikWsD/fc2+khAIpoB9xsLDw51T2G37/Y6EQLAE3G534HOUAGiwlKnXCvifNbttv7fxeWolSMEU8D9nPGvBVA6tuplULbTuJ61BAAEEEEAAAQQQQAABBBBAAAEEEEAAgTgCBEDjYLCJAAIIIIAAAggggAACCCCAAAIIIIAAAqElQAA0tO4nrUEAAQQQQAABBBBAAAEEEEAAAQQQQACBOAIEQONgsIkAAggggAACCCCAAAIIIIAAAggggAACoSVAADS07ietQQABBBBAAAEEEEAAAQQQQAABBBBAAIE4AgRA42CwiQACCCCAAAIIIIAAAggggAACCCCAAAKhJUAANLTuJ61BAAEEEEAAAQQQQAABBBBAAAEEEEAAgTgCBEDjYLCJAAIIIIAAAggggAACCCCAAAIIIIAAAqElQAA0tO4nrUEAAQQQQAABBBBAAAEEEEAAAQQQQACBOAIEQONgsIkAAggggAACCCCAAAIIIIAAAggggAACoSVAADS07ietQQABBBBAAAEEEEAAAQQQQAABBBBAAIE4AgRA42CwiQACCCCAAAIIIIAAAggggAACCCCAAAKhJRARWs2hNVlF4LffftP777+vJUuW6N9//1WJEiXUpEkTdevWTQUKFMgql8l1IIAAAggggAACCCCAAAIIIIAAAgiEuAAB0BC/weejeSNGjNBTTz2l6OjowOk3btyo2bNna8iQIfr4449Vv379wD42EEAAAQQQQAABBBBAAAEEEEAAAQQQCJZAyAVA9+/fr48++kjbtm3TiRMndN111+n6669PMeB26tQpffbZZ1qzZo0OHjyosmXLqkqVKmratKnC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CICm3irHl2zVqpVee+21FB3KlSunqVOnKjzc17MzxcJmZ987B6hQ3kJOsTV/rNSzw/rKzhFq0/jx49W7d29nm38QQAABBBBAAAEEEEAAAQQQQAABBBA4FwECoOeiloOPefLJJ7VgwQLVr19ftleoPxUtWlR9+/bV6tWrddlll/mzz/papEAR9bnz+UC5Wb9N06h3RwXejxgxQi+88ELgPRsIIIAAAggggAACCCCAAAIIIIAAAgikRYAAaFq0KOsI1KtXT3aezoMHD+qHH37Qr7/+qj179mjw4MEqUKBAmpUebPKIrixexjlu028blLtMhF599dVAPQMHDtTIkSMD79lAAAEEEEAAAQQQQAABBBBAAAEEEEAgtQIEQFMrRblEAoUKFdJ1112nUqVKBYatJyqUioyoyCi9dE9swPOFyf318H8eVp8+fQJHP/bYY5o4cWLgPRsIIIAAAggggAACCCCAAAIIIIAAAgikRoAAaGqUKBN0gdtqttbN5es65/n73z0aNu0VDRkyRA8++KCTZxdDuu+++zR9+vSgXwsnQAABBBBAAAEEEEAAAQQQQAABBBAIHQECoKFzL7N9S4Z2HhZow1vT39CuA3/qnXfeUfv27Z38mJgYtWvXTgsXLgyUYwMBBBBAAAEEEEAAAQQQQAABBBBAAIGUBAiApqTDvkwVqHLlDepYr5NzzpOnT2rAJN+K8BMmTFDTpk19+SdP6rbbbtPatWsz9do4GQIIIIAAAggggAACCCCAAAIIIIBA9hQgAJo971vIXvXAu15Wnqg8TvumLJ6ktb+sVmRkpD7//HPVrl3byT98+LATEP3pp59C1oGGIYAAAggggAACCCCAAAIIIIAAAghkjAAB0IxxpJYMEihR5FL1vv3pQG19xj3ubOfNm1czZsxQ5cqVnff79+9X48aN9ccffwTKpmXjyJEj2rFjh2wwlYQAAggggAACCCCAAAIIIIAAAgggELoCBEBD995m25b1uv0pXXJhCef6l/+0VF8u/8zZLly4sL755htdddVVzvudO3fq1ltv1d69e1Pd1o8//lg1atRQwYIFVaZMGdmV7KtWraqPPvoo1XVQEAEEEEAAAQQQQAABBBBAAAEEEEAg+wgQAM0+9yrHXGneXHllh8L703MTn9Hp6NPO22LFiunbb7/VpZde6rz/+eefneHwhw4d8hdP8tXj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OTUnT648alSlidP8YyePaf6muUlSBHqD3nNX7P5138td82a5H39K3nPsudmlSxdNnTpVeewNNmn16tWqXbu2fv/999jzsIUAAggggAACCCCAAAIIIIAAAgggEFQBAqBB5T23yqOipO7dpYkTJbtgkp0+0i6Q1LmzVKpU4jpPnHBp3Lh8JmAa4fQgzZ1bevBBmVW9pV27EpfPSTlxh8FPTzAMPq6D0xt0whiFfW3mKShV0rfL7ZF3+Ei5y1eRZ/rMuMVTvd28eXPNnTvXTGNg5jEw6eeff9ZNN92kTZs2pboOCiKAAAIIIIAAAggggAACCCCAAAIInLsAAdBzt8u0I+0o6vvuk8aOlX79VfJ4pPHjJbtoUunSiZeZP3VKituD1AZUbVl7TE7rfNikanOFhfke81lrphs7g5dCCvu/Jr65QZ80cwxEhPtK7vxTntvayN22g7y7d6dwdNK7bMBz8eLFpjevrzvvblNH3bp1nbykjyAXAQQQQAABBBBAAAEEEEAAAQQQQCCjBAiAZpRkJtZj1tnRvfdKH3wgrV17WLt3/2XmA92v++9369prE19Iwh6kZoF0pzep7VW6fbsvoJr4qNDIKVKgiGpfU8dpzL7D+7Ri67KzNsyVN6/CXxuq8NWmbPWqgfLez6fKfW1led55V96zBFIDB53ZKF++vJYtW2buj+8G/WtWw2rcuLFZGMv0OCUhgAACCCCAAAIIIIAAAggggAACCARNgABo0Ggzt+KaNaP1zjsebdkieb3SypXSf/4jVayY+Dri9iC96irJBkQ7dpTee0/66afE5bN7TosarQJNmLE69QFHV5XKCl+xWGEj3pAKmJWrbDp8RJ5Hesldu768m37w5aXy38svv1xLlixRrVq1nCNOnjypNm3amEC2iWRngfTLX9s0cf5YHT3BavVZ4HZwCQgggAACCCCAAAIIIIAAAgggkEECBEAzCDKrVVOjhjRypLRxoy8gun69b+X4669P+konT5YeekhOD1Lbw/TGG30r0/+Qthhf0pWf59yW8QKgU9N0NS4zfD7s0UcUvuV7uW5vEXvsilVy31BT7r795T1xIjb/LFt2LtB58+apWbNmTkm3223me+2uF1544SxHBnf3B3PeVc0nKumhd7rq4VFdg3syakcAAQQQQAABBBBAAAEEEEAAAQQyUYAAaCZin89TVakiDR8u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Ua2+l0GAAAECBAgQIECAAAECBAgQIECAQPULdOsxQI888si0zz77pEWLFqVZs2al7373u401NnPmzDzW4bBhw9LYsWMb8zvyIcZ6uu+++zqy6Ra3+eSTT9L69evzejHWSs+ePbe4jRUIdFQgxixbu3ZtHtfHtdZRRdttjUBxrcW6MRHdjjvuuDWbWYdAhwViOJy4r7nWOkxow60UiGttw4YNee2BAwcaA3Qr3azWMYEYUzvGZhwwYIAxQDtGaKutFCiutVi9b9+++WcrN7UagQ4JxPjG22+/vWutQ3q1t1HcY7Y1desAaAw6f+6556Yrr7wyTZs2LcVkRiNGjEgNDQ35c0yGcPHFF29zw/S9995LV1xxxbbWle0JECBAgAABAgQIECBAgAABAgQIEChRoMemr1KJ29TM6rNnz06XX355Ouyww9L06dPbLff8+fNzADRmEStS9AyNGdxHjx5dZHXodzzhj9fpOytddNFF6Yknnsi7f+CBB9L+++/fWYeyXwIECHSZQNyXzz777Hy8k046KU2dOrXLju1ABAgQ6EyBU089Nb3++uv5EM8//7yeK52Jbd8ECHSZwMMPP9zY6eeCCy5I55xzTpcd24EIEOg+Ar169epwJ8W67gE6bty4NGfOnC1eCREgvf/++/Mr74sXL04xOdLQoUPL8ppIvE7Xma8KR/w6XhWNtN1226XotSoRIECg1gXiflbc2+I+595W6zWq/AQIFALxcLy4v0Uj3v2tkPGbAIFaFoi3K4t7W5yHe1st16ayE6hPgboOgJZaZbvuumuKH4kAAQIECBAgQIAAAQIECBAgQIAAgfoQ6NazwNdHFToLAgQIECBAgAABAgQIECBAgAABAgTaExAAbU9GPgECBAgQIECAAAECBAgQIECAAAECNS8gAFrzVegECBAgQIAAAQIECBAgQIAAAQIECBBoT0AAtD0Z+QQIECBAgAABAgQIECBAgAABAgQI1LxAj69m191U82fRjU/glVdeSUuXLs0CxxxzTOrfv3831nDqBAjUi8CKFSvSvHnz8unstdde6Rvf+Ea9nJrzIECgmws899xzafXq1Vlh0qRJqWfPnt1cxOkTIFAPAkuWLEkNDQ35VA444IA0fPjwejgt50CAQB0JCIDWUWU6FQIECBAgQIAAAQIECBAgQIAAAQIEmgt4Bb65hyUCBAgQIECAAAECBAgQIECAAAECBOpIQAC0jirTqRAgQIAAAQIECBAgQIAAAQIECBAg0FxAALS5hyUCBAgQIECAAAECBAgQIECAAAECBOpIQAC0jirTqRAgQIAAAQIECBAgQIAAAQIECBAg0FygV/NFS7Ui8MUXX6QHHnggvfjiiylmSx4xYkQaNWpUmjx5stlEa6USlZNANxb4+OOP03333Zfeeuut9OGHH6YhQ4akfffdN/3gBz9Iu+22WyuZTz/9NP3+979vld8044QTTkj7779/0yyfCRAg0KUCTz/9dFqwYEG7xxw8eHA67bTTWn3/xhtvpPvvvz+9++67qV+/fumQQw5JEyZMMItyKykZBAh0pcCrr76aHn/88a065FFHHZWOPPLIxnW13RopfCBAoEoEBECrpCJKKcbKlSvT+eefnxYvXpw322WXXdJjjz2Wf5577rk0derU1KdPn1J2aV0CBAh0mcAzzzyTpk2blj777LP8wGbXXXdNL730UnrhhRfSQw89lC655JI0ceLEZuV5880380OfZpktFuIhkABoCxSLBAh0qcCDDz6Y72ftHXT48OGtAqDxQPvmm2/Om/Tv3z+tW7cuvfzyy/kh0a9+9as0evTo9nYnnwABAp0q8M4776S//vWvW3WMaM81DYBqu20Vm5UIEOhCAQHQLsQu16GuueaaHPwcO3ZsuuKKK9LAgQPTkiVL0uWXX55mz56dpk+fnn7xi1+U63D2Q4AAgbIJxL2qCH6effbZORCw/fbbp+jVfuedd+af+Af/AQcckPbee+/G4y5atCh/HjNmTO4V1fhFkw/RE14iQIBAJQWKe9UFF1yQ4t7WMu20007NshoaGnK7LR5cxwPsb33rW+nLL79Mf/vb3xrbc3fffXcaOnRos+0sECBAoCsERo4cmS666KJ2DxU93v/xj3+kHXfcMR177LHN1ivuh9puzVgsECBQQQEB0Arid+TQCxcuzL2kdthhh3Tttdemvn375t3sueee6cYbb0wnn3xymjVrVjrvvPNSy0Z2R45nGwIECJRT4OGHH849P4877rh0zjnnNO46AgXnnntueu+991L0EI31oqd7kYpGdLwSeuKJJxbZfhMgQKBqBJYtW5ZWr16dohfUKaecslXluuOOO9KmTZvS6aefnsaNG5e36d27d97+gw8+yD3fIxj64x//eKv2ZyUCBAiUU+D//u//Uvy0lWI4oz/84Q/5q+iUM2zYsGarabs147BAgEAVCJgEqQoqoZQiRGAg0vjx4xuDnznjq//Eq/BHHHFEfnUqgqASAQIEqk1g/vz5uUjRy6mtFD3bI8VrU01Tsfz1r3+9abbPBAgQqBqB4h/7W3ufivHxYuiPSN/5zndanUeR98gjj+Reoa1WkEGAAIEKCsRbicuXL08nnXRSOuaYY1qVRNutFYkMAgQqLCAAWuEKKPXwr732Wt6kCBK03D4CoJE2NwB/y20sEyBAoKsEYoiOe++9t9kYUU2PHQ3pSIMGDWrMjtdB33777dSrV6/GCUGil1W8Ni8RIECgWgRaBkDj3lXc09oq4+uvv557f8ZwH3vssUerVQ488MD8Ns+qVaty7/hWK8ggQIBAhQSeeOKJPN5xdMD50Y9+1KoU2m6tSGQQIFAFAl6Br4JKKKUIMX5epKbBgabbF/nFBElNv/OZAAEClRaIV93b+od+lCsay0Xv9YMPPrixqDEr8vr16/MrWDEWXgzGH69dbbfddjnvjDPOSMcff3zj+j4QIECgEgJFADTuZVOmTEnR433Dhg05iHn44YenGBc0Xo8v0pbadLFetOvWrFmTx36PCZQkAgQIVFogJrG89dZbczFiuKKYvK1l0nZrKWKZAIFqENADtBpqoYQyfPLJJ3ntItDZctMBAwbkrGK9lt9bJkCAQLUK/Pa3v03vv/9+ijGNTzjhhMZiFkGFGB/0tttuSz169EgxoP7OO++c3vlqdtJ4BSsmTpIIECBQSYHidc8//elPOfgZPTjjdfjPP/88PfXUU+nMM89sNrxH0VZrr00X56JdV8kadWwCBNoSiN6f8SA6HuhMnDixrVWStlubLDIJEKiwgB6gFa6AUg6/cePG3IiObdqb4Kh4AufV0FJkrUuAQKUF7rnnnhQ/0avzsssuazbGcRFUiPtezCA/atSoXNyYOCR6g/76179Ojz76aH6tvuUMpJU+L8cnQKB7CEQwMyYtihRjd/785z9PMWFlpMi/6qqrUkxkGfew3/3ud3lIjxgDNFJ7bbr4rmjXRRBVIkCAQDUIPPTQQ7kY3/ve9/K9rK0yabu1pSKPAIFKCwiAVroGSjh+BAaiMR2vHbQX4Czy+/TpU8KerUqAAIHKCUQwIHpMxT3ul7/8ZRo5cmSzwpx11lm5h8HAgQObvT4fPUFPPvnk3As0AqF33XVXEgBtRmeBAIEuEoj2WQzR8dFHH+WHNHF/KlIM+3H11Ven0047LfeKiomPjjrqqNSvX7+8yrp164pVW/0u2nUxfIhEgACBSgtEz87//Oc/qWfPnunEE09stzjabu3S+IIAgQoKeAW+gvgdOfTgwYPzZjEeVFupyC8a1W2tI48AAQLVIBDjesbr6xH8jIc2ESCYNGlSq6JF76iDDjqoWfCz6UrHHXdcXvzvf/+boqe8RIAAga4WiAc4MZnRYYcdlofpaHn8r33ta+mQQw7J2TGpW6SiTReTurWXtOvak5FPgEAlBB5++OF82PHjxzcb07hlWbTdWopYJkCgGgQEQKuhFkooQ9FYLhrELTctGtExNp5EgACBahWIe1i8Ivr444/nMe7iNfZoTHckRWAhUvSiKsbU68h+bEOAAIHOFBgyZEjefYydF2lLbbpYR7suFCQCBKpBIIbiiHZbpHgDZ1uSttu26NmWAIGOCngFvqNyFdquaDxH74EjjzyyVSmKXgXRW0oiQIBANQrEP+hjNuS33nor7bXXXun666/PPafaK+v999+fB9ufPHly2meffVqt9uGHH+a8mCxkc2PptdpQBgECBMokEK+EPv/882nHHXdMp5xySpt7XbZsWc6P+16kok23ePHiFD3ie/funfOL/6xatSotX748Dw8yYsSIIttvAgQIVEQgXarQRQAAC81JREFUhu+IB8277757OvTQQzdbBm23zfL4kgCBCgnoAVoh+I4etphp78knn2y1i3j1M2YZjVRMEtJqJRkECBCooEBMXHTppZfm4GfMjvyb3/xms8HPKGrc72bOnJnuuOOONkv+r3/9K+cffPDBbX4vkwABAp0tsGLFinTbbbelW265Jb377rutDheBzNdeey3nF/eqGBs0Zopfu3ZtmjdvXqttnn766bRhw4a8TgRWJQIECFRS4NVXX82H35oHMtpulawpxyZAoD0BAdD2ZKo0P3p9Rg+oGIB61qxZzUoZAYJ4rWrYsGFp7Nixzb6zQIAAgWoQiLGjGhoa8qufN9xwQ4qJjbaUvv3tb+dV4gFP9Bptml566aUUvQwi/fCHP2z6lc8ECBDoMoF48Dxo0KAUD3luv/329OWXXzYeO14bve666/IklkcffXQOaBZfnnrqqfnjjBkzUtPhjaK36J///Of8XXs9Sot9+E2AAIGuEFi4cGE+zL777rvFw2m7bZHICgQIVECgx1cNtU0VOK5DboPA7Nmz05VXXpl7BcQfl3gKFwGFuXPn5tenYiy9lrMob8PhbEqAAIGyCMRsxieddFLjP/JjBtH20v777597U8X30QNqypQpaf78+Xn1MWPGpPh58803U/SQivSTn/wkFYGEnOE/BAgQ6GKBF198MV144YU5CBpjsR9//PF5puRot73//vspggbx4KcY+y6KF/e3uH+9/vrreaK3aNdF8DR6T8VD7QiYTps2Lb8G38Wn43AECBBoJhBtuI8++ihdddVVacKECc2+a7mg7dZSxDIBAtUgIABaDbXQgTJEICAaxEuXLm3cOnqGRpBg9OjRjXk+ECBAoFoE3njjjXTuueduVXH222+/3IuqWDl6UEUv97vvvjtPdlTkx6zLMZ5oW2MiF+v4TYAAga4SiNfcb7755hzQLI65ww47pHHjxuXgaFuvssfDoZtuuilPLhJjgUaKB0QRbDjvvPNS3759i135TYAAgYoIxFBrEfSMwOadd96ZH+hsqSDablsS8j0BAl0tIADa1eJlPl70DojB82Mg/aFDh+ohUGZfuyNAoLoEomfUBx98kFauXJmGDx+e+vfvX10FVBoCBAh8JRATGEX7LCZmiwc122235VGn4v4Ww3zEy1mxTb9+/VgSIECg5gW03Wq+Cp0AgboREACtm6p0IgQIECBAgAABAgQIECBAgAABAgQItBTY8uPolltYJkCAAAECBAgQIECAAAECBAgQIECAQI0ICIDWSEUpJgECBAgQIECAAAECBAgQIECAAAECpQsIgJZuZgsCBAgQIECAAAECBAgQIECAAAECBGpEQAC0RipKMQkQIECAAAECBAgQIECAAAECBAgQKF1AALR0M1sQIECAAAECBAgQIECAAAECBAgQIFAjAgKgNVJRikmAAAECBAgQIECAAAECBAgQIECAQOkCAqClm9mCAAECBAgQIECAAAECBAgQIECAAIEaERAArZGKUkwCBAgQIECAAAECBAgQIECAAAECBEoXEAAt3cwWBAgQIECAAAECBAgQIECAAAECBAjUiIAAaI1UlGISIECAAAECBAgQIECAAAECBAgQIFC6gABo6Wa2IECAAAECBAgQIECAAAECBAgQIECgRgQEQGukohSTAAECBAgQIECAAAECBAgQIECAAIHSBQRASzezBQECBAgQIECAAAECBAgQIECAAAECNSIgAFojFaWYBAgQIECAAAECBAgQIECAAAECBAiULiAAWrqZLQgQIECAAAECBAgQIECAAAECBAgQqBEBAdAaqSjFJECAAAECBAgQIECAAAECBAgQIECgdIFepW9iCwIECBAgQIAAAQK1J7Bw4cK0du3aXPB99tknDRkypM2TeOedd9KyZcvyd3vvvXfafffd21xPJgECBAgQIECAQG0ICIDWRj0pJQECBAgQIECAwDYKvPjii+mss87Kexk9enSaN29e6tWreXN4yZIlacyYMWn58uVp8ODB6ZVXXtnGo9qcAAECBAgQIECg0gJega90DTg+AQIECBAgQIBAlwiceeaZ6ZRTTsnHevnll9MNN9zQ7LgbN25MsU4EPyPNmDEj7bnnns3WsUCAAAECBAgQIFB7Aj02fZVqr9hKTIAAAQIECBAgQKB0gRUrVqRDDjkkRU/P7bffPvfwPPDAA/OOrr/++nTJJZfkzz/72c/STTfdVPoBbEGAAAECBAgQIFB1AgKgVVclCkSAAAECBAgQINCZAv/85z/TpEmTUvQDOProo9OcOXNyIHTs2LFp/fr1KV6Pnzt3burTp09nFsO+CRAgQIAAAQIEukjAK/BdBO0wBAgQIECAAAEC1SEwceLENGXKlFyYZ599Nt1yyy3p9NNPz8HPnXbaKd17772Cn9VRVUpBgAABAgQIECiLgB6gZWG0EwIECBAgQIAAgVoS+OKLL9Lhhx+eGhoamhX7rrvuSqeddlqzPAsECBAgQIAAAQK1LaAHaG3Xn9ITIECAAAECBAh0QCDG/5w5c2YeB7TYPGaIF/wsNPwmQIAAAQIECNSPgABo/dSlMyFAgAABAgQIEChBYLfddkv9+/dv3GLNmjWNn30gQIAAAQIECBCoHwEB0PqpS2dCgAABAgQIECBQgsA555yTPv7448Yt/vKXv6Q//vGPjcs+ECBAgAABAgQI1IeAAGh91KOzIECAAAECBAgQKEHg1ltvTbNmzcpbXHbZZWnkyJH5809/+tP09ttvl7AnqxIgQIAAAQIECFS7gEmQqr2GlI8AAQIECBAgQKCsAm+88UYaPXp0+uyzz9KoUaPSCy+8kBYsWJDGjh2bNmzYkL75zW+mOXPmpJ49e5b1uHZGgAABAgQIECBQGQE9QCvj7qgECBAgQIAAAQIVEFi/fn2e6CiCn717904zZszIv8eMGZMuvvjiXKK5c+emadOmVaB0DkmAAAECBAgQINAZAgKgnaFqnwQIECBAgAABAlUpcOWVV6aXX345ly1efY8eoEWaOnVqOuigg/Li1VdfnXuGFt/5TYAAAQIECBAgULsCXoGv3bpTcgIECBAgQIAAgRIE4rX2Y489Nm3cuDEdeuih6d///nfu/dl0F/PmzUtHHXVUXmfEiBFp/vz5qV+/fk1X8ZkAAQIECBAgQKDGBPQArbEKU1wCBAgQIECAAIHSBVavXp3OOOOMHNiMV99vv/32VsHP2GuMA3rhhRfmAyxatKjxc+lHtAUBAgQIECBAgEC1COgBWi01oRwECBAgQIAAAQIECBAgQIAAAQIECJRdQA/QspPaIQECBAgQIECAAAECBAgQIECAAAEC1SIgAFotNaEcBAgQIECAAAECBAgQIECAAAECBAiUXUAAtOykdkiAAAECBAgQIECAAAECBAgQIECAQLUICIBWS00oBwECBAgQIECAAAECBAgQIECAAAECZRcQAC07qR0SIECAAAECBAgQIECAAAECBAgQIFAtAgKg1VITykGAAAECBAgQIECAAAECBAgQIECAQNkFBEDLTmqHBAgQIECAAAECBAgQIECAAAECBAhUi4AAaLXUhHIQIECAAAECBAgQIECAAAECBAgQIFB2AQHQspPaIQECBAgQIECAAAECBAgQIECAAAEC1SIgAFotNaEcBAgQIECAAAECBAgQIECAAAECBAiUXUAAtOykdkiAAAECBAgQIECAAAECBAgQIECAQLUICIBWS00oBwECBAgQIECAAAECBAgQIECAAAECZRcQAC07qR0SIECAAAECBAgQIECAAAECBAgQIFAtAgKg1VITykGAAAECBAgQIECAAAECBAgQIECAQNkFBEDLTmqHBAgQIECAAAECBAgQIECAAAECBAhUi4AAaLXUhHIQIECAAAECBAgQIECAAAECBAgQIFB2AQHQspPaIQECBAgQIECAAAECBAgQIECAAAEC1SIgAFotNaEcBAgQIECAAAECBAgQIECAAAECBAiUXUAAtOykdkiAAAECBAgQIECAAAECBAgQIECAQLUI/D/ZBS3/+uKQbQAAAABJRU5ErkJggg==" width="672" /></p>
<table>
<thead>
<tr class="header">
<th align="left">model</th>
<th align="right">df</th>
<th align="right">Test MSE</th>
<th align="right">Train MSE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Linear Regression</td>
<td align="right">2</td>
<td align="right">36.0399</td>
<td align="right">4.9654</td>
</tr>
<tr class="even">
<td align="left">Smoothing Spline</td>
<td align="right">6</td>
<td align="right">40.2160</td>
<td align="right">3.5441</td>
</tr>
<tr class="odd">
<td align="left">Smoothing Spline</td>
<td align="right">25</td>
<td align="right">38.8952</td>
<td align="right">1.8645</td>
</tr>
</tbody>
</table>
<div class="page-break-after"></div>
<div id="classification-setting" class="section level2">
<h2><span class="header-section-number">1.1</span> Classification Setting</h2>
<p>So far, we have talked about assessing model accuracy in the regression setting, but we also need a way to assess the accuracy of classification models.</p>
<p>Suppose we see to estimate <span class="math inline">\(f\)</span> on the basis of training observations where now the response is categorical. The most common approach for quantifying the accuracy is the training error rate.</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>This is called the <em>training error rate</em> because it is based on the data that was used to train the classifier.</p>
<p><br /></p>
<p>As with the regression setting, we are mode interested in error rates for data <em>not</em> in our training data.</p>
<div class="page-break-after"></div>
</div>
<div id="bias-variance-trade-off" class="section level2">
<h2><span class="header-section-number">1.2</span> Bias-Variance Trade-off</h2>
<p>The U-shape in the test MSE curve compared with flexibility is the result of two competing properties of statistical learning methods. It is possible to show that the expected test MSE, for a given test value <span class="math inline">\(x_0\)</span>, can be decomposed</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>This tells us in order to minimize the expected test error, we need to select a statistical learning method that siulatenously achieves <em>low variance</em> and <em>low bias</em>.</p>
<p><br /></p>
<p>Variance  <br /><br /><br /><br /></p>
<p>Bias  <br /><br /><br /><br /></p>
<div class="page-break-after"></div>
</div>
</div>
<div id="cross-validation" class="section level1">
<h1><span class="header-section-number">2</span> Cross-Validation</h1>
<p>As we have seen, the test error can be easily calculated when there is a test data set available.</p>
<p><br /><br /><br /><br /></p>
<p>In contrast, the training error can be easily calculated.</p>
<p><br /><br /><br /><br /></p>
<p>In the absense of a very large designated test set that can be used to estimate the test error rate, what to do?</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>For now we will assume we are in the regression setting (quantitative response), but concepts are the same for classification.</p>
<div class="page-break-after"></div>
<div id="validation-set" class="section level2">
<h2><span class="header-section-number">2.1</span> Validation Set</h2>
<p>Suppose we would like to estimate the test error rate for a particular statistical learning method on a set of observations. What is the easiest thing we can think to do?</p>
<p><br /><br /><br /><br /><br /><br /><br /></p>
<p>Lets do this using the <code>mpg</code> data set. Recall we found a non-linear relationship between <code>displ</code> and <code>hwy</code> mpg.</p>
<p><img src="data:image/png;base64,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AAIIIIBADAhoPE0b+OhQWMTOqldhYQ+AanF0RunBgweLTr6gAQidvVknbRgyZIjREkUnW5k3b57ce++90rdvX2Nm+AsuuEC++uqr6p0NWyMQIwIzZsywXFIdL1cDck5I/8/edcBHUX3dm0ZII43QIbSE3pEmHRFEFAuKfogFBASxwB9E7KKICIpiAcFesIANBZQiCKj03jvSS0hII6SQ752Hg5vNljebLbO79/5+k83OvHnz3pnZmTfnnXsvkg1BTVa7dm2qU6eOJAlVEhDBG71t4zR6ceh+mvTIburSMoVKhaipOnPzAmnZ+nga924devq9JFq+IY5y8wKU4cD9BvFRduzYIe9FIEbthSAA4fvUU08pHQMJpB577DGlslyIEXAGAs8995xSNQhnoXodK1WooxAmSVQTt4HUHTJkiI7ajV0UY52GDRsqNfKee+6hmjVrKpXlQowAI8AIMAKMACPACDAC/oUAcnLs3btXemP6V89d01uXEKDmTcXgfujQofTdd9/JE4fkCK+++ipB9RAaGkqQ8v7888+0bNky8135OyPgkwjAjVWFxEA4iW3bthkSg7CwMKpWrZp80a9UqRLBrV/FEivm0NDbjtKMcdvpvt7HpKu7yn4oc+BYBM34rhoNe7WBUIdWomNnQlV3leUQKwVuA9u3b7cbO2XkyJFy0sbWAZCACWE+QOCwMQLuQgAThmPGjLF7uLfffluGn7Fb0EUFXnjhBZn80Fb1uI/MnTuXMJHgK4b79pw5c+Tkrq0+NW7cmN59911bRXgbI8AIMAKMACPACDACjICfIoDEpyA/Ocu78y4AtxCgps1F3EPEEYQi6/Dhw7riIJrWw/8zAt6OANza33vvPavJehISEqTUHa7nRja87IMAhHs8JjtUiQzE9byh3Tl6Y+RuenbQfmrTMI2CAtWy2GVdDKaFf5Wj0W/Woxdm1qaVm2J1qUKhAE1NTZWKUJChJ06cKJbxHuo5xC8eP348WYpZ3KRJE1qxYgV5ysXYyNcEt831CCCkzMyZMwkKcXNLTEykn376iYYPH26+ya3fMUGwYMECGjt2rMUJktatW8swOB06dHBru9xxsLp169L69etl2B/z4+He8uCDD9KqVauoTJky5pv5OyPACDACjAAjwAgwAoyAHyOA0G3woj5+/DhneXfydRAgYuWpMQ4OHhjVb926lX77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/0qNGjV87gKB58svv5TDDz/c53aujCwBjPW8efMCWup27txZEOjMaoKF8HfffefXGhHXlLvuusuWy4V27drp60379u19NgNTbnHNuummm3xuj+eVsLwdO3asX0tQ+NP89ttvpWvXrjHt5vz586VXr15+24CZAjNnzmTAPL+EuIEESCDWBOgDNNYjwOOTAAmQAAmQAAmQQAwIQKR49NFHBVPcYZ2HB1f4jmrTpo2cd955cvrpp4flZykGXeIhLRDANPTly5fLuHHj5Ouvv9YRpSFyw58npuNandLueSicL6gXFqYQxrZt2yYQPjGtediwYQxM5wkrBp87duyox+Shhx6S8ePHyx9//KGtcVu1aiW33nqr/PWvf7XdKohyM2bMkI8++kj+97//ycqVK7WAB4EM1xQc027q1q2bLFy4UPsn/uyzz2TdunVaWId4jnMTVqqJmiCCDhkyRF+Lf/jhB+0zu2nTpnLiiSfKRRdd5IrggbDkRnT3Dz/8UM8MwHUEPgchiF9wwQXywAMPJOrwsF8kQAIJQiBFORsuS5C+uLIbeEu5adMmWw7iI9WRzZs36x9PvN1nchcB3DxgfJBwc0FrG3eNj2kNHhgwBYm+8AwR9yzhlH3r1q26QQhsYGUanXtanzwtQQAFWInhe8TkLgLFxcVaIEGr4DTfbvRed/UmMVuDIEi4p8R9HCLBM7mLAF4e7NixQzcK1zh/FrHuanVytQZBkLZs2aLvEdwSBCm5RiBwbwsKCnSgN5TCvTYijTO5i4C538azKp5ZmdxFAAGqTFDYRLxXQBR4+BjGy7xzzjknJPicAh8SNu5EAiRAAiRAAiRAAiRAAiRAAslLID8/X1v99enTR+rVq6ctNM844wz5+OOPkxcKe+4KAhBKnn/+eRkwYIB2+dG4cWM5/vjj5Y033tBWq65oJBtBAiQQdQKcAh915DwgCZAACZAACZAACZAACZAACcQvgenTpwvETjODyfQE09YxJf7MM8+UN998k9bKBgyXUSOwdOlS7U5gyZIllY6JmVyTJ0+Wl19+WbtuaNiwYaXt/IcESCDxCdACNPHHmD0kARIgARIgARIgARIgARIgAUcIQFg66aSTqoifnpXDT+TQoUM9V/EzCUScwPbt27Wlp7f46Xngn376SQYPHiywEmUiARJILgIUQJNrvNlbEiABEiABEiABEiABEiABEgiZwIgRI2TXrl1B94cI+sknnwQtxwIk4BSB++67T1avXh20OgRzeumll4KWYwESIIHEIkABNLHGk70hARIgARIgARIgARIgARIggYgQQDC7zz//3HLdr732muWyLEgC4RBAkKtx48ZZroLnpmVULEgCCUOAAmjCDCU7QgIkQAIkQAIkQAIkQAIkQAKRIzB37lxblc+ZM8dWeRYmgVAJrFy5Unbu3Gl594ULF3IavGVaLEgCiUGAAmhijCN7QQIkQAIkQAIkQAIkQAIkQAIRJVBQUGCrfrvlbVXOwiTgQSCUc62wsNCjBn4kARJIdAIUQBN9hNk/EiABEiABEiABEiABEiABEnCAQJs2bWzVYre8rcpZmAQ8CLRs2VJSUlI81gT+WKtWLUFmIgESSB4CFECTZ6zZUxIgARIgARIgARIgARIgARIImUDPnj2lefPmlvc//fTTLZdlQRIIhwDEzIEDB1qu4owzzrBclgVJgAQSgwAF0MQYR/aCBEiABEiABEiABEiABEiABCJKABZ2Dz74oKVjNGrUSK677jpLZVmIBJwgcP/991uyAs3KypK77rrLiUOyDhIggTgiQAE0jgaLTSUBEiABEiABEiABEiABEiCBWBIYPny43HjjjQGbULNmTfnoo4+kRo0aActxIwk4SaB///7y3HPPBawyPT1d3nrrLWnXrl3ActxIAiSQeAQogCbemLJHJEACJEACJEACJEACJEACJBAxAs8++6yMGzfO53T4IUOGyKxZs6Rfv34ROz4rJgF/BK6//nqZNGmSdO3atUqRI488UqZNmyZnnXVWlW1cQQIkkPgEqiV+F9lDEiABEiABEiABEiABEiABEiABJwkMGzZMhg4dKvPmzZOVK1dKTk6O9OjRQzD1nYkEYkngxBNPFORFixbJ4sWLJS0tTbp06SKtW7eOZbN4bBIggRgToAAa4wHg4UmABEiABEiABEiABEiABEggHgnAJygCIyEzkYDbCHTq1EmQmUiABEgABDgFnucBCZAACZAACZAACZAACZAACZAACZAACZAACZBAwhKgAJqwQ8uOkQAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJUADlOUACJEACJEACJEACJEACJEACJEACJEACJEACJJCwBCiAJuzQsmMkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIUQHkOkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJJCwBCqAJO7TsGAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAVQngMkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIkQAIJS4ACaMIOLTtGAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAZTnAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQQMISoACasEPLjpEACZAACZAACZAACZAACZAACZAACZAACZAACVAA5TlAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiSQsAQogCbs0LJjJEACJEACJEACJEACJEACJEACJEACJEACJEACFEB5DpAACZAACZAACZAACZAACZAACZAACZAACZAACSQsAQqgCTu07BgJkAAJkAAJkAAJkAAJRIfA6NGjJTs7W1JSUipyXl6efPXVV9FpAI9CAiRAAiRAAiRAAgEIVAuwjZtIgARIgARIgARIgARIgARIICCBRo0ayaZNm6qU2bNnj5xwwgnSo0cPmTt3bpXtXEECJEACJEACJEAC0SJAC9BokeZxSIAESIAESIAESIAESCDBCDRr1syn+OnZzXnz5smAAQM8V/EzCZAACZAACZAACUSVAAXQqOLmwUiABEiABEiABEiABEggMQh8+umnsn79ekudmTZtmmzcuNFSWRYiARIgARIgARIgAacJUAB1mijrIwESIAESIAESIAESIIEkIDB06FBbvTzppJNslWdhEiABEiABEiABEnCKAAVQp0iyHhIgARIgARIgARIgARJIIgL5+fm2erto0SJb5VmYBEiABEiABEiABJwiQAHUKZKshwRIgARIgARIgARIgASSiEBZWZmt3paWltoqz8IkQAIkQAIkQAIk4BQBCqBOkWQ9JEACJEACJEACJEACJJBEBFJT7T1KZGVlJREddpUESIAESIAESMBNBOzdtbip5WwLCZAACZAACZAACZAACZBAzAh07tzZ1rH/+te/2irPwiRAAiRAAiRAAiTgFAEKoE6RZD0kQAIkQAIkQAIkQAIkkEQE5s6da6u3Y8eOtVWehUmABEiABEiABEjAKQIUQJ0iyXpIgARIgARIgARIgARIIIkIpKenyx133GGpx++9956lcixEAiRAAiRAAiRAApEgQAE0ElRZJwmQAAmQAAmQAAmQAAkkAYFHHnlEHn/8cb89TUlJkc8++0zOPvtsv2W4gQRIgARIgARIgAQiTYACaKQJs34SIAESIAESIAESIAESSGACt912myAi/MiRI6VBgwZSvXp1ady4sTzzzDNy4MABOfnkkxO49+waCZAACZAACZBAPBCoFg+NZBtJgARIgARIgARIgARIgATcTeCxxx4TZCYSIAESIAESIAEScBsBWoC6bUTYHhIgARIgARIgARIgARIgARIgARIgARIgARIgAccIUAB1DCUrIgESIAESIAESIAESIAESIAESIAESIAESIAEScBsBCqBuGxG2hwRIgARIgARIgARIgARIgARIgARIgARIgARIwDECFEAdQ8mKSIAESIAESIAESIAESIAESIAESIAESIAESIAE3EaAAqjbRoTtIQESIAESIAESIAESIAESIAESIAESIAESIAEScIwABVDHULIiEiABEiABEiABEiABEiABEiABEiABEiABEiABtxGgAOq2EWF7SIAESIAESIAESIAESIAESIAESIAESIAESIAEHCNAAdQxlKyIBEiABEiABEiABEiABEiABEiABEiABEiABEjAbQQogLptRNgeEiABEiABEiABEiABEiABEiABEiABEiABEiABxwhQAHUMJSsiARIgARIgARIgARIgARIgARIgARIgARIgARJwGwEKoG4bEbaHBEiABEiABEiABEiABEiABEiABEiABEiABEjAMQIUQB1DyYpIgARIgARIgARIgARIgARIgARIgARIgARIgATcRqCa2xqUiO3ZsmWLvPPOOzHv2q5du6RatWqSk5MT87awAZUJHDhwQDA+SBij3NzcygX4nysI5OfnS2ZmpmRlZbmiPWzEQQKlpaWye/duvSI9PV2qV69+cCM/uYbAzp07JTs7W3+PXNMoNkQTKCkpkT179ujPGRkZvFdw4Xlh7hVwH4cxYnIXgf3798vevXt1o3CvgGsdk7sImHsF3CPgXoHJXQSKi4uloKBANwr32rzfdtf4oDXmO4RnVTyzMrmLQFFRkSAjJeK9Aq4R4SaeteEStLD/mjVrZNSoURZKsggJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkICTBFLKVHKyQtZVmQDekuCNPRMJBCKwdetWOe6443SRPn36yNixYwMV5zYSIAEvAsuXL5ezzz5br8V36cknn/QqwX9JgAQCEZg7d65ceumlushZZ50l99xzT6Di3EYCJOBFYMqUKTJixAi9Ft+lG2+80asE/yUBEghEYOLEiRW/PTfccINcdtllgYpzGwmQgBeB8ePHy1NPPaXXwgDPPBt5FYv7f2F9nJKSElI/aAEaEjbrO6WlpQkyEwkEIoBzBNMPkSCac1pOIFrcRgJVCeCHkN+hqly4hgSsEkhNTa34DuHdOH+HrJJjORIoJ8DvEM8EEgiPAAQNcy+Hmvg7FB5P7p2cBMx3CN8nfoeqngMMglSVCdeQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAmQAAkkCAEKoAkykOwGCZAACZAACZAACZAACZAACZAACZAACZAACZBAVQIUQKsy4RoSIAESIAESIAESIAESIAESIAESIAESIAESIIEEIUABNEEGkt0gARIgARIgARIgARIgARIgARIgARIgARIgARKoSoACaFUmXEMCJEACJEACJEACJEACJEACJEACJEACJEACJJAgBFJUpM+yBOkLu0ECcUtg37598u233+r2161bV/r06RO3fWHDSSAWBPbs2SPTpk3Th27UqJH06NEjFs3gMUkgbgns2LFDZsyYodvfrFkz6dq1a9z2hQ0ngVgQ2Lx5s8yZM0cfunXr1tKxY8dYNIPHJIG4JbB+/Xr55ZdfdPs7dOggbdq0idu+sOEkEAsCq1atkkWLFulDd+nSRZo3bx6LZrj6mBRAXT08bBwJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkEA4BDgFPhx63JcESIAESIAESIAESIAESIAESIAESIAESIAESMDVBCiAunp42DgSIAESIAESIAESIAESIAESIAESIAESIAESIIFwCFAADYce9yUBEiABEiABEiABEiABEiABEiABEiABEiABEnA1AQqgrh4eNo4ESIAESIAESIAESIAESIAESIAESIAESIAESCAcAtXC2Zn7kgAJhE8A0d+///57WbdunRw4cEBatGghRxxxhBx//PHhV84aSCAJCEyePFmmTJmiv0ONGzeWbt26ybHHHiv4zEQCJGCPQFlZmdx///2ydu1aeeihh6Rhw4b2KmBpEkgyAriPW7Bggd9e16tXTy666CK/27mBBEhAZMeOHTJx4kRZvHixIBp8o0aN5PDDD5dTTz1VqlWjZMFzhAR8ERg7dqzs3r3b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" width="672" /></p>
<p><br /><br /></p>
<p>We fit the model with a squared term <span class="math inline">\(\texttt{displ}^2\)</span>, but we might be wondering if we can get better predictive performance by including higher power terms!</p>
<div class="page-break-after"></div>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">## get index of training observations</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co"># take 60% of observations as training and 40% for validation</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">n &lt;-<span class="st"> </span><span class="kw">nrow</span>(mpg)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">trn &lt;-<span class="st"> </span><span class="kw">seq_len</span>(n) <span class="op">%in%</span><span class="st"> </span><span class="kw">sample</span>(<span class="kw">seq_len</span>(n), <span class="kw">round</span>(<span class="fl">0.6</span><span class="op">*</span>n)) </a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="co">## fit models</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">m0 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ, <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">m1 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">2</span>), <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">m2 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">3</span>), <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">m3 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">3</span>) <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">4</span>), <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="co">## predict on validation set</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">pred0 &lt;-<span class="st"> </span><span class="kw">predict</span>(m0, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">pred1 &lt;-<span class="st"> </span><span class="kw">predict</span>(m1, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">pred2 &lt;-<span class="st"> </span><span class="kw">predict</span>(m2, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">pred3 &lt;-<span class="st"> </span><span class="kw">predict</span>(m3, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"><span class="co">## estimate test MSE</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">true_hwy &lt;-<span class="st">  </span>mpg[<span class="op">!</span>trn, ]<span class="op">$</span>hwy <span class="co"># truth vector</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"><span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">2</span>, <span class="dt">model =</span> <span class="st">&quot;linear&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred0) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22"><span class="st">  </span><span class="kw">bind_rows</span>(<span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">3</span>, <span class="dt">model =</span> <span class="st">&quot;quadratic&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred1)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"><span class="st">  </span><span class="kw">bind_rows</span>(<span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">4</span>, <span class="dt">model =</span> <span class="st">&quot;cubic&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred2)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"><span class="st">  </span><span class="kw">bind_rows</span>(<span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">5</span>, <span class="dt">model =</span> <span class="st">&quot;quartic&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred3)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co">## bind predictions together</span></a>
<a class="sourceLine" id="cb1-25" data-line-number="25"><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">se =</span> (true <span class="op">-</span><span class="st"> </span>pred)<span class="op">^</span><span class="dv">2</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># squared errors</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26"><span class="st">  </span><span class="kw">group_by</span>(terms, model) <span class="op">%&gt;%</span><span class="st"> </span><span class="co"># group by model</span></a>
<a class="sourceLine" id="cb1-27" data-line-number="27"><span class="st">  </span><span class="kw">summarise</span>(<span class="dt">test_mse =</span> <span class="kw">mean</span>(se)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co">## get test mse</span></a>
<a class="sourceLine" id="cb1-28" data-line-number="28"><span class="st">  </span><span class="kw">kable</span>() <span class="co">## pretty table</span></a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">terms</th>
<th align="left">model</th>
<th align="right">test_mse</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">2</td>
<td align="left">linear</td>
<td align="right">14.17119</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="left">quadratic</td>
<td align="right">11.26710</td>
</tr>
<tr class="odd">
<td align="right">4</td>
<td align="left">cubic</td>
<td align="right">11.08535</td>
</tr>
<tr class="even">
<td align="right">5</td>
<td align="left">quartic</td>
<td align="right">11.04907</td>
</tr>
</tbody>
</table>
<div class="page-break-after"></div>
<p><img src="data:image/png;base64,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IAESIAESIAESIAESIAESIAESIAES6I4EKIB2x1eNPpNAiAg4o+ORO20ORt22Bbmn3glnTKLRc5MHJWuexMaHh2PvO3PhrikN0YjshgRIgARIgARIgARIgARIgARIgARIgAS6lgAF0K7lzdFIICwJuOJSkDf9HoxUQmj25JvgcMVoP73uehSveAD/fWgoCpf9Gp76yrD0n06RAAmQAAmQAAmQAAmQAAmQAAmQAAmQQGsEKIC2RoblJNADCUQnZiP/vAcw8paNyBh7NeAwPiKalPBZ+MF8bHxoGIpXPYomJYwykQAJkAAJkAAJkAAJkAAJkAAJkAAJkEB3IEABtDu8SvSRBLqYQExaPwy4+El1WNJnSBt+sTW6u6YEe9+ao5bGj0DJumfhVUvlmUiABEiABEiABEiABEiABEiABEiABEggnAlQAA3nV4e+kcBxJhCXNRSDLn8Rw274BMmDplveNFbsxe5Xb1CHJY1F2cZX4PV6rTpmSIAESIAESIAESIAESIAESIAESIAESCCcCFAADadXg76QQJgSSMgbh4Jrl6Dge+8iMX+K5WV96VbsfOkKbP7TZFRsf8cqZ4YESIAESIAESIAESIAESIAESIAESIAEwoVAyAXQxx9/HLfddhs2bdrU7jkuWLAAU6dOxX333RfQ5vzzz8cDDzyAMWPGBJTzgQRI4PgQSB5wKob+8EMM+s5ixOeMspyoLfoc25+7AFufno6q3SutcmZIgARIgARIgARIgARIgARIgARIgARI4HgTCLkA+uqrr+Lhhx/Gzp072z23ZcuWYdWqVc1E02nTpmH27NkoKChod180JAES6HwCacMuwLAb12DArGcRkz7IGrBq13JsfeoM7HhhFmqKvrDKmSEBEiABEiABEiABEiABEiABEiABEiCB40Ug5AJoRybi8XiwefNmfP7557pZQkJCR5rTlgRI4DgScDgcyBjzHYy8eQPyZz6C6OTeljflW9/A5scmYufia1BXut0qZ4YESIAESIAESIAESIAESIAESIAESIAEuppA1LEMOHPmTCxdujSgi8bGRv188cUXw+lsW18V26amJqv9hAkTrDwzJEAC3YOAwxWF7Ek3IHPcNSj+9I84sPz38NSWaefLNixShyQtRtZJ30fuaXMRk9Kne0yKXpIACZAACZAACZAACZAACZAACZAACUQMgbYVyiNMc+HChVrArK+vh3mZgqaIm2ZZa3fTVoYZNWoULrrooiOMyGoSIIFwJeCMjkfutDkYddtW5J56J5wxiYarTR6UrHkCGx8ejr3vzIW7pjRcp0C/SIAESIAESIAESIAESIAESIAESIAEIpDAMUWADhs2DI899hhWr15toXnzzTexe/dunHvuuejXr59V3lImOjoaiYmJGDhwIC677DKkp6e3ZMYyEiCBbkTAFZeCvOn3IHvyTSj66H4tfno9DfC661G84gH9nHPyT9Fryi1wxSZ1o5nRVRIgARIgARIgARIgARIgARIgARIgge5I4JgEUJnwD37wA32Zk5dl8SKA3nTTTZA8EwmQQM8kEJ3UC/nnPYCcqbdh/wfzcejzFwBvE5rqK1H4/j04+MkfdaRo1sTr4YyK7ZmQOGsSIAESIAESIAESIAESIAESIAESIIFOJ3DMAmiwh1dffTWmTp2KoUOHBlf1yGc56MntdqO8vDzi5m/u9yoTq6qqOuKerxEHgBNqHwFHKtLPXIjEsT/CoRX3oXrb67qdu6YEe9+ag8LlDyBj6h1IHvFtOJyu9vV5nKy8Xi/q6uoC9i4+Tq5wWBLoVAINDQ1W/9XV1fp9bxUwQwIRSEC2ZZL3fSR+vxaBLxendAwE7J/vNTU1+n1/DN2xKQmEPQH5eVw+4/n5HvYvFR08RgJ2faa2thb252PsOiyay9aakuxbaXbUsZALoJdffnlHfYhoexFM5AUyX6xImqz8Z2Im+WZKTgVnIoFWCST2Q/rZjykh9EaUr7of9Xs/1qaeqv04+M5tKPvPI0iZfAfiB58X1u8led9H4r/nVl83VvRIAvZvLOSbJ/lFHhMJRDIB+X6Nn++R/ApzbiYB++e7fLbbv583bXgngUgiIO95+TmV379H0qvKubREwP75Lt+/R9rneyj+DYdcAG3phQgu27dvH95++23IN5sXXHABevXqFWwSMc9RUVGIiYmJyDmWlZVZUUEZGRmQPV2ZSOCIBHrNQN9RM1D59UfY/+4vUb33U93EffgrHHr7R4jvPRZ9ZtyLlBPOOmJXXW1QVFSk9y1OTk7u6qE5Hgl0KQGJkpDIIElpaWmIjeU2FV36AnCwLidQXFys3+epqaldPjYHJIGuJFBRUQGJ7JeUkpKC+Pj4rhyeY5FAlxMoKSmBy+XieSNdTp4DdjUBWZVbWVmph5XP94SEhK52oVPHMwVQp/Poz3I/+pZtTE1+m/ivf/0L/+///T+8//77AZbz5s1D37599b6hP/zhD9G7d29cc801WgwNMOQDCZBARBNIHnAqhl73EQZ9ZzHic0ZZc60t/AzbnzsfW5+ejqrdq6xyZkiABEiABEiABEiABEiABEiABEiABEjgaAh0igA6d+5cXHzxxfj3v/+NLVu2WH69/vrrmD9/vvUsGQnTfe6553DPPfcElPOBBEigZxBIG3YBhv1oNfrPegYx6YOsSVftWo6tT52OHS/MQk3RF1Y5MyRAAiRAAiRAAiRAAiRAAiRAAiRAAiTQEQIhF0A//PBDPPDAA9oHWf5tD7u99957daSnhKDPnj0ba9euxU9+8hNtK8KoPDORAAn0PAIOFcaeOeYKjLz5C+TPfATRyb0tCOVb38DmxyZi5+JrUFe63SpnhgRIgARIgARIgARIgARIgARIgARIgATaQyDkAuhTTz2lozpHjRqFjRs34tprr9V+7Nq1C59+auz1N2vWLC2SnnTSSXj00Ucxffp0LYwuX768PT7ThgRIIEIJOFzRyJ50A0be+iXy1D6grvh0a6ZlGxZh0x9GY/drP0FDxT6rnBkSIAESIAESIAESIAESIAESIAESIAESaItAyAXQTZs26fFE+BwyZIg19pIlS6z8JZdcYuUlc+mll+rndevWBZTzgQRIoGcScEbHI/eU2zHqti3IPfVOOGMSDRBNHpSseQIbHx6Ove/MhbumtGcC4qxJgARIgARIgARIgARIgARIgARIgATaTSCkAqic6r5582Y9+De/+c0AJ9588039LMvfzz777IA6OQhJkkSMMpEACZCAScAVl4q86feoiNDNyJ78YzhcMbrK665H8YoH8N+HhqLww9/AU19lNuGdBEiABEiABEiABEiABEiABEiABEiABAIIhFQAlQONGhoa9ADJycnWQFL2wQcf6OeJEyciPd2/rFUKi4uLdV1aWpq+8wsJkAAJ2AlEJ/VC/nkPYuQtG5Ex9mrAYXx0NdVXovD9e7BRCaHFqx5FkxJGmUiABEiABEiABEiABEiABEiABEiABEjATiCkAqhEd/bv31/3b0aCyoMcjFRVZURoBUeGSv3SpUvlhn79+uk7v5AACZBASwRi0vphwMVPYsRN65E2/CLLxF1Tgr1vzVFL40egZN1f4FVL5ZlIgARIgARIgARIgARIgARIgARIgARIQAiEVACVDqdMmSI3zJs3Dzt27EBNTQ3mzp2ry+TLZZddZuXr6ur0YUiLFi3SZdOmTbPqmCEBEiCB1gjEZQ/DoMsXYdgNq5A8aLpl1lixF7tfvV4dljQWZRtf0YerWZXMkAAJkAAJkAAJkAAJkAAJkAAJkAAJ9EgCIRdAZ8+erUHKie/Dhw9HTk4O1q5dq8vOOeccjBgxQudXrFiBwYMH42c/+5kWKfLz83HVVVf1yBeBkyYBEjg6Agl5J6Hg2iUo+O47SOw72eqkvnQrdr50BTb/eQoqtr9rlTNDAiRAAiRAAiRAAiRAAiRAAiRAAiTQ8wiEXAA96aST8OyzzyI6OhqNjY3W0veRI0fixRdftAiXl5dj//79+jk7O1vXxcQYB5xYRsyQAAmQQDsIJA88DUOv+wiDvrMYcb1GWi1qCz/D9ufOx9anp6Nq9yqrnBkSIAESIAESIAESIAESIAESIAESIIGeQyCqM6Z67bXXYvz48ViyZAl27tyJ008/HRL9mZqaag03bNgwHR16ySWX4I477rD2DrUMmCEBEiCBDhJIG3YBUofMxKENL6LwgwVoKPtK91C1azm2PnW6ruutTpVPyD2xgz3TnARIgARIgARIgARIgARIgARIgARIoLsS6BQBVGCMGjVKX62BGThwoI4AdTpDHoTa2pAsJwES6AEEHOozJXPMFcgYdSlK1j6Noo/uQ2NloZ55+dY3IFf66MvR+/T/QVzmCT2ACKdIAiRAAiRAAiRAAiRAAiRAAiRAAj2bQJeqj9XV1daSeIfDAYqfPfvNx9mTQGcScLiikT3pBoy89UvkzbgXrvh0a7iyL15UByWNxu7XfoKGCmMrDquSGRIgARIgARIgARIgARIgARIgARIggYgi0KkC6MGDBzFnzhycdtppyMvLQ1JSEu6++24NUJbGn3LKKVi8eDGampoiCionQwIkED4EnNHxyD3ldoy6bQtyT70TzphEw7kmD0rWPIGNDw/HvnfugrumNHycpickQAIkQAIkQAIkQAIkQAIkQAIkQAIhI9ApAqjX68VDDz2EIUOGYOHChfjoo49QWGgsQTU9//rrr7F8+XJceumluPrqq/WBSWYd7yRAAiQQagKuuFTkqf0/R966GdmTfwyHyzh0zeuuw4EVC/Hfh4ai8MPfwFNfFeqh2R8JkAAJkAAJkAAJkAAJkAAJkAAJkMBxJNApAqiIn7Nnz8bhw4cRFRWFcePG4YQTAvfac7vd+qR4mfvf/vY33HjjjccRA4cmARLoKQSik3oh/7wHMfKWjcgYezXgMD4Gm+orUfj+PdiohNDiT/6AJnd9T0HCeZIACZAACZAACZAACZAACZAACZBARBMIuQC6YcMGzJ07V0ObOXMmduzYgXXr1kHy9nTWWWfpOlkGL+nZZ5/Fli1b7CbMkwAJkECnEYhJ64cBFz+JETetR9rwi6xx3DUl2Pvmz7DxkZEoWfcXeNVSeSYSIAESIAESIAESIAESIAESIAESIIHuSyDkAuiDDz6I+vp6HfX58ssvo1+/fq3Syc/Px9tvv42MjAx4PB489dRTrdqyggRIgAQ6g0Bc9jAMunwRht2wCsmDpltDNJbvwe5Xr1eHJY1F2aZ/QLb2YCIBEiABEiABEiABEiABEiABEiABEuh+BEIugH722WeagkSBxsfHH5GI2JjRodu2bTuiPQ1IgARIoDMIJOSdhIJrl6Dgu+8gse9ka4j60q3Yueg72PznKajb85FVzgwJkAAJkAAJkAAJkAAJkAAJkAAJkED3IBBSAVSiODdu3KhnPn78+HYTOOecc7Tt7t27292GhiRAAiTQGQSSB56Godd9hEHfeRlxvUZaQ9QWfoZDr1+NvS9eiKrdq6xyZkiABEiABEiABEiABEiABEiABEiABMKbQEgFUJfLhaSkJD3j8vLyds/84MGD2jYvL6/dbWhIAiRAAp1JIG3YhRh+4xr0n/UMYtIHWUPV7l2JrU+djh0vzEJN0QarnBkSIAESIAESIAESIAESIAESIAESIIHwJBBSAVSmOGbMGD3TpUuXtnvGsg+opFGjRrW7DQ1JgARIoLMJOJxOZI65AiNv/gL5Mx+GM6GXNWT51jew+bEJ2PnKtag/tMMqZ4YESIAESIAESIAESIAESIAESIAESCC8CESF2p3Jkyfjgw8+wPz583HRRRfhhBNOaHOIZ555Bm+++aa26ciy+TY7ZWWXETjsrsG6qt1Ia0pFbHQMXA4notQld//lUnmHKjfuLt9dnp0t2Et7e7lDtWUigeNJwOGKRvakH8Gddw4aNj+Pw2v+AE9tmXap7IsXUfbfl5F10veRe9pdiElhJPvxfK04NgmQAAmQAAmQAAmQAAmQAAmQAAkEEwi5APrzn/8cL7zwAvbs2YMJEybg/vvvx8UXXxw8Lnbt2oUFCxbg6aef1nXTpk3DrFmzmtmxILwJfFVXgjk7F3e6kyKKtlcwNYXXYCHVXy7Ca7Agawi3WnhVUX/KAi7fPUrd5Y/crfIWhFu7sCuCr/3ZLuj6/QgUelsv9wvIrflNkbjT34J6AEdUHDIm34q+025G0fKFOPjJo2hqrAGaPChZ8wRKP3sOvSbfhJxpcxCVkNE1TnEUEiABEiABEiABEiABEiABEiABEiCBNgmEXABNS0vDX/7yF8yYMQOyD+iNN96or9jYWO3I3//+d/z1r39FSUmJ5VhCQgIkEtSpBCam7kWgydvUJQ671ThyMbVOwB95e2TBtKOCrCHONo/g9Qu9/ohfy4+2BGSfoBzoR0t+B/YbaG/UtS50mwKz0a+0DVVyxaWiz4z56DXlJyj66D4tfno9jfC663BghRJG1zyOnJN/qupvgSvW2Bc5VGOzHxIgARIgARIgARIgARIgARIgARIggY4RCLkAKsOfccYZ+OSTT3DLLbfou5TV19fLDYWFhfpufpk+fToeffTRIy6VN+15Dy8CuTGp+F7OVMTExUFpWnA3NcEDdfnu8iwiqYiXHn151N2rnpWV726UG/ViF2jf3nKjXy+84QWoC73xi8TuLhy1ew0lQm57BVN7BK8p9Hoa3YiJitaXJfT2GgrH2fei8eBmuA/vgku9t53qve3a+T6i9qxAUu9xSFSnyUe7ZIuI4MhgMxK5DaH3iEJySxHNRr9HIxh3r1eU3pIACZAACZAACZAACZAACZAACZDAkQl0igAqw06cOBErV67E4sWL9X3btm2Qy6uEgSFDhqCgoEALpRdeeOGRvaRF2BLoG5uOm/PORFZWFqKjo8PCTxFUG9WS5LaFVEMw9SixyhRk5W48m2KtXbj1l0n/fkE3WKBt3m+7hF67YKwE5OZCsl0wNv00heS2/Gnud08WiU2xvVPeqC4XkDmoedf1aq/QPcubl4dpibkVg3m3hF4lHptlppAc/GwIrs0jhf1bN/j7OLIQ7bc1xjtGobdVIVn5CyUYO1vqv2XBPExfOrpFAiRAAiRAAiRAAiRAAiRAAiTQCoFOE0BlPNmX8NJLL9VXK+OzmARCTkCLMq7QLXcOuYNh0KFbCcSmGNiSoGvWhVzo1VHAhmDbskB9jEJvC0KyiilWgrKar4oOlrtfkDaF5Ob+NPXgSGLztQ+Dt2nYuuD0CaYinLqUcGoJqK3sFdyxSNz2C7GmEN2+/g1h2thL+ciRx7XVNfDUNyIpKhZ1dQ7ENsXqvZNFzLb+qLywkP/r9V29YrpeieVydF1AnWmj7kwkQAIkQAIkQAIkQAIkQAIk0NUEQi6APv7449i0aROuv/56jBgxol3zkcOQ5CT4Cy64AHPnzm1XGxqRAAkcPQGJdotSsg1T6wS0MOwTTj2++/6iQsQlxOtLSanGVg++iOCWBN3K/etwYO1TqCndqqwd8ChhqEkJQFHpg5Ay+tuIUUvj7ZHHR78FhBnp649o9gu9Zl1zodcUO5uN20xINgRkk4MWknuwSCwCeUOTb6uJpsbW30SsOSoCIrCK8BosoEq5KcAadxFZ1S+7lKZqt7XbSKXd1sprIdass92VvQi6WsA1hVz97LfxC75mmQi/huhr1Km86ZNvfNMPyzc9juG3GGv/fbamjXhh9OPvzz6O1Ju2ur0eU2xN/3UPQTb2Mr/f0o/lo4xr71vXGbYB40gLPZbND/Vs2Bh9SFP97OvP9FfXWrZiI1YyhqoxuYsXlk1gv0Y/Pnuxs9maY5g29v5MfqaN9M9EAiRAAiRAAiRAAiTQMwiEXAB99dVXsWTJEpx11lntFkCXLVuGVatWYfDgwT2DOmdJAiQQ9gQCIol9WnFddCISYxKRHJ/cPv8z1GfaqEtxePO/sX/pPNQVbzTale0CvvoASf1PQd5Z9yIpf2r7+gszq1YFVNvWElqIDRCSJSJX4nKNe3uEZL9Aawi89q0rjknotSKSW4oMbnuLCXPu9ntwxLTUMXWcgGzTUakOFGMigeNBQKTYGGdUkLhrCLmmgNqS8KsFXBFyRcRVjpu2pthq3i1RV1mZIq3cAwRoU/j1Cbtmf5a9HkdaqD82W6k3bHSNqhO/xSfTf7PcuJu2MmfTxhKMVYH8MW3seaPMP0c7D92XvZ3uR2xFxPb7onsPGMPoz/RFrFW1fLX8sPtizducoxCUMcw+pZU8++5+//1+m7amL2Jrlhl36VNKDT8C64z+A/uV8YwVSMG28qx7Mn1q4T0i/jKRAAmQAAmQAAl0HoGQC6AdcdXj8eh9QT///HPdTE6DZyIBEiCBSCOQNuxCpA45H4c2vIjCD+ajoWynnmLVro+x9cnTkDr0fPQ+cx4Sck/sVlPXIrH64TCmW3ndtc62FBnsF3T90bkilvrLWxF6tZDsizz2CcgdE5LbL/TWNtSjvrEBFZ46REWrbxXUD+YiTIrgLHt567x8VXmJiFU3qVUXtI2285WY9qatUSd2hr1Zb/Rj9GK2N+r8tmITWOd/NvsV35hI4GgJyHusjpHdR4uP7Y6RgBZjVR/BAqpdzNWirrYxxFmpM4VYXWeJrKpU1xmir9Gn+qxuMj679fYtrig41R7Z5ngiwZptVK6FckPIVd2KpRaH7b7p9rpcxjYszP7EWv6YfhjlUmKO6bMw26ly0y/dk6/cLNPtpEeVMcVlowdzXClXNbb+pMZqbys3f2GhvWml3OxH2hsjtD6O0Y+fld0v+/i+HvxMfPMx7A1f1WBSar0uVntdquqUP0a92Zs8GeXm+0Geda3K6DJbf2IdMCfdn9GXfyyjP6NfTdsYs4Vx9OjKUPcbNI6gM39JYH9ftDiO1dY/H9NX7YevXk+NX0iABEignQSOSQCdOXMmli5dGjBUY6OxHPDiiy/W/6EGVAY9iG2TigQy04QJE8ws7yRAAiQQUQQc6geMzDFXIENFhJaoZfGFH94Hd1WRnmP5ltdRvvUNpJ/4beSd8SvESuQoU0QQkB+qYtTV3VJ5eTlqamq02xkZGYiNje1uU2jTX9nGocbToKSuQAFVGun4ZC3yGmKu2FgirSX4GkKtSK1en5BrCrNyN8Vc3dYawxByjToRjI1+TVt9N23N8aUnNYhpI23s4+hn3Y9PgPbZmuKyaWv536y9+K898fdrs2kmQOu5GT4ZrYL9MXgY/vr8DurP9Mlv07y/QBvfSHpu6tUx2RxBQNdELFvfHH2++OtM/4FGt/r+VX7wV5e8B+S1tfzwMRIeht++u7IRKaBRRb3bOdptlAkTCbSbgPFONd57upG8EZlIgATaJCDCqCHO+u4+cdQQe42m2kZ9vjcXW00B2BBtDTufgCv/J6jmukxy6q/uU5f76qRPbaGqVd6wNvJGubLTTQ17v9jsLw/wSfqSbtQ9oFwVSrFd1NdWqrylccQXKdf+WOObfRpeyjjSqyFGG/3b8/bxxSn5o8cy2+m2BpPgcaRvv1++vq2xlLWvP2Vmm6eykwI9UvNyc3zDF9P31saReuWB5athb83JVy6j2X8B4rc3WJnemOXG/IPnY/gtpeK+vqsGdlZGqW1Oll/GONJO26h2Zh+Gr/7+dLmuN0Yyn+3j1DTUoNpdg/QoBhZqpC18OSYBdOHChRg9ejRM0dPef0tl9vrg/KhRo3DRRRcFF/OZBEiABCKKgMMVjexJP0LmuGtR/MkfcGDFQnhq1Unx6gfrsi9eRNl/FyNr/PeRe+pcxKTkRdTcORkSCBcCsg9yijM+XNyhH2FAoLi4WAv9qampne5NvUcFACiJVbStjgnoIryqwAEtBqv2LQiy0p8lEssoNlsZMVjUNcRa6dLfX7CNJYTL6KpD8VtEdknBttKflEmPdlujjfivcqbflo3f1piTzW+bja7T4xv9yDBarJYufX9kTMsnVWaNpW2lTnsQ5GNwf/45qmYB/RksbGNofwweYmv4b3hj+SGO+uYho1t++/o266SV9l/bGD6prDFHn63Zpx5B5mqztXw152iv89mqbphIIOIIGP/i1LT0vzXf9OQfBBMJ9EACKq4f/xl3Vw+cefumfEwC6LBhw/DYY49h9erV1mhymNHu3btx7rnnol+/flZ5S5no6GgkJiZi4MCBuOyyy5Cent6SGctIgARIIOIIOKPjkXvK7cieeD2Kli/EwU8eRVOjirhTh+uUrH4cpev/il6Tb0LOtDmISsiIuPlzQiRAAiTQUwnEql+EMZHA8SIgEf6V1VVaPE1Rgn9cXJxIpeqPSkpAkj+G0CrSrFFuCbs+gckot9npdqa9qjWfff1Z4qytP7EOHEfaGX2Y5VaPqtwUe42xfTUtjGP5KmP5+pOpBYrH9nHEO7O/wHKp0ePpfpQHvv50uXrQPtnGkXIxal7un6vu0deP3ydzHBlNujBmac8b8/fZBYzpn6fpqzm++KL7UF9NpoaNUS5lVo8qq+tUid8vVSIm0l5qbf1Juf4FhNQaRkb7oHJpLv1aY6kC/zjSq+/ZVy5Pgb762ksr3/i6ROWNeaonX7nu11cuHRvjeOHxGJ46nGo7H1t5cDvTF/v40kDK/fM3nqWt4b2qZCKBcCJghJOGk0dh5csxCaAykx/84Af6Mmcly+JFAL3pppsgeSYSIAESIIHWCbjiUtFnxnz0mvITFH10H0rWPAGvig7yqkNgJDr0oHrOOfmnqv5muGKTWu+INSRAAiRAAiRAAiRwBAKy9FTv4a3sYtWBX3EU5I9AjNXdnUBJSQlcLlenBlsZYqpPLNWiqcr7xFMptdeb5S2JqsI6MLLdEHgNsVertz5hV4RqQ4I1+9PjqPbmygJ7uV/UtgvGqr0lCJvlPmFZVF89klHu99UolbEMUdtsF1guzc05S0/+8YWFYWv0aeT1V7Pc5OfzQOz1TIPKrT597dRNt2ip3GKl/Db+Gv5bzGSuvn6MeUmN4ZsxfhArbW+0NtuZ9vbxfT20LOpLQ+nHGsfIW+3NOmWn/yhDX063sex0vepElbrVGTvwSI9MrRE4ZgE0uOOrr74aU6dOxdChQ4Or+EwCJEACJNAKgeikXsg/70H0mnqbPijp0Od/U/+PqW+B6itQ+P48HPz0j2pZ/J3ImnAdnFGRtR9jK0hYTAIkQAIkQAIkQAIkQAJhT8Dc01IcdTECL+xfr0h1sKqqCpWVlZE6vZDMK+QC6OWXXx4Sx9gJCZAACfREArFp/THg4qf00vfCpfNw+Mt/aQzu6oPY++bPcGDlQ/qgpIwxV8Kh9jFkIgESIAESIAESIAESIAESIAESIAESaJtA9zuatu35sJYESIAEIoJAfPZwDLp8EYZevxLJg8605tRYvge7/nUdNv1xHMo2/UMvL7EqmSEBEiABEiABEiABEiABEiABEiABEmhGgAJoMyQsIAESIIHwIZDYZzwKrn0TBd99Gwl9J1mO1Zdswc5F38GWP38DFTves8qZIQESIAESIAESIAESIAESIAESIAESCCQQ8iXwgd0f36eamhrMmTMHubm5+NWvftWiM2LzxBNPtFhnFsphTieccIL5yDsJkAAJdDmB5IGnY9h1H+Pw5n9j/9K7UVe8SftQU7ge2/86E0kDTkXejAVIyp/S5b5xQBIgARIgARIgARIgARIgARIgARIIZwIRK4DKqWPz58/Hhg0bEBXV+jS3b9+OxYsXt/kajR07lgJom4RYSQIk0FUE0oZdiNQh5+PQF39H4bIFaCjbqYeu+vojbH3yNKQOPR950+9BfM6ornKJ45AACZAACZAACZAACZAACZAACZBAWBNoXRkMa7fbdq62thYPP/wwVqxY0bahqt22bZu2GT9+PM4807/Pnr1hQUGB/ZF5EiABEjiuBBxOJzLHXomMEy9DydqnUPjhfXBXFWmfyre8jvKtbyD9xG/rw5JiMwYfV185OAmQAAmQAAmQAAmQAAmQAAmQAAkcbwIRJ4CuWbMGv/3tb1FUVASnEgmampraZGwKoCJ+XnjhhW3aspIESIAEwomAwxWN7Ek/Qua4a1H8yaM4sHwhPHWHoU5GQtkXL6Lsv4uRNf77yD11LmJS8sLJdfpCAiRAAiRAAiRAAiRAAiRAAiRAAl1GIKIOQXr33Xcxe/ZsLX5OnjwZP/3pT48IUpbASxo6dOgRbWlAAiRAAuFIwBkdj9xT7sCo2VuRc8rP4YxOMNxscqNk9ePY+PBw7HvnLrhrDoWj+/SJBEiABEiABEiABEiABEiABEiABDqVQEQJoIcOHUJeXh7uvPNO/O53v0N6enqb8NxuN7766iu9R+igQYO0bUVFBerr69tsx0oSIAESCEcCrrhU9JkxHyNv26wiQ2+ERIhK8rrrcGDFQvz3oaF6ubynvioc3adPJEACJEACJEACJEACJEACJEACJNApBCJqCfz06dNxySWXtHnokZ3irl270NjYiH79+uFvf/sb/vnPf6K0tFQvnZeyq6++Gmeffba9SYv5K6+8slXRNCYmRo9RUlLSYtvuXCgCspkOHz4Mh8NhPvJOAhFJQA5Xq6mpafXfe/hM2oX4yb9E7+HfRfmnv0f1lleUCtqEpvoKFL4/DwdWPYrUCbci6cSrlEgaGz5u05OwIeDxeCxfysvL9f+LVgEzJBCBBOQ9X1dXp79ni8DpcUokYBGwf75XVlaiurraqmOGBCKRgPzMKlck/jweia8X53T0BOyf71VVVfrn1qPvLfxamoGKR9rmsi3PI0oAzcrKamuuzerM/T93796NJ598EtJeDkP6+uuv9bVgwQKsW7dOR5Q2a2wrkJPmzRfDVqyzo0ePVtvxeSP+G2q7GBrMgM8kEEkE5AP3WD50u5RFfA5STv8d4sdcj8r//B71O9/WwzfVlqLs41+hfP2fkDxhNuKHzILD6epS1zhY9yEg30zZv6HqPp7TUxLoGIFu9fnesanRmgRaJMDP9xaxsDBCCUjgExMJ9BQCkfj5Hop/wxG1BL6jb2Zz/8/k5GQ8+uijOgL0oYce0nfZS1QiGt944w0sW7aso13TngRIgATChkB0egEyvvlnZM76N2L6nGz51VS1H+XLbsfBl85G7Vdv6l/WWJXMkAAJkAAJkAAJkAAJkAAJkAAJkECEEIioCNCOvibXXnstZNl8amqq3jvUbC/C56xZs3QUqCyLf/7553H66aeb1c3uK1eubFZmFtx11104ePAgcnJyzKKIucuydzPyNTMzs91bD0QMAE6kxxE4cOAAEhMTkZSU1D3nnnMWcOJZqNz5IQqX/go1+/6j5+E5vAOH37kR8b3HIW/6AiQPnt4950evQ0ZA9sOura3V/cl+2rKdCxMJRDIB+V4tNjYWKSkpkTxNzo0EIMsizWXv8jNQXFwcqZBARBOQLe5cLhfS0tIiep6cHAnIZ7t8xkuSIL+EBN/BuBGCxtSejmXrxR4tgMqbYvjw4a2+HWbMmKGjQXfu3KmXvDqdLQfMtiWGyIetvECttW118G5QYX/jReocu8HLQBe7kIC8zyPhvZ46+AykDv4Yhzf/G/uX3o264k2aYm3heux4/nwkDTgVeTMWICl/ShfS5VDhRICf7+H0atCXriAQKZ/vXcGKY0QOgUj4niZyXg3OpLMI8PO9s8iy33AjYP/+XfSnSNOgzPnY59nR16BlRa+jvUSovRm12dDQYP2mNEKnymmRAAn0QAJpwy7E8BvXov/FTyMmfaBFoOrrj7D1ydOw42+XoPbAf61yZkiABEiABEiABEiABEiABEiABEigOxLo0QLoyy+/jD/96U96qXtLL54sd5Uky6EkWpSJBEiABCKNgEP9djBz7JUYefMG5M98GFFJudYUy7e8ji8fm4CvX/ku6g/tsMqZIQESIAESIAESIAESIAESIAESIIHuRKBHC6DvvfceXnjhBfzlL39p8TVbvny5Lh85cmSL9SwkARIggUgh4HBFI3vSjzDq1i/18ndXnG+fJK8Xh774OzY+Ohq7X78ZDRX7I2XKnAcJkAAJkAAJkAAJkAAJkAAJkEAPIdCjBdAzzjhDv8zvv/8+duwIjG5au3YtJEJU0g9+8AN95xcSIAESiHQCzpgE5J5yB0bN3oqcU37+/9l7EzDJzrLu+65Ta+/L9HT37FtmDdkIyQRIJoQBZRFUVCTqJXkvWV4Q/GRRP9RAJFzyqoBB8XtfIeol1yW+gl6CoCEmIWQPWSBkm8xk9sza09N7V1fXdr7//ZzzVJ1TXdXLrN3V/ye555w6z3POeZ5fVXdX/etexIn7ybOLeel/8qvywpe3ytF7/kjy6YF6R8H1kQAJkAAJkAAJkAAJkAAJkAAJ1AmBRV0E6Vd+5VdEK7j/5Cc/kVtuuUWuvvpqY3v37pX777/fPMUf/vCHZfPmzXXydHMZJEACJDA7AtFUm6x402el+7rflhMPfF76n75T3EJO3HxGTj78BTkFMbTn9R+X7tf+jkQTTbO7KEeRAAmQAAmQAAmQAAmQAAmQAAmQwEUgsKg9QLVC+5//+Z8b8TORSIh6fX71q18V9QhduXKl6bv55psvwtPCW5IACZDA/CAQb+5BbtA7ZNvvvCCdV/6GSMT7s1GcHJHjP7hNXrhjs/Q9/jdSzGfnx4Q5CxIgARIgARIgARIgARIgARIgARKoIFDXHqA7duyQhx56qGLJ4YepVMqEuL/3ve+VY8eOydDQkKxfv16am5vDA/mIBEiABBYxgWT7Gln7i38nPdd/Uo7d+xkZfuk7hkZ+/JQcuevj0vfoHbLsplul84pfh0YaXcSkuHQSIAESIAESIAESIAESIAESIIH5RmBRe4AGn4xYLCarV6+Wyy+/nOJnEAz3SYAESCBAoGHpVtlw8zdl8wcekZb1byz1ZIcPy6Fvv19e/JurZPDFfy8d5w4JkAAJkAAJkAAJkAAJkAAJkAAJXGwCFEAv9jPA+5MACZDAAiTQtOI1svG9d8nGW+6WxhXXlFYw2b9bDvzLe+Slv32tjOy7t3ScOyRAAiRAAiRAAiRAAiRAAiRAAiRwsQhQAL1Y5HlfEiABEqgDAi3r3iBbPvCwrH/PNyXVva20ovSxH8ver79d9vzDm2X8lR+VjnOHBEiABEiABEiABEiABEiABEiABC40AQqgF5o470cCJEACdUigfevPy9YPPS1rfvHvJdGxrrTCsYMPyu47d8i+b/ySTJx8vnScOyRAAiRAAiRAAiRAAiRAAiRAAiRwoQhQAL1QpHkfEiABEqhzAhHHkSVX/rpc+tHnZNXb7pBYc29pxcO7vye7/vdr5OC/3SKTA/tLx7lDAiRAAiRAAiRAAiRAAiRAAiRAAuebAAXQ802Y1ycBEiCBRUYgEo3L0u0fklf9P7tk+Ztul2iq3SPgujLw7D/LC399mRz+3kclN3p8kZHhckmABEiABEiABEiABEiABEiABC4GAQqgF4M670kCJEACi4CAk2iU3ht+Xy793d3Sg60Tb/RWXcxL/5Nflefv2CJH7/kjyacHFgENLpEESIAESIAESIAESIAESIAESOBiEaAAerHI49AEmAAAQABJREFU874kQAIksEgIxBraZQU8QS/93Zdk6bUfEvUQ1ebmM3Ly4S9ACN0sxx/4vBSy44uECJdJAiRAAiRAAiRAAiRAAiRAAiRwIQlQAL2QtOvwXiO5QfnDF35VvvDcx+Sb+/63PHXqhzKQ6avDlXJJJEACZ0sg3twjq95+h2z76PPSecWvi0Qi5pLFyRE5/oPb5AUIoX2P/40U89mzvRXPJwESIAESIAESIAESIAESIAESIIESgVhpjzskcAYEDk/skWeHHzUWPL0p1iIb2y6XdS1bZF3rNlnfuhX7W6WnYSU0D0/0CI7nPgmQwOIhkOxYK2vf9ffSc/0n5dh9t8nwS98xi8+Pn5Ijd31c+h69Q5bddKsRSSNOdPGA4UpJgARIgARIgARIgARIgARIgATOCwEKoOcF6+K56JGJfVUXO54flWdOP2IsOCDppOSStsuMMLoewqgVSHsbV0vc8cJig+O5TwIkUL8EGrq3yYabvynjR5+SY/f8sYweuN8sNjt8WA59+/0Ij/+iLNt5m3Rs+8X6hcCVkQAJkAAJkAAJkAAJkAAJkAAJnHcCFEDPO+L6vsHPdt8sl7e+VobiJ+WV9Muyf+RF2C55ZexlGcuPTFn8ZDEjLww+aSzYGYvEPE9ReIlaYVS3K5rWSyKaDA7lPgmQQJ0RaFrxGtl4y/dldP/9cvTeWyV99Emzwkz/S3LgX94jJ5e/2lSTb93wpjpbOZdDAiRAAiRAAiRAAiRAAiRAAiRwIQhQAL0QlOv5HoWILP3eJtm0/dXyhm0/L9HN5bSyx9OH5QAE0QOjLxlh1G5Hc0NTiOTdvLw8/KyxYKcjjqxu2RQSRddDJF3VfIk0xJqCQ7lPAiSwwAm0rL9JtnzgYRna9R05hpygmb4XzYrSx34se7/+dmlee6MpptS0avsCXymnTwIkQAIkQAIkQAIkQAIkQAIkcCEJUAC9kLTr8F7uEUcKd8el/+5JrG5SnPaINFwRk+TmqHRsXi49q1fJ63rfElr50ORpI3TuH90VEkgHJqcWTypKUQ5CQFWrbCvhHap5Rdchv2jQa7Qx1lw5lI9JgAQWEIH2rT8vbZvfIQPP/rMcv/+zkh06aGY/dvAB2X3nDtO3fOefSEPPpQtoVZwqCZAACZAACZAACZAACZAACZDAxSJAAfRika+T+xYPlD0+dUnFIVfGH8gZs0tMbIwaQTS5KSqpLVFp6+2Ua7pvMmbH6HY8NxoQRiGOQiDVkPqTE0eCw0r7R8b3i9pDJ/6zdEx3liR7TAEmW3jJCqRtic7QOD4gARKYvwQijiNLrvx16bzs3dL/1J1y/MHPS37spJnw8O7vyvCe76HvPSiW9GlJdq6fvwvhzEiABEiABEiABEiABEiABEiABC46AQqgF/0pWNgTiF5ZwAKykjjeILmXXckdLUIFDa8p+3JB1Eb9wxHUOkpcEi15iqq3aLTNkaZ4i1zZ9XpjwStkChOyb/j5Uii95zm6S46nD0rB1fuH2+nJk3K67x55HBZsrfGOKcKoepAubVgWHMZ9EiCBeUQgEo3L0u0fkiVXvVf6fvQVUxipkEEaDdc1HqIDz39Luq7+LVl246ck3sKf5Xn01HEqJEACJEACJEACJEACJEACJDBvCFAAnTdPxcKcSKTDldhNeensSko8Hhc350rmhYJM7s7DsN1TkMKgG1qcm0Ow/C70wWxzWsuh8yqIJtZExWmKmO5UtEEu7bzGmB2v21wxFwqhtzlGj4zvQ182ONTsj+QG5en+B4wFOzVk/pJWVKZv3SLrW7YhnB5h9RBGexpXiRMJe7gGz+M+CZDAhSPgJBql94bfl67XfEBOPvJFOfX4V6SYS+MLl7z0P/m3cvon/yjd131Eeq7/pMQaOi7cxHgnEiABEiABEiABEiABEiABEiCBeU+AAui8f4oW1gQjcQiZV8aM2ZkXRouS+aknimZUFIVJ3vZ62+IIQucfQug8zLbEBkeSm7x8oiqKxlc4Eol6oqiOiTtx2dR+hTF7jm6LblEOje6Bx6hXkd4LpdfK9HtlojAeHGr20/kxeXbgMWPBzoSTlA2tl3o5RiGMWoF0edM6iTn80Qmy4j4JXCgCsYZ2UwhJxc4TD3xe+p++U9xCTtx8Bt6hX5BTT35Veq//hCy97qMSTbBQ2oV6XngfEiABEiABEiABEiABEiABEpjPBKjizOdnp07mFm1BePv1aoh991vueEEmnlEPUc9T1ITOV4ii2X1Fye7Lyuhd/kl4taYuRT7RgCga65zqoalemypWqr1xhb2jtz0ytl/2Qxg9MPJSSCBVEbSyZYuTsmvox8aCfbFITNa26PU9T1EtwKReoyubNkgymgoO5T4JkMB5IhBv7pFVb79Dul/3u6ZQ0sCz3zBh8cXJETl232ekDx6ivTs+BY/R94sTS5ynWfCyJEACJEACJEACJEACJEACJEACC4EABdCF8CzV4Rzjy+DRCZO3esKEm0fo/Iued6gVRQunw6Hz6jWqnqRqtjnNEUldoUWW4CnqF1lSL9RabWXzelHbseznQkP6Mydk7/BzKLqkxZc8gVSF0uHsQGicPsi7edk78ryxYGdEIrK6eWOpIv06CKPrIJSuadkkrEwfJMV9Ejh3BJIda2Xtu/7ehL4fu+82GX7pO+bi+fFTcuSuj0vfo3eYQkmdV/yaRBz8zmEjARIgARIgARIgARIgARIgARJYdAQogC66p3x+LjgSQ+j85Qidh4kkzSQLYxBFn7W5RL2tOxmefxFj0o/kjdme2DIH1/FFURs6P40oqud1pXqNXdfzZnsZsx3JDnqV6Y0wqlXpPYFUBdPK5oorh8b2GLu/onN541rjMboeuUXVY1Q9SHXbHG+tGMmHJEACZ0KgoXubbLj5mzJ+9Ck5ds8fy+gB76cwO3xYDn37fSY8ftnO26Rj2y+eyeV5DgmQAAmQAAmQAAmQAAmQAAmQwAImQAF0AT959T71KLw7m14XN2bXmjup+UR9URSFlrKvoOR8Reh8/nhRRtXu9vOJwukrtU1D58uiaKxraui8vUdw25rokKuX3mgseFxD5sseo1YY3SUn0ochg1Z4ruLEY6hYr/bICRvP712tM9ktl7RdhuJLCKdHGL233SYdya7g7bhPAiQwSwJNK14jG2/5vozuv1+O3nurpI8+ac7M9CPtxb+8R04uf7Usf9PnpHXDzllekcNIgARIgARIgARIgARIgARIgAQWOgEKoAv9GVxk84/3OBL/mYS0/Iy3cLfgehXlUW1eiytlIIoWTlUIkIiYzzyHPpiIVx3eQW2UFLxNg6Kok6odOl+JWUPaL1/yWmPBvslCBl6iLyCM/iVsy0WYjo0fMKHzwbG6PzDZJ0/03Wcs2NcSbzfCqIbQmxyjvkC6NLVcIpHZzzN4Te6TwGIi0LL+JtnygYdlaNd3TE7QzKldZvnpYz+WvV9/mzSvvdEUU2patX0xYeFaSYAESIAESIAESIAESIAESGBREqAAuiif9vpZtFaFT70qZsyuqph2ZaIUOq/CaF7cCdvrbYsoBp9+DKHzMBEvrj7WrflEy6JoYjWqzs8QOh++KoL3UQRpa8fVxoJ9+WJeDqooOooQegijBxBKr/tamV6LLVW20dyQ/KT/IWPBvlS0UTbCY9SG0FuBdFnjGtHiT2wkQAJhAu1bf17aNr9DtEjS8ftvl+zQQTNg7OADsvvOHaZv+c4/kYaeS8Mn8hEJkAAJkAAJkAAJkAAJkAAJkEDdEKAAWjdPJRdiCTiNCJ2/DqHzMNvyp4oyYUPn4S2aO1wQ13MGtUMk3+fK2D05Y+Yg9MTkFg2bj0oKRZYSCKFXD9QzaTEnBo/OVxkLnl90i0YEVW9R6zV6AMLo4bGXpVpl+kwhLc8N/MhY8DpxJ4Hwea8avS2+pJ6jK5rWS9wpcwiew30SWCwEIo4jS678Dem87Fel/6k75fiDn5f82Emz/OHd35XhPd9D33tMsaRk5/rFgoXrJAESIAESIAESIAESIAESIIFFQ4AC6KJ5qhf3QmNLHWl5E0Ln3+RxcIsInX8J3qF+6Lxu8yeQTzTY8HBSK9PDRvzQ+UgDQucvg8cpRFFTeR5bFVzPtKnXplaJV7up4iLHxg+aMPqyMIochhBKx/IjFSNFcsWs7B5+xliwMxqJyprmzV5l+laE00Mk1Vyjq5ovkVQUi2EjgUVEIBKNy9LtH5IlV71X+h7/azn5yJekkBkScV14iP6zDDz/Lem6+rdk2Y2fknjLskVEhkslARIgARIgARIgARIgARIggfomQAG0vp9frq4GgYiDcPdtEDJhthUnUHX+ORRYsqIoQuc1VD7YNJR+4om8MRs6H+1CBftA6HwcofNO8sxFUXu/5U1rRe36ZW+zh8x2INMne0eeMxXpg56jQ9n+0Dh9UHALCLVHLlKYHA13qwi6zlSl1+JLKoxukdXNm1iZPoyJj+qQgJNolN4dfyBd13wQIugX5dTjX5FiLi2CVBX9T/6tnH7m69K9/bel5/pPSqyhow4JcEkkQAIkQAIkQAIkQAIkQAIksLgIlNWfxbVurpYEphBwGiLSeG3cmO3Mn/arzkMUzaDIUu4QQucrUnYW+hE6fx9C52Gmaei8qThfrjwf642cs+JFnaluuTa1U67tDlexHs0OycsQRjW/qIbR79c8o/AYPZU5ZpcT2mr+UbUHj383dLy3cXVJGA0KpC2J9tA4PiCBhU4g1tBuCiF1X/cROf7An8rpp/9O3EJO3NyEnHz4C3Lqya9K7/WfkKXXfVSiCVROYyMBEiABEiABEiABEiABEiABEliQBCiALsinjZO+UARiSxxpfmMC5t3RRahs1hdDteq8CZ0/jlj5YOF5DZ3X8HqYbZEUQudRrEnzidrK89GWs/cStdfXrQqUr+66wVjw+ER+HB6jz0MYRQi9eoP6Aunx8UNSxH+V7UT6sKg9dvLuUFd7ossUYNIQeiuM6nZJqic0jg9IYKERiDf3yOq3f1l6XvcxFEr6rCmYpGHxxckRU0G+7/G/gcfo/ytdr3m/OLHEQlse50sCJEACJEACJEACJEACJEACi54ABdBF/xIggLkQiEQifu7P8o9OMYPQ+RcQOq+CqC+KFkeCiij00QxC559C6DzMtugShOEjn6hXZAkFltYgn2jq3Iqieq+GWJNc1rndmL23brOFSRMar8KohshbgfTI2H7Ju743a+AEDbF/8tT9xgKHpTnWiuJOl0EU3YIwer8QE4TRnoaV58zrNXg/7pPA+SKQ7Fgra9/19yb0/dh9n5Hhl/7D3Co/3idH7vq49D16hymU1HnFr0nEiZ6vafC6JEACJEACJEACJEACJEACJEAC55hAWcU5xxfm5UhgsRBQ0bLxaoTOw2zLDyB0/tlyPtGshs4jf2iwFU67Mv7DnDFzHNpnYqPnIeoVWYpKbJkDoeXci6J6v0Q0KVvarzIWnFceeRAPj+0x4fPWW1S3R8b3SqZQsQicqEWZnjn9iLHgdbTI0vrWS5FfFDlGIYxagVTzmmpxJjYSmK8EGrq3yYabvyXjR56UY/feKqMH7jdTzQ4flkPffp8Jj1+28zbp2PaL83UJnBcJkAAJkAAJkAAJkAAJkAAJkECAAAXQAAzuksC5IhDrROj8GxA6/wbviiZ0fm8RHqJlUTR3DOHnwQh0OI1qeL3a6Pe88yJJhM5fGgydj0q0DUlGz2OLOTEjWKpoGWy6hiPj+4wwaivTqzCqYul4fjQ41OyrWPri4FPGgp2xSNxUoldhVMPprUC6snmDxB2GFwdZcf/iEmhaeY1svOX7Mrr/fjl67x9L+uhTZkKZfqST+Jf3yMnlV8vyN90urRvC+Xgv7qx5dxIgARIgARIgARIgARIgARIggUoCFEArifAxCZwHAiZ0Xr07YbYVs65MvqBh854oqkWWikMVofMouDTxY4TOw2yLdpRD5zWfaGItQucbz4+XqL2nbnUNWjle7UZ5Z7BLjiNnaLn4EsLpRxFWjwJMo7mh0Dh9oOH1Lw8/ayzY6Ygjq1s2lbxFrdeoVqZviDUGh3KfBC4ogZb1N8mWDzwiQ7u+Y3KCZk7tMvdPH3ta9n79bdK89kZTTKlp1fYLOi/ejARIgARIgARIgARIgARIgARIYHYEKIDOjhNHkcA5J+AkItJwVcyYvXhhWEPnteK8l1M0exCh82nb620LgwidfxCh8zDbEpfY4kreNr4CofPR8y+K2vsvQ+V4tdf1/qw9ZLaDk/2yd/g55BjdJQe1Kr2pTv+iDEz2hcbpAy3IdBDCqVplW9m03hReMh6jfjj9mpbN0hJvqxzKxyRw3gi0b/15adv8DlMk6fj9t0t26KC519jBB2T3nTtM3/KdfyINPZeetznwwiRAAiRAAiRAAiRAAiRAAiRAAnMnQAF07sx4BgmcNwIa3t50g1o5n+jkPq/avPEUhZdo7iji5ssF5s1csnsROg8b/S9vaogyl6SGzsND1BZZinac39D5alA6kl1yTfdNxoL9o7lh2Tf8vBFEreeobk9MvBIcVto/Mr4f4ff75aET/1k6pjvdDSsQQl8uvGQF0rZEZ2gcH5DAuSIQcRxZcuVvSOdlvyr9T90pxx/8vOTHTprLD+/+rgzv+Z50Xn6zLHvDrZLsXH+ubsvrkAAJkAAJkAAJkAAJkAAJkAAJnAUBCqBnAY+nksCFIJDcABETJm/18mO6OVSdf7EcOq+V5wsDFaHzcA7NPJM3ZufotMLj9PKYJCCKapGlxDqEzjddOC9ROw/dqufmlV2vNxY8PpFPI3T+hVIIvXqMqjB6bPyA8RANjtX9vomjxh7vuyfU1Z5YIhtaX4Uco1uMQKrC6DrkHF3asCw0jg9I4EwJRKJxWbr9Q7LkqvdK3+N/LScf+ZIUMkj5gFy5Az/9hgw8903puvq3ZNmNn5J4C193Z8qZ55EACZAACZAACZAACZAACZDAuSBAAfRcUOQ1SOACEojEIWRegdB5mG2FEYTOP1cWRbMHEFA+FhZFiyMInX8YofMw2xLrHHiIlossxVcidD52cURRnZPm+ry08xpjdo66zRWzJjReiy5pblGbY1SLMmlfZRvKnpan+x8wFuxrirVUCKOeQNqL8H3NccpGAnMl4CQapXfHH0jXNR+ECPpFI4a6uQnkdMhL/5N/K6ef+bp0b/+I9Fz/CYk1dMz18hxPAiRAAiRAAiRAAiRAAiRAAiRwDgiUFZRzcDFeggRI4OIQiLYibP71auXQec0fqt6htshS9hWEzpdrKZmJqlCaPZCV0e/788ZvhNRWDZsvi6KxrgsfOl9JUavDb2y73Fiwr+AW5PDoyxBEIYqOoPAStl5l+pclU6hInooTtVr9swOPGQteJ+mkvOJLpir9tpLn6PKmdRJz+GsyyIr71QnEGtpNIaTu7b9twuJPP/134hZyomLoyYf/AuHyX5We139cll73UYkmmqpfhEdJgARIgARIgARIgARIgARIgATOC4GIi3ZersyLGgK/8zu/IydOnJCvfe1rdUdkcnJSCgUvGWUqlRIHufHY5i8BF+Jn/mXYPthepBGFFQdmnm+kWSS2FbYBdolIdLWIg2PzuemvteMTh+TQ+G7YntL2lfTLEEFHZj31aCQmq5s2ypqmzbBNsiy2TtYilH5t2yZJOMlZX4cDFx+B3PBhGXjsz2XsxW9h8eU/s9HGpdKx/WPSevlvolCZl9ZiPtLJZrOSz3vfmCSTSYlGkYaDjQTqmMDExIR5nScS8/fnso7xc2kXkEDw97u+3mMxftF7AfHzVheBQCaTMZFe+n6GjQTqmUAulxM1bfX4+131pxtuuEFuv/12efe7331GTyX/4p0RttmfpEKMmr7ZqLdWLMKj0G/6g8YQYktjHm8hYkbVfsabozsOIXR3RAr7HSnux3YfwsAnw6Hg7hhC0J/0zK7MWVEUZ4Mr0fWuOGrLXYTO2975se2KLZeutuVyddtNoQmdmjwmKoQeSu+RwxBH7f5ofjA0Th8UoBofGEMeUliwOeLI8oZ1sqoR4mjjJlkN0/1VjZdIKtoYHMr9xUqgoVc63vglab7yf8rwY38mEwfuNiQK6VPSf/8fyuBT/5+0XfsJadzyS/jdOf++PLJfbumkVQgNPl6sTynXXd8E9L2avs7r8f1afT9zXN1cCQR/n+vv9+D7+blei+NJYCEQ0Ne4fk7l7/eF8GxxjmdDIPj7vB5/v5+Ln+F5JlmczdM9P8/Vb1XjcRTLWLp0fk7wLGY1ODgo+o2ato6ODrPOs7gcT70YBPRluTZ849wJzSea98Ln9+Qld7iIMN7wmOJRCKZHIYw86B+Hc1hyi1dcKbnJC5+Pdc8/UUdnuxT/bZMrwgvCo6HJ07JvBJXpkWf0AIovedsXpT9zYspYZFiVIxP7jD122uYP8IYtb1yLEPqtKL6Ewkt+8aW1LZulNcH8j1NALoYD+N2/fPN/yPiRJ+XYvbfK6IH7zaoLo0dk4L6PSfrZr8rynbdJ+9ZfmFc0hoeHJZ320ki0tbUJvSbm1dPDyZwHAn19feZ1rq93NhKoZwIjIyMyPo5vwNFaW1uloaGhnpfLtZGA9Pf3Gw9//bzKRgL1TGBsbExGR0fNEltaWqSxsb4cc9QDVNvZRB5TADUI+Q8JkIAlEO91JN6bkJY3e0fcguvnEvVzikIUzZ8sh/SaUciEMPkC+mEinrez0xyR1KWaT9TPKYrq805j2LvU3nM+bNuTS+TqpTcaC85nPDdqhFEtvPTc8SflaHa/8Ro9kT6MwOYKDjjxWPqgsUdO3BW8jHSllpk8o1YYtduOZP19ORJaOB8YAk0rr5GNt3xfRvb/wAih6aNPmeOZUxDb/++vSuPyq2X5m26X1g07SYwESIAESIAESIAESIAESIAESOAcE6AAeo6B8nIkUG8EIlEImdtixuzaimlXMs/7XqJaaAmiaNFzJrBDTBX69I/yogZ51ByP9eBar/ILLKHQUnw1gskT81cU1Uk3xVvk8iWvNbY99VZpamoS/UYtU5hA4aVyRXpbmf7o+H6Eznu5cc2i/X/6M8fhTXpcnui7L3hYWuMdsqHtVbKuBRXpW7eVPEe7G1aExvFBfRBoXf9Gaf3AG2Vo17fl2H23iQqg2tLHnpa9X3+bNK97gymm1LTy2vpYMFdBAiRAAiRAAiRAAiRAAiRAAvOAAAXQefAkcAoksNAIqCdn47VxY3bu+b6iTGjo/B7PUzR3qCBuRepb9RwdO5mTsfv8mHpEyXseovAShYeoVp9XkXQh5JNNRRtka8fVxiwD3eaKOTk0uhsV6RFKrwIpQup1/5WxvZItekJwcPxIblB+0v+QseDxxlgzxFCtSI9wegijViBd1rhGnHmYMzI4d+7PTEBD3ts2v1MGnv2GHL//dskOHTQnjR34oez+2g3oewdC4/9EGnounfliHEECJEACJEACJEACJEACJEACJDAtAQqg0+JhJwmQwGwJaM7Plp0InfcjeE3o/Ms2bN7b5pFfNBQ1joeTu9AHsy2CVCWpS30vUV8UjSKcfqG0uBOXS+DRqRZsRbdoRND9Ia/RXRBL98hEocJ9Fiem82Py/OATxoLX0erz65BfdL2fX9QKpCua1ovem23hEIg4jiy58jek41Xvlv6n75QTD/4vyY+dNAsY3v1dGd7zPem8/GZZdtOnJdmxbuEsjDMlARIgARIgARIgARIgARIggXlGgALoPHtCOB0SqBcCJnR+C0LnYbYVJxA6/0IwdL4gxdFwHk0XdVcmnswbs+dFl3qh8ynNJwpRNL4W+USTC0cU1XWo1+aalk3GbrIL87fHxg+WCi9ZgfQgco6O5oYqRiLDKrxIdw8/YyzYGYvEZHXzJs9btBXh9MZ7dIs5loymgkO5P88IOLGEdG//sHRddYv0Pf7XcvKRL0ohM4wvC1wZ+Ok3ZOC5b0rX1b8ly278Q4m39M6z2XM6JEACJEACJEACJEACJEACJDD/CZSVifk/V86QBEhggRNwGhA6/xqEzsNsy/ej6nwgn2j2IELnKyLFC6dcGb8/Z8ycp6HzG23YvIbORyWG4k0RZ2GJopbB8qa1ovb63rfaQ2Z7auJYSRi1lelVIB3K9ofG6YO8m0eo/YvG5Gi5GwkFZGXzhpLXqBVG1zRvNvlNyyO5d7EJOIlG6d3xB9J1zQfl5MNfkL4ffUXc3IRIMS/9T/6tnH7m6xBKPyI9139CYg2sZHqxny/enwRIgARIgARIgARIgARIYOEQoAC6cJ4rzpQE6pJArMuR5jckYN7y3KIr2X1+6LwWWILljlUJnff75LveeZEGhM6jWJOXS9QTRaOtUEoXcFvasFzUru0OVwYfyQ7K3pHnTX5RK4zqtm8ioHz669ZK9Zp/VO3B4z4sv6+3YRVyjKLwkh9Or9u1KMbUluhcwNQW/tRjDe2y4s2fk+7rPiLHH/y8nH7678Qt5IwYevLhv5D+p74qPa//uCy97qMSTTQt/AVzBSRAAiRAAiRAAiRAAiRAAiRwnglQAD3PgHl5EiCBuRFQL87kRgiZMPk579xixkWe0LxkXoIg6hdZKg5XhM7DUW7iaYTOw2yLLglUnUfofGIdQudTC9NL1K5Jt62JDnl11w3Ggsc1b+i+kRcgjL4Ez1F4g6IAkwqjGmKvQmhlOzHxiqg9dvLuUNeSZE+p8FJQIF2S6gmN44PzS0DD3Ve//cvS87rfRaGkz6Jg0j+bsHgNjz9232cQLv830nvjpxAe/z7RMHo2EiABEiABEiABEiABEiABEiCB6gQogFbnwqMkQALziICKlg1XxY3ZaeUHAqHzEEWzBxA6DxE02AqnETr/AELnYaZB+0xs8LxDTfV5zSe6YuGGzgfXqvtaOf6yzu3Ggn2ThYxoTlEVRDVM3gqkR8b2mdD54FjdPz15Uk6fOilPnro/1NUSb5cNrZeaivQqjNrK9D0NKyUSWfjCcmix8+iBFkBa+65/QOj77xnhc/il/zCzy4/3yZH/+pj0PXqHLHvDrdJ5xa8jDcTC9nqeR9g5FRIgARIgARIgARIgARIggToiQAG0jp5MLoUEFhOBWCdC53cgdH6Ht2oXBWOy+4sImS8XWcodReg8/i81OEFm90IshY3+p3c0kkQ+0a1e1XlbZCnaUV8ikhZB2tx+pbESC+zkkVvy8NgeCKMQRY1A6nmNvjL2skwWM8GhZl+LMj1z+hFjwc5UtNF4jK431ek9YVQFUs1rGo1Eg0O5fxYEGrq3yYabvyXjR56UY/feKqMHPIE6O3RIDn37faZ40vKdt0n71l84i7vwVBIgARIgARIgARIgARIgARKoPwIUQOvvOeWKSGBRElAPxKR6d8LkbR6C4iRC5zVsPiCKFgbDoeBacCnzDMLrYai7bVq0ww+dh4eoeoqa0PnG+vNwjDkxT7iEWBlsRbcoR8f3h4RRFUjVi1TD7CtbppCWFwefMhbsizsJk1NUhdF1yC9qBdKVzZdI3CkXwgqew/2ZCTStvEY23vJ9Gdn/AyOEpo8+ZU7KnIKH7//9VWlcfrUsf9Pt0rohnDt25itzBAmQAAmQAAmQAAmQAAmQAAnUJwEKoPX5vHJVJEACIOAkETp/RcyYBVIYQuj8CwFRdD9C59O219uqSDr+EELnYbYl1jtSWBWX6BZXklcUJL4SofPR+hNFdb1OxJFVECnVbpR3WgRmezx9OFB8yfMcVWF0ODsQGqcPcsWsvDz8rLFgp3qFrmreWK5M74fTr2nZLKkoqlmxzYpA6/o3SusH3ihDu76N0PjbRAVQbeljT8ver79Nmte9QVZACG1aee2srsdBJEACJEACJEACJEACJEACJFCvBCiA1uszy3WRAAlUJRBtd6Tp9WqeB6KGzucOaeh8AUWWED6PfKK5VxA3XwifruH1sj8mYw+4Mob/Iqg5k9yiHqJe+LxWn48tqa/Q+TAB79GyxtWi9rrenw11n86cNB6j+1F06aDJNQpvRITWD0z2hcbpg4JbMN6kKpzef+zfS/0RiciKpnVGGFWP0XUmpN6rTN8cby2N406YgIa8t21+J4okfcMUS9KQeG1jB34ou792g7Rteacs3/knoiH0bCRAAiRAAiRAAiRAAiRAAiSwGAlQAF2MzzrXTAIkUCKgofOJtQhzh7X8rFdJ2825XsV5iKImfB6iaKG/InQ+i9D5ZyGawmxz2hA6f2lAFF2PqvNN9eklatdst1ohXu2a7pvsIbMdzQ55lekhdnq5RlGZHgKpVp+vbFqp/ghC79UeOuEnafUHdTesQAj9NoTse8KoFUjbk0sqL7MoH2vxoyVX/oZ0vOrd0v/0nXLiwf8l+bGThoUWTRre/V3pvPxmWXbTp0WLKrGRAAmQAAmQAAmQAAmQAAmQwGIiQAF0MT3bXCsJkMCsCETiCJ2/DKHzMPh5mnMKI0U58XC/RI8kxT0QNQWXimNhUbQ47Er60bwxe6P4GsfkEVVPUS2yFF+F0PnY4hBFlUFLol2u7Hq9MctEtxP58Sk5RlUgPTZ+AHWrgpWrvLP6Jo6K2uN99wQvI+2JLq8yfesWI5BaYXRpw7LQuMXywIklpHv7h6Xrqluk7/G/NoWRChlkt4Wn88BPvyEDz31Tul7zPlm241MSb+ldLFi4ThIgARIgARIgARIgARIggUVOgALoIn8BcPkkQAKzIxBtdST66qI03eBIS0uzOSl7WD1EreUlexjCXT58PQ2vVxv7bz+fKH7rpkzoPDxFN3nh87Gl9R86H6Yi0hBrkks7rzEW7MsWJuXQ2G6Io14Iva1O/8rYXsm75Zys9pyhbL883f+AMXtMt82xVhRe8jxG1XN0nS+Q9iJ8X71+6705iUbp3fEH0nXNB+Tkw1+Uvh99RdzchEgxL/1P/B85/ZN/hFD6Eem5/hMSa+iodxxcHwmQAAmQAAmQAAmQAAmQwCInQAF0kb8AuHwSIIEzJ5BYjdB5WMubvWto6Pzky1YQ9cLn831hL1EVSDPPI3QeJoI4ejSnFaHz27yK8yqKJjZAbG1ZfKKoskhEk7Kx7XJj+ti2PIQ7FUEPjKLw0gjC6bFVkfTw2B7JFCDsVbSx/Ig8N/C4sWCXFlnS3KLWU1RD6lUgXdG8XrQ4U701FTdXvPlz0n3dR+T4g5+X/qfuNCKoiqEnH/4LPP6q9Lz+E7IU/dFEU70tn+shARIgARIgARIgARIgARIgAUOAAihfCCRAAiRwjgho6HxqG0LdYbYVRiGK7kJxJVNkqYDQ+YIUR8KiqD5OP47QeZjIpDlVQ+WTCJn3DKLoaoTO4/qLtcWcmPHiVE9OWVGmoEWsjiJs/gCKL6kgagVSLbCkImhlU7F019CPjQX7YpG4rEUV+rIwCq/Rli2ypmWTxB0vN2xw/ELb13D31W//svS87ndNoaSBZ//ZhMVrePyx+z6NcPmvSO+Nn5Kuq98nGkbPRgIkQAIkQAIkQAIkQAIkQAL1RKD8Kb2eVsW1kAAJkMA8IRBtiUjjtXFjdkrZI0EvUVSdP1RAeLLt9bZaiV5t7N5y6HxyoxVEdRuTeM/i9BINktJw9pXw3lS7Ydnbg11yMn0kIIx6xZfUc3Q4OxAapw80vH7vyPPGgp2OOLKq+RIjjK43nqOeMLoW4mhDrDE4dEHsawGkte/6B4S+/x6Ez8+IFkjSlh/vkyP/9THpe/QOUygpujbMckEsjpMkARIgARIgARIgARIgARIggRoEKIDWAMPDJEACJHC+CCRWInQe1rLTu4Obh5fo3rAomj9RUQgIzqGTuzAGZpvTHJHk1oAouiEq0TaKopZPT+NKUbuux89R4HcMTvbDW/QF32PUeo7ukv7McXtqaasFmQ4hzF7th/Kd0nHdWda4BlXpkWc0EFKvHqQt8bbQuPn4oKF7m2y4+VsyfuQJOXrvrTJ24IdmmtmhQ3Lo339L4p2bpPk1H5fU+rfMx+lzTiRAAiRAAiRAAiRAAiRAAiQwJwIUQOeEi4MrCURPZqTtL3dLpKdJit3whupqEFnaIBF/ax63xBdF0ZFKNnxMArMloFXhU1sQOg+zrTjuSsYPnbeFlqZUnUcV+okn88bsebHlTqDIEqrOr42Kk1i8ofOWS3DbkeySq5feaCx4fDQ3jPyiyDGK8HmtSO+F1O+S4+lDwWGlfT2u9siJu0rHdKcrtcwIoxpCHxRIO5JLQ+Pmw4OmldfKplvulpF995lQ+PTRp8y0cgN7ZPC//6c4DV0y2LZSYqlWiTf3SLRxCYomdRrz9jskhmNR5BqNNaCvsXM+LItzIAESIAESIAESIAESIAESIIEQgfKn7dBhPiCB2RFwTk9K7BgKkMCCWQ2D+6Lay3IU14AoGoE4WlUkbU1IJEqRZnbUOWoxEHCaEDr/GoTOw2zLnSyW8omqKJo9iNB5L2WoHSL5YwibV/uBHzqPuj7JSwJeopuiEluGfKKLoBJ6Ccosd9Rz8/IlrzUWPGUinxbNKerlGS0LpEfH90vBLXvk2nPUk1Ttib777CGzbUt0QhC91OQWVWHUCqTdDYGkpqEzLtyD1g07RW1o17chhN4mmVO7zM2LE/2Sgc2lOYlmiKW9EEs9oVRF0agvmnpiKY6bPl84hYCq5/A1ORfKHEsCJEACJEACJEACJEACJDAXAhRA50KLY6cQcMbz4kK3jIQUz4ph2nd03FhwWHDfnNHreZCGRdKU8SiVtqRElrFCcQVZPlxkBDTnZ7wnIc1v8BbuFlzJ7kNY/B4vfD7zUkHyxxE6H/zhgj5nPUgtrgh+1FJbY+UiSxo638HQecuncqu5Prd2vNpYsC9XzMqh0T2oSO/lF1XvUd0/PPayaF9l09yjP+l/yFiwrynWUqpMHxRGNcTeiVzY56V96y9I2+Z3ypHHvyaDT/0fyQ/uMVXjg/Odab+YHZPJgb0iU1OtTntqrKl7ijepEU59IVUF1WiyVWJN8ERNthiR1YnjbwQbCZAACZAACZAACZAACZAACcxAgALoDIDYPT2ByWuWyKl/XCJd+UaJDeXEPQVv0H4Ytm5/xmzN49PYn6mdSIvAgtpNcN+cDk9RWQFPIeNJ6ouj1rPU9y6NOPQknQk1++uDgHpNJzdByITJz3lrKqYROv+SV3XeCp+VVedd/KhNPI3QeZhtsd5g1XnkKF2H0Pkkf5Ysn2pbrQ5/SdurjAX71Sv0yNg+E0av4fTqOXrAVKh/STIFwK9o4/lReX7wCWPBrqSTQmV6DaPfGhJIVzZtkJhz/v58RxxHWi99j8TWvdNMp721SZzcoBTSA5KfgGFbmDgd3k8P4vFpHMc2rds5qp+4kxZiUptTc5DmAd6mMYTgR00IvoboY98P1a8UUE2YPrxRI9Hzx29O8+dgEiABEiABEiABEiCBuiFQdIsmQqyIzwO6722xr//hmH5OcKuMMccxRrelc4Lj/POD1628VjozIemJcdnR5b2Hrxuo53Ah/ARwDmEu6kvBezOyCrk+p4HgDiFW99gYRNEMxFFPJFVxNCiahtTPatcagVfVyIC4XnRmaURIKG1CyPAKeIsGc5EG91UwjV9Yr6rSRLlDAueZgNOI0PlXI3QeZlu+vyiZF8uiaHZ/ldB5FF3SwkvjD/ih8/gRSawPhM5vhtCE/KL8gsFSrb2NRqKypmWTsZsCw1zXNTlDvVB6Lb7khdPr4zHkH61sk8WM7B5+xliwLxaJyermTV5leoij61sQTt+6RdY0b5ZENBkcek72nVhSkk1rRNphc2iFyTHJjZ0wYmhZOPUEVE8s9cVUCKZ5FU4hoKr3KN4Vzv4uxYLkRo4am/1JiFqIpcrCqRFLrWgaEFCt56nNeQrvUwqnc6HMsSRAAiRAAiRAAheDQFlEqyG6TSfGiSfAVYprVswzx0NCXcU9ZiHUTSsG4v6V858i+s3i/rXmb641w/or7z/lWlXWmHfLjiUX4zm394xFEhRALYwqWwqgVaDw0OwJDA1G5b/+bYm0tkWkBYWPW1pgrSLNMLP1Hzcg5Dbajg/mami1hFJ3DAKnhssbD9IKkdR6l6Ji9rRtHALOniFjwZHBfUkhMSI8SY1I6nuOlgVTeJaqSJrij8e0nNm5YAjEuhxp3oHQ+R3elN0iQuf3I5/onrIomjuK0Plg4XnsZ1GZXm30P73zIkjhm9ysxZp8YRT5RKPt/DJhti8EzXG5vGmtsdf3vjV02qmJ4/AULRde0gJMKpAOZafm39Q3WPt1LOy+o+XLOOLg19p64y1qvUZ1q16kjTH8vrvALZpsRqj6JXO6q4rE+fFTIW9Sz+PU8z5Vz1J9bL1MPWH1tLj5WUQZBGai47NDB40FDs+4a3OZevlNteiT73mqRaBMMSjvmHqa2hyozG86I1YOIAESIAESqDMC+vfciEbTCVXW062KmFQSoPy+KQKU71lX6x7WC8/F+cMjQ0jZ5krDUEN1D7ya9zgTrz0VAwNefDXWFvIArHH/2mtTgTIgOuJ8y0u3bIubgAq8bLUJUOGpzYY9syCQHotKelwN0evHpj+h2RdDg8JopVDa2JgQZzPC3Dd31BZJJ/DtylH1JNUwe18kLe3jQ7Aem5zhBz+D/n3wuIIFhdHgviQg7KhIakPsu7yQ+2CF+4h6m7KRwAIjoF6cpjASiiPJ27zJFzOuTCKHaFAULQyGfiLExY9W5pm8Mbvk6BJUsN9WzieqXqNOqtZXHPYsbisJLG1Yhu9glsm13TtDXUOTp43QeXAElekDAmnfRED59M/Qb9NfGdtr7MHj3w1dp7dhFbxEy4WXrEDamugIjbvYD1Qkjjd3G5vLXNxCXnLjJ0sh+MbD1A/LLwmofgi/J6J6IfxSnNu39XquCe+fS4Q/1hRrXOoLpIHCUL7nqSeWQkD1Q/ijKqZin/lN5/IK4FgSIAESmErAE4mqC0VWQJrOs8wIUFXErCnHfTEq7Fnm3dfex5wTEKpCx6vcQ6+l5wTnp3/n7fGQgFZVDDu7+0+5t85lDvef+mzwCAksLAIa0eXAdBuBk4F9rPn59bhn3n6tMaVzcH7pWji/dDx4rdCYSGnMdNeOBK+F8/M5/Jzmwp/fFhb18z9bCqDnn3Fd3yGXww9nFN/wFWYWPMZGRdSOT/3cHmI0RSCFcBoUShubYtKyrl2cS9pri6QqgJpwexti7+UjLQmmKpKmZ/jgm4UL3IERY8FfI8F9iWHdy1UkTdWucN+C1ACsuB16jvlg/hFQ0bLhypgxO7v8ALxEXwyIoii4pCJosBVOuzL+UM6YOa6h82s1n2hZFI2vQOg88pWyzZ1Ae3KJvDp5g7y664bQyeO5USOIHoAwqp6julWB9Nj4QXypE/otZc47MfGKqD128u7QdZYke5Bj1BNGVSC1wij8fEPj5vsDDU1PtK4QUZtDK+Yyfpi+F4Kfh2hq8pv6Yfnevu99agXUSXx5htD7WTfj1Xom+U1jEIJ7IIai+JOG4atgqoWg/JB8z+PUep6WBdQI8qKy1SagXkm22Z8V3eqH/QIE8bwvits+W1XOnlc+rj3etWyfHavXr+wrPfbPMXPw51Ktz17T9tlr2+Ohe0yZh9cbGlNxr2CfTTtRvlft+dt5mPMrrhk6v8TZZ2TnGFi/XUv5vMBzU+Pa9hy9v52LPT/YVzpm71sxH+/s8PNnzwn2VbIJjamYo52POb+iz54XnKMdX62vdMzyqrhecI72mvYc7Stdu+I8XfHERFqG00OSRZqV5FBSokgLZcW4oNhmBDATCltDdPPFMHtONcFMJbOZhToV+axY5+2XrjWL++vYavdQsY6NBBYygQg+6c4slE0V0yoFM/O4QiirKuBNGRO+dhQpmFT8m6sYWOv+U47j2qV56V188dE7FhAQIfTpuVOOT5l/QMCs0lft/prffyG3sbExGR2F4MJWkwAF0Jpo2DEbAmvWT8r/+MgJaWvrkvHRuBE4R6EZqtCp28p9OOnM2Ox5sxJKNdTeCqR2qyH4LVFp6WqTxtVtUuuzoJvDGyMVSVGsKZiHNCSSjvr5EGvNWsPxD2OxsPLbdvu20z9JI4S1gn3JkxRxxBU5SQXFnSgQ1YLM4xeLQKzTkdj1jjRd73k6a+h87hDyie7WqvNe+HzuFfwcBT9jYF/D67P7szJ6lzfzCDJfJJFDNCiK6rXZzpxAU7xFLuvcbix4lUxhApXpdyN8HiH0vjCqAql6huqHxMp2evKknD51Up48dX+oqyXWLisbLpHWGIS1ON7wRiGqVXyQ1hPsB+65fQAv/7a059nfmvZ65toV9yv1+cdD958icpTnVrp2xfVC55euGZhbAvt4H+y2esdcIwovx52WGQHUhVBWVLFMvWJ0C1HUPnax7yJVgbfFvnkc/EHRu9uZYcf/fqB8d+3T5+uwb+Y2+KOKh/izZZsdb7fmuH7hhg8GSNiLL98chP3hI5TZhh9rPzrMuPL1yleyvM/oOdILVvCeej1do72fty3fq9ynY3JFpMdhIwESIAESuOAEIDvNSmiqJiZBpgqIWPY6emyWYlbp3uFz7PlGAPPH1Lq/Hp+YyJjikU2NzVPWUl5f+B7meipAouikjgl52vnzr7x/aF46BuvX68xWqLPna653Os9c8Jc6b7hICFAAXSRP9PleZhz6yNIez6a7Vw6fYYYGawukVjidk1A63Q3RV8pJGhJI9bgDa5XmTa3SeKVUFUrdAj6UHUd8f0WxppBIqoWZpn6uLc9K+zSvKcx+1NPO4L4ZjEJSU0XScqV7zZ8aiVE0Mqz4z0UhoKHzWh1eTd7ifUNanETo/B4VRMuiqHqFBpuL+meZZwvG7PFoB8LwtwZE0Q14g4gCTmxnRyAVbZDN7VcaC14pV8xBBH25VHhJ84uqSHp4bA+8gPAEVbTR/JDsGn2q4igfzpqAvpTVLsqvbP35q/Jtox4O/2jiABsJkAAJzH8Cnhg1N68vKyaVBCiVsSBGmWtBnCodn0GM0+vM9f5T74H3OGd4/6g/P3v+bMS0yvvXmv+Ua2GOOrbMqT7el/X39yNiMSodHfMr7c/8/8njDEmg/ghQAK2/53RerygOzWQuQmmlB6kVSO32vAilxoPUE05bWiPwJm2Wlu5mad4g0giNstKjVL3i5GS6ikjqhd2bnKRDEBhUTJ2uncA1YMFRwX1zql+wKWK2ZXHUPLZ9EKnYSOBCEXCSCJ2/DKHzMPh5mtsWhrTqvIbO+6IoCim5eHkHm+YXTT+aN2aO42UbX4PQeRRWSm3xwufjq/CNO0Png9jOeD/uxE2ou4a7B5uGHR4d348QevUYLVemV3E0U8AXN2wXnICGvGmzW7OvnpqBPwjl3/L+QWwidoDveVkeYy5n/kENiCnNjrNbO2C2Y9UrxsxWt763qXqXqmhgFGBsdYwx8wfU80gt3UfXhmbXa7d6LdvssdK2Sp9eQZv1mrFjzbGKPjs22FcoFDBnTevjvTUOnm/Hz+ba5fMC86+1xsB8S/eYMlftCTOaDRt7jq6xdO2KeXg9YW6lsf49zZiK80LXrtFnWQXvUbq2f06wz16zRG26MVX6Kq9trxe6R+m80l3KbP0+e57dBtdfusds2JTupWeFn7/ZsLHnnIv529eLvWZ2MiuRAr6AdBpEPeKSCYTB+6JXUDQsh7l6wmH1PhXLvP5K0c0KdpXXNqLbHMTAIC/lwUYCJEACJEACZ0qAAuiZkuN555XAbIXSLJwvh+FRasPmrTBa2moYPkIGz5dQ6uUrjcCTtAlCaZOg2LLxODVV7ys8f9w+TySVUwi5t8WbKjxL7efXmnBR7MkUf9oVHhH6TIucoybkPhhmH9zXUHzke2IjgfNFQCvDN71OzQ+dhyCTO4x8ouol6ouiWYTSmwhfOwm8iHMHi8bG/ttLPRHBFyYqiAbD57WiPdu5I6AfXFc1X2Jsh7yjdOGhoSF5ZWi/TBYnkOKkzXxA1s7yB9G5CQiVH8DtB/HgNcvHfLFglgJCpShh51i+XlmAqJyHub8VJyoEEHvdanMMXbs0z6kih37wv1itmJtAflMtDOXlMC0Xg/IKQHnFoNCHfKeFCS8HamESfzTnkt80tDgbCjE11UJoGB5EonGJNWl+0w6JmmJQmuNU85siz6kWgcKxKB5r/tNgDtTzmd+0r69Pksmkeb1XzpePSaCeCIyMjMj4uPcFV3t7uzQ0IDUTGwmQAAmQAAksAgIUQBfBk1zPS0zM0qNUhVITel+Rl3TMF0jNFvtwAJmxWbH1+AwjVRwthd8br9JGPIb1IkfpxupCqavh9BpyX6pqD8HTiqQqfqpwqnlHp2uat3R0SGTPUEhPDZ3ViB99zUuqwqjvOVrOSwrPUhVJU/z1MB1m9s2egApSiTUInYe1/Ix3XjHrSvZl9RAti6L5vtCrVFz8OGSeR+g8DJlFzYlOO6rObwmIoqhk7zSVxbjZz4ojpyOgz1lXErku0TqbO40wNN149s0/Ak68QZIda0XU5tBUKM1P+KKoFoPC45KICjG1UHkMj4vZQGLSWdzLLeQkN3LE2CyGl4Y4iSaIo0vLYmmjV/zJKxKlYqkKp7YglFcwKppsg0MqvzgpQeQOCZAACZAACZAACSxSAlQ4FukTv9iWrUJpd49n0619WqEUAqn1LJ2LUDrd/dTxSIs4lYXSBB4nUPW+Q1q2Qii9tiyU2s9v7jgEzkqRtCSYIuxeRdLJGZTcNPLD7UMlY1hQcgruSxKeS8uDxZu8kPsIxFEVS41I2uR5+E27RnaSQBUCTgJC5qWoNQ6zrTAML9GXIHiafKIFySJ0vjgWelVKcQih848jdB6GF7o5Nb7aC523nqIJhNJHYhRFLVduSWAuBNQTU20uzS0WIZSegnCqAqknoObTgxBOAwKqOa5iqndMx7p5/M2aQytmxyWrNnRwDmcJPEt1Tepd6omi3hohlqq3qYqmOJ7JQiRt7ZFJd5V3LNk8p3twMAmQAAmQAAmQAAmQwPwmUP7kOb/nydmRwAUhMGuhFLoLIkTFeo5aYbTy8YxCKbQd61E67QIDQmlLaxwCaTuE0nZphjdpyyateh8WSt0JiEMnfE9S4zmKD5klkRQCqYqkKoJO11REPQDVFxaUoIL7oqH0psJ9qoonqSeSCkLybUjqdLdjHwlE2xxp3K5WFtazr1gPUc9bNHsQr8uKl66G16uN3euHzuP0xEZ4iQbC5+M99ADjK4wEzhcB9bCMN/cYm8s9ivms5Mf7IJz6YqkVUNXL1B6zwqm/Ve/UuYbpqwermveVyfQzPGK7ka801tgVEE0hoJowfS8s34Tp++H6ZWF1iTgxLxeyvQy3JEACJEACJEACJEAC84MABdD58TxwFguMAPLFz86jdAahVPOTqmh6LoVSFLaHIBqDV2kbhNI242HajLonXr7SslAayUNIMhXukZPUiKQQRStFUg2nn67lkPPtMBYBCwqjwX1k1hepWuG+7EkqrQkWu5mO8yLuS6xC6DysZacHwc2h6jw8Q8uh8wXJn7C5B+0Y+IZqESaYbQ4KmiU1dN4UWcI1L4lJtIVeopYPtyRwMQg4sYQk2lYam8v9C/ACzY+f8kLzrVhqtl6+UxOmr3lNccyG7xcyiHpA0a9ZN+RCzSOHqtpcWgQCaDlM33qeItep5jf185p6+U29fKcmB2qq3eRFnct9OJYESIAESIAESIAESGBuBCiAzo0XR5PAnAjMViidhFCqxZxKnqTQFK1nqPEq9R/PWJsCyuMIPuOpTdug+7S2RiGQtkIgbcUWwugyCKebK4TSRFEifvGmmiLpMHIzhhTPijsX0HkU3qiw4LDgvqlB0tPohdWHcpKWK91LexJhzfTiq6C76B5G4gid34rQeZhthVEvdL4kiiK3aHEk9AozjyeeyIuabfEVCJ3fbPOJQhRdG0WBMIqilg+3JDBfCUSRC1RtLvlNXRRjKxV7st6k2KGybjMAAEAASURBVJqQfIilo6ePSCQ3AhsN5UCdc37T/OSZ5TdNtkIg9UXRkFjqHfPym1rvU69gVBTnML/pfH2Vcl4kQAIkQAIkQALzjUD5E+R8mxnnQwKLiAAKz0o3wtnVpmuVQqmKpFY0De6fO6HUgVDaDIG02fMkVaH0VeWQe+NV2uhKw3haIqcnKjxJvbB7E24/CIW3GBakQuvUrhNpY8FRwX0z3uYeNduyOGoKOekxFUkTF6/qcmhNfHDBCERbEDZ/jVo5dD53NBA6j8rz2f0FcSscmnNHEToPG/uB34G/iMkNZUFUxdH4Mr6eLtgTyRuRwHkkoKlYvNyfyG+6ZOqNalWBd9UTNN3ve5PCq3RKXlN4mSLfqVc4Ch6oRlw9jfym+Ls3h1acHJGs2uCB2Z+FNZn8pprjVPOb+gKqF55vxVI/12kgB2qU+U1nz5gjSYAESIAESIAE6oYABdC6eSq5kMVAYNZCKbTHYeQoDYqiwX0rmp4boTSCHJ9NCLFv8jxJNQR/BYTSrQFv0hZXmrMT0jA2AaEUIfeag9QPuy95lqpIqiH10zU9R8P0d4UHhYTSTqjJfqGmUsEmiKOlfa1wr7lL2eqaQHwFxEtY803eMt08qs7v80RRW2Qpf6zi9QbnUONFiiJMtjnN5dB54y2K3KKaq5SNBEhgcRCIIBfomeU3nTRh+qYwFPKPeuH4Xlh++VjgOITVQmZI3ELFNzXTYVavVg3zh81JbnViEIM1vymKQEEY9YpEqWAaEEtL+U7Lx5jfdLong30kQAIkQAIkQALznQAF0Pn+DHF+JHAGBJJwjpyVR2lAKK0mkNrw+5mEUnwGmyH0XsOKGyGUNkpLW8CDdFl5Xws5tRYz0jI5IclRCJ3wKA2JpL5gKhCypm0D+BiotgcfJAMDg/ui1es1L6kKo8ab1MtH6omkgKciaYq/HgP4FvyuVoVPbo4Za32Ht5ziuCuZl/IyCQ9RI3xq6DyqzAebVqGfeAqh8zDbYsv80Hm/yFJifVS0qj0bCZAACVgCKhaeUX7TzEgoBF89Sr08pn5hKM116ofwm+MqgE5qftPw7y47j6rbYh65TU8Yq9pf42AklvKEU5PLFMKozWmqHqilYxBV/RB+I6ymOpDflH9PayDlYRIgARIgARIggQtIoK7fkaTTafnkJz8pvb298ulPf7om1knEFf/rv/6rPPXUUzI4OCgbN26UK6+8Ut7ylrdINMrwx5rg2LHgCcxWKM34QmlllXsrkNrjxQqHukpARiiFZ+oIrHqD+CioKB/pMEJpC0TR5pXwJEURJ1vpvi2WlZaJtDRnJiQxUhZKPa9STFS9S7WC/XRtHB42+/CBERb8yBjclxR+9k2FeyuSpiSVyImzvFXc1RipIqkKqWwLloDTFJHGq+PG7CJyKKg0uRuiKLxAVRhVr1EXaW6DLX+8KGrjP/Q9tfBSURHUeIj6RZZiyx28jimKBrlxnwRIYGYC0VSrqEnHupkH+yO8/Ka2AJRuVSQd9PKblsRS75gJ1fePzT2/aeYs85tq7lJfLLWep6XwfT1ezoEaTbXxd+isXwEcSAIkQAIkQAIkMBsCdSuA6pvBz372s/Lcc89JLFZ7mUNDQ/LhD39YXnnlFcOrs7NTvv/97xt79NFH5TOf+YwkEonZsOQYEqhbAinokqlekR7YdG2KUIocpbbSfdDD9OyEUv15VEPVXOhL6lFqhNLlXsi97rcm89KOKsEadt+YnpD4cEYiEEaDofeSLnv0VV1TBiLqASwAZoVRXNq0ks6bQCh0LwpxdEG0neJJCq9SDcVvifNDXFXA8/NgvNeReG9Cmm/05ueiiFf2QFgUzR3BK8C+KHQYXipZeI+qoV6ZaQ5eFslN6nFaFkaj7Qyd9/FwQwIkcA4JePlNIR5CQKyW37TWrdwCPEE1vylC9D0vUw3Jx756maIwVFAsLYXwQ1y9sPlNfVFUxdGQx6ke17ynGrrvmeZANcWxai2Yx0mABEiABEiABBY1gdrK4ALGMjExIV/+8pflkUcemXEVt99+uxE/t2/fLrfeequ0tbXJ0aNH5Y/+6I/kwQcflL/6q78yXqQzXogDSIAEZNZCKZw0h+GAaT1HKz1JNUfp+JhIfgaNsrZHqf5qgzJqTFAl1xdHV2F7KbxJ4VzTlipIR2FcWnMZaYI3acP4hMSGMbFAflIZnSEXWxZC2GFMFhbUw4L7gtBrqVrh3gu7NyJpWwJzpLfgfPwRikQROn8JREyYvN2bYTHt+h6iZU/RwmDoWZfiuMjETxA6D7Mt1oNrBUTRBAouOUk+75YPtyRAAheWgIamx1t6jc3lzkX83SwJp0Ys9YVTzXVaK98pBFVB6P2sG/7An0l+00g0Di/ToFiq+15YfkkshWhqxvjeqOqVyvyms35mOJAESIAESIAEFiyBuhNANYz9z/7sz+TEiRPiOI4Up3E1e/HFF+WJJ56QhoYG+dznPgfxRsNvRVasWCFf+tKX5F3vepfcdddd8sEPfhAeZtb3a8E+1+dl4hGoWKl/+6bk4BroLl0qEXjQRjqXiLNkidlG6D17Xrgv9IumoP2pzeRRmoaIFPIgrfAo1T4VSuHEMm1zoVNq2H049B6ClkAJNeadrkJpqxZxst6kTUXpKqalrTAhLfAmldOnkaM0L6kx3FCFUrVhxEeHta/wXDRn6VEsBBYcFtwXdQzsRk5SDasPeZLid5J93IEK91F6EIbhXpxHTmNEGq6KGbMzyPfDS3SXhs3nRYssZfcidL6iKkn+pCv5kzkZf8gX1vF0JtZpPlF4ivr5ROMrETpPMdxi5ZYESGAeEnDiqbPKb1rKa2pC8ZHD1Iimvhdq6ZhXMGqu+U21iNSZ5Dd14o3wJlWv0kqx1C8CFcxravOdphCJwvym8/AVyimRAAmQAAmQQHUCdSWA3nPPPSbsXZeqHp033HCDfOELX6i+chz94Q9/aPpuvPHGkvhpB2so/LXXXiuPPfaYEUHf/e532y5uAwScwQGJ7dktRVhFmjxvVGOjOF0QRiGIOhBGVRyNLME37WaL/Ta8eYwzj2IAKXcDBBoRRqw2K6EU4qitbm89Sk3YvS+azlYoHYZQquY1FRybfdMjq/Uf41HaugY9l0EwVZHUmZCO4gS8SSekGUWcGhB2nxjJSHTQF0m1wn0xJHma65T+gUArJ9LGgqOC+6KOghpSXxJJy+KoEU1VKG2HSJpQYZftQhOIdTkSu8GRphu832cmdP6Qhs57oqhuc6/gidbn2jbsZ/cVYVkZ/S/vYARPoyeGlkXRWCeFb4uMWxIggYVLwOY3Tc4lvykcGQoZXwz1w/JrCagmlN8XUItIgzOXVsylpTicltywlxJrtudqrlKT19R4k/piqRFSbb7TqceY33S2dDmOBEiABEiABM4tgboSQAcGBmT58uXym7/5m/K2t71NHnrooWlpvfDCC6ZfxdJqzQqgzz77rFAArUYIQhByqE7bUIiqePgQQoQPaZq8qi3SDhHUF0Q9kdQKpF1GLI20IhE+vHnZSKAWgZJQuqzWCO+48SgNCKXBvKR2f65C6VHjvgmVVtTCLQJv0taVEEpbXOmOTkinqFCaMblJm5CqIzWG/KQo5ORoxftBFHCarsK9qqGnMA7m7grfJySUdiY9oRSCqFfVHopacF89SVnhPgzwPDwyofNaGAkmb/XySBczCJ23Fee10BL2C6dDz564eIozPy0Ys9OKLtXQec0l6ouiGxE6n2LovOXDLQmQQP0S0Pd/pjgSRMW5NOMJ6ofnex6mXl5TL7+pF6pfULE0OAaeqHPNb1rIDEOgHZbs4IHZTw/hJiZ/aSAE38tvGhBLNZ+p742qXqnMbzp7vBxJAiRAAiRAArUI1JUAunPnTvmlX/qlaYseBUFork9t7RDgqjV73BZIqjZGj/3yL/+yZLNV/R+lqakJeQzzcurUqVqnL9jjhQJCPC+7XMZWrpQY1CNnaBiC6KBE4D4XGcQW4qh5PFkRB1qxYhfj1GT/vqoiqYtKN257B6zdN7tf3gJ0xVX5kASqE3DwW6+1w7PqI5C7MR2R9LiD8HrH30Yljf2xsYhMjGMffek0UmwUphehNPTe8yiNyFFBiLuxirvipetAIG28FJ6ksbQsiaSNN2lbHpXuJzPSaITSSRRympQowu0juaALYcW19OEAft7U9uDnKtAd3C+2xKQIobS4BNaZ8PZ1ax57xyRJT9IAvnO3qyI9zHmDCKRpKWpavP0RKezD60m3B/GayoRfV4VTrqRP5SX9iJ/rIeKKsxK23pUozNkAW+4az2Rc8pw0/f1u2zBSnbCivaXBbb0S0Ne85pCv9X6uXtdd3+vC37HIUvzpVfNWql+n21KK1dZezE9IEZ6mxUkYPE+LmSF/6+2rN+qU45NIau6Wf2dWu27oGN4cmByqKEA1eTrUM/0DJ4Evv9olmurAVq3d2yaxhUhqjuk++rwx3n4k6n0JZy8e/P0+MjKC9zbIJcRGAnVMQD+L1+vn8Tp+2ri0MyAQTP84ilxx4+Nzi4Y4g1te0FMmfV0puM65TqCuBNCurq45rd++IKzQWXlyqyYDRLPjKvvt4z179oh9Muwxu7388stFK9LrL926bNGouAhxz8FqtuykOL4g6qg4CrHTUXEU+3YbmYZPBPwiCLUXtRrN1Xl0dEgRIfUqlHpbPFbRFIWtdCtJL8drjUvwMAmUCMTxWQF1iaQNQul0bQIiqBFDrSga3BrxNIoP1DMLpcViBOH7URmTFjkICzX9La3f0cAijitd8TRC7tPwJvVyk2rYvRZxahyflORYBoWcsuJocaZpmjOaFzU5VPuPYjEVlWJXQgoqlEIcLXSoUOpZwd+6DXX1J2QaYuexS5/uK0SiatiN4alzj0cghjriHsBzoNtjEETxGik1F/2vqMFp+AH/aBIi6NqiRNYVxVFbj/2OoOxdOnvOO8EPy3M+mSeQwAIiUNfv1xbQ83Bxp4o0Jg3dEBRhc5hIcXIEoumwEUddI55CODWPBzwRFcdceIoGhVU3i5CUubRiVorpPmNzOS0SQ0SICqZJFUnbfKHUE1CRxBTfyEXxJRdWq/vGNBe13Uef2ff6I2Z8cN+Owzn+tfTbuPK+XlvH4Bz/Ot5jHDP39c+Hp29pHMaHztfz2EjgLAnw9/tZAuTpC46AioRnIxTOxwWfC01t0X561RdDJoOQU7RaBY6amzX3n9QUN00n/5mZQAICiiZxhNX8fhyh8kYktaIoPEmNWGoew/sIHqaRgEdS5U21L9LfLw6sVnNRkKnY0QlBFAKp700aEkxV8GbRplr4eLwKgYbGoqgtWTr9Fxw1hdIx35sUwulshFIXItipySY5VRluj6h3Uev0Jpl0s9LrjMkSCKUdWsQJHi0tyE3aOJGRFITSxAi8SSdr/jSaiziZgjhHJiQGq9XchCOFLvx8Qxy1oqjZlh4nxW1etH9mamGb9rj5DLoCYuYKPD83eM+RFlNyD0FIP+AbRFEZgAXbJATR3fiQCCs9s22eEGrEUBVFVSDl90BBatwnARIggXNCwEm2QmDE+8jWVbO+ngtPUFc9TCdh6lnqC6i675pj2ud5nqonqncMfYgQmUtz8R7ARcqd4tixuZw2P8equBrFGx5fbC2LqVaU9bbaHxZx7XF/nBFjPfE1LPCi3+8ri7BWnMV4TclVKdCaP9zap8KtvU/w/sF71ji/NJ8q4nHwnnp9M1bH4f1Vad9bi86vJCQj5Km0b3nMz2eVsyIBEiCBC0Zg0X4y1QrxWv1dw51qeW/a44kZRLGnn37aeHlWe9Z+7/d+T/r6+qS3FwJgnbVBeHVaRktQ5Ch+HosZ6bd2JlR+4LS4aqjGXUTOV7vv6v6IhiDV9niKIE1B9OQJEbVaraXFL9aEavZLkIMUxbCCxZtM0abYov2xqUVt0Rw/ceKESWtR60uTswUxPuaWCzmhwr3NS2q2fu5SjVSbKfR+MpKQQ26nHCr4iijeF5ci8P00arFiXjrwIUpzk5oiTqh035rPGG/S1LgWcZqQaNqvVl5jYRF4msaOQSBVq9XieLOuBZrUtIjT0lQ5N6lf1EndbVn5vBZA//gabHeUxxQGbYElLbLkmVv5mXgYgulP1Pzz4EQaX6VV5zWfaFQSyCuaWIMPS9GAd6k/VMPe9e+jNi0KONPfQf80bkhgwRLQ92rJZFLaEDXCRgIXjsDyOd+qmM+KyWuKnKVeTlMUiZo4jWO2WFQgxymO53Fcx7mF6um65jyBi3mCisYQdG2r/a7fjuC2GoFIDPngNSeUL4xasTe4NcKwEXWtuFveen2ewGqFZlOvwQqtZot+X9jVbfDaRiyudgzneUKyCsiewKvnTb223x+6X/AeKhR799fzh0fHcNm4tGrxXXsPKxCbeeC9UGCuHpfw/EusdBwbCcxTAhq5rKHv2jSauREFqeupWe1JtbwzbYtaydGQec3vaV8klRDtcc3jOV2bTvjTJ0dzp9Vj/rTgms73Gs298CEcn8TxVGys+nS48OpVYVRF0WLFVgVSPYakjlXPLR3EL4yi/tI4dLB0qHInglB7LdrkQPQ1xZvMPgRTLeSkhl82LNpUSa0+HtvXefC1fy5X1oxwaLXeGT4P6cu4UhzVl+0YRFJ73BNKa88ujzd+pxKt8CaFx4o2/Wugph6CGnK/AiHZxYK0ZiekDeKoKeKECj3t2G/GMS3ilByFSDqOvKQYXrNpztJjCLVX89uUDywO8vx2ewKpqWhvhFIt4oTJWOG0A8JpFaHOXnOxbWOdUYm9NipNr/VWrl8SaZX5YJGl7EGwL7mDYhzA5w4XjY3d44nbETjSJC6BIAoxNIUiSyqKxnu8v1tBpufrNR+8B/dJ4GISON+/3y/m2njv+iIQjSclGl8miVZNKj37VsymjVA6fOqwjA8eNx6nTY0piceQRgp/7118Maq5THW/cutqjlP0m3Ga4FzHm2Pe1pyj/ZXHgtdDtNa0/f71p97bv1/F9e0cyvP15qfnT+cQMXti9TtSi32hLGP9LrDGyqZxgalxRu3DEQiqVhS125K4aoTZsoDriboVIqsvwE4RXtXLGX0lAVeFnqpCb1igDd67msA85T56/ymib3CO1foDIrPO0Z+X8Xw2QnItARvHK9dAIbn2i+sc9dj3NefocvPiMufi84h+3F20bSYBVBODa+uA4MU2/wmo6BhZilyksFrfzbm5HETSfk8gtSJphUcpciNMu1gXnq9qxX17q4/TeagQCoHUiqTGi3SJJ5KafT+9QvUL8CgJTE+gCdk51GZqMwmlKpZqbmz9rFOtFfDmZDDVLIPSLAerDcAxBx+EWiCIqlDaCnF0aUQr3XvepM0Iu2+AN2l8PCOo21O7FdF5Au6LsOCw4L5RWX2PUU8kLYuj5rEKpSqSqsfpImz6hiCxGh6dsJY3eQCKWVeye30P0d3YovJ8/mSIKkIqkeblBfTBRsTzDnLaIyiuhM+Pq/Hmt9eVTHdBio15sMX71zi+0DPb4L49Nq0UvgifFS6ZBEiABOYPASfRCG/+RklG2iTfhF/yaK1ICaURcfXc3EIO2i0EPwioU8VVFXatiIt+daYIiLjlPl8ADgq6AaFYnTCMQFyj37tvWaCtKiTPVuCtmGM1Abh8TMVgrE/XGJxv1TXq+i0L7zwKybV/MvR1ha+VQ+9ba49mTy0CtYVkT4CdIuwagViFVvRDVC17DFeKrGEBd6oXcbjfCrSla5rr4zPFFGHX3qf6+d51rIjtCcZTheZaHszl+wU9oO0cgtcpe3DjHLY5EVjUAmh3d7eBtX//frnuuuumgNPj2rZu3TqljwcWJoEIwvQjvcvEgdVqLgTQ4qk+eJIirB4iadGG3ftepC7yk6JMbK3TvTdP/afEheHtUPWm84AHcjm8HmIpvFtVOLWiaSSlrnhsJHDmBM5WKLWh99MJpUW8ERlONhmrNVMtZNaMYk0qkrbkMiYn6RLxvElVPNVK98l0RhwVQms17TqFsDeYuys8KHQWijZ5ofbqQYoPdX74fWm/EyLpIqlw7yQiktoWM2aJFYb90HkVRP3Q+SJSLwRbcciV4o9x5MeoBIY2gDf4+iZ/1k3fvzWXRdFKwVRitq+aiFo+JiWxdebxUkucpdfwrJ82DiQBEiCBeiSgAktUvfXYzpiAibJDmiQVh62QqhfTtApGXDWCqvUQVrG4ipBcIfDa6wS3Zr9ChC33hwXkkrBrPZIrrm/FXN1OTIzji/iiJOLwdrZrqJijEchr3lvXrQI61oUx5XvrWq1oXBaQy8coJM/0oqOQPBOhWfRbUVgFYSMKx6T3f/x0FicuziGLWgDduXOn3H333XLvvffKr/3ar4VeAVok6Qc/+IE5duWVV4b6+KC+CajwGF21WkStRisi36h72stBagTSkjepJ5q6KN4k0xRtEvVEPX5cCrCaLdUgzlLNQ+qF1k/xItVQ/Bny09a8NjtIIEBgNkKpptdNw1vUhtjrdsq+epRqjtIK5d+Fd+IovE7UajbcoAkeGkYkVW9SFUxhnRBK27BVb9IUijhFCxUXr7zgAFwa1fagYESgL7ivOUdLIqkNscfWE0nxxcMS7NdphftomyON16qVPwzmjqp3aEEyviia3Y837Hgff8YNT1FxxBK32zO+2jk5EWlxJdJohdTKbVl0tR6umg7C7pe31Y5pYlU9Xq0vfKw0Dj8PbCRAAiRAAiSwUAiYKLvp3sPN84X09/dDBI9e1KhOU89C8/CWBNOykOoJqmGB1/NEDgjJNQTesiBrz/dF2in3KQu05XPKcwgeq+4FXT4/tAZfSA4KyKH+kuCM+dn9qkKyN//q98Y8VYBmq05AeZrPR76zgqYnYKtJYFHTUa/PtWvXyssvvyx33XWXvPWtby2B+qd/+ic5DVFrzZo1sn379tJx7pCAEnBaUSRBbd26qkDMH7lBFUi93KOmWJPJTeqJphqG72rSRlWVarUMKnYiRy0S1dYa4eUbteH2RijV4k3qTeqF4JuiTfiDz0YCZ0tANZu5CqVTBFK85M2xakIpbjAeTxk73lQ77UhjbhJepPAk9UVS3apA2o6we/UubcLPTSyPN0rTtWG8AVXbhy8yAuOC+9IMRcsXR4Mh9yVPUniXRprKImLgMgtuN74CeT9hzW/0pu7mXBl4dkTSu+DZMQAv0lgK3rnwmsBxF++tytvyvkzXN8PTcSGAuXi6XaQE8Fd4IW45/T3US7bJCrFloXS2Xq96cSPMNky9RlmwLfdNe1145LKRAAmQAAmQAAmcPwImHyOKT7GdHQG34AmpU0VWKwCXvZRV1C0JycaD1+urLrKWBV5PDK4Uksv9U++t10W/EXjhBeALvcH7VBOIQ9fRuZbma+ftbc18KgTw0BzN/bz1F8HHeIGeHea6PntRC6D6i+j973+/fPrTn5Y//dM/lccee0w2btwozz33nNnX4ka///u/X5cFjOr6VT0PFmf+yEGEFFj0ko1VZ+RqMnjrOWq3Jh+piqSap3TAc7mrerZ30EWeWjU5eCBU66R0Cl7jpaJNVhRFqL0nkMK7VPOStqBok6pbbCRwDgjoS8kKpdMVc1LtX71Fx3xRNCiW2mNa1KnSozSN4g9qJxu1UlP1lkKF3JJICoFUhVGToxRCqRZ0Um/SRB5vEKZrY1D61A7gZywwLrgvKXy50A2vVhRrChdv8kPvVSRt9cLIA5eY97sqoMUuQU2s5R6jts4WUx37bCeuwmlxvLaIaoVVjba3+1O34T71VA2Lsvb64XE6pizSYj/0RJ7tys7gfPWSHQ1OIrh/Btc7B6dE8FKuJp5OPYYfcuPxOvN4z5O22riyOGuvXxZpMR6F0dhIgARIgARIgARIIEggEkXuTVO1NXiU+5bAGKrg2kLe9hi3YQKLWgBVFDt27JC//Mu/NALo/fffL2ra1q5dKx/72Mfk8ssvN4/5DwmcawIReGZGNA8trJaPpotcoy7CNkp5SCGUFk1uUv+YiqRZhPvWalCZTC5T9USVl6uP0nlYr1EjkgYEUiuWNjVVP5dHSeAMCahQOpuq91YorSWQqiN1pVCaiSVE7VQDvLRrtDi+IW1FRdxWiKPqRaqCaSj8HrmuUjm4DU7XMnBtPIwJwILyVXBftChT1Qr3ViRFyH17clF8CaFCVxQFluZLcwsQZNNhwTQsvk4VUYNia1lQDV8jOMYIr3nbb7dTr3tWKQfOEVAXdcgwQ/9qdnuOLn4ml8E7VCcVFko94TV8rFb6gbKgOt14TMzPSVsYi0gBInAuXfRTGoSF2zNZAs8hgXlLIItvYRL4+8RGAiRAAiRAAouIQF0LoCpuPvTQQzM+nVdddZV861vfMiHvryDcWIsj9fb2ioNq3mwkcDEJaI7PyPLl4sBqNXcijaJNCKn3izXZnKRF41UKb1It2oScozWbeqL29UkBVrPpPJagaBOEUlOoSQs24bEnnHrFmyJJhnXU5MeOMyYQFEqnu0hVoRQepFYgtQIqvhjVHPaSwzfIpxtajdW6bhShKNZz1IikgbB7zU+qxxrhbTqtpJfDzY4ieSosKCkF90UL9YTC7T1xNALPUnvcVLhnQZ9aT9UZHY+AZ7Rl2mfvjK57Nid5gqwVSu02LJh6Im34mCe6Tj1WFmmn9gWFWimJtOVxtav4nc0K53AuvHvDBbpCPzVzuNBsh+KLEwwdFnypUa3hpRLBj6T1WC1vw8dqe8dOFWLLIm34GrULhwWuUee/D1wtimcNX1aYff1Fr8c0rYbts1sdY/vNGH+s7TfbwHn2mhX9Ve8bGlNx3dJ1AtcOji/16/wwJvjYH6dfxoTXF7yHf10dY9dnx1feR69vj+mYcbz3079BFU2/0g5+rT2nLCXqna0pYsxHJOzrVv9Q4/+q26rjqoy1Xt+6rXUtPT7Hccab3Fyvyj113lXnh+OV58zxvmae5hr2WhXbmtermOe08/OuaaK4zDifzxndd7bzs+P8ec5ifuZ1ERpXscbgfGtwYaQamLGRAAmcEwJ1LYDOldD/3969QElS1Xccvz0zu7Pse2Fhkcciy0MNoBg4SDw+QNAQiCSGGIPGBDXkQSSanCQSxRAU0SBokiM5aMhDQDRA1MARE4wBjVFDgg9yfCDv9+6ysLuzO7s7uzPT+f9u1a25XV3VPbPT09OP7z0UVXXr1q1bn+6Z7f7PrXv3s+COFhIC3SRQ2WexG1y71jktJWlyq4116B+vT2e1D4/chyCpJm3Kz1wT16WeqE8/ZZM2PRXn1m4vXmwB0nTSJnu0Pmz72e0VOF1pkzbZsBIkBOZCYNaBUguWbre4RxwonbC+2ZsXLfVLWZsH7Ocm6z2aBkWT4Gjy2L2OLbFepuG7SWE9+qK63rrf2aLvryHF274Cm5xJkzfFY5Jm+wqgaob7oYZXClWz7lCBAZuoKfnm3RkNTHrJRkHRLFBaHJwNgdipwGujcsmx2l635eXnvZes/UBWd2rRhn46k0WvmLYr2U9vyA/r5HhS3l7d9Ny4fLKt8nr1k/OSOqfOTc5L9kOZin2Krwzate0xEq31e6IyYPv6NeDXybbysmMV21ajddzWFb9v26paebq+8svaoXLhHrTOljS/LDinwJz9lwQwbSME6hSkUz6pOwT0uo00eTqig+6kH95a/XCPDd9S+n23UL8E7ReX/wiUW9vuCv2esuMTg/olaeXjQKsq177y/S/FaL3X5aI64joL25dc2wd5fRvS9tiqpp0tbV9yzbp7btC+Ghtfbubtm/qDRLh+um7qbNcqfX1zddWVS9tpxWruQftNrzvd9iXlGL7HTLsgEQDtgheJJiIwW4GBFfYosJbD1xVWVdUMfps3+yBp6EGq8UmTR++tF6kCpYoMNUo7rCfqjsds0iZbSlLF2pDNaq+gqC1+PFL1KNXj9ytX2he38K9qSSVkIzALAX0uCo/eN6pGvURHc7Pe61H7ECDVWsvo6IDbOrDEbR2O+9PU1qzAxVIfHLWgqK3Do/Zx4HSpBUkH9QG9LKkTzzMWfbGl+qPaQtlZ+jC3ynpiW5BUPUezCZu0vZ91XdN4pbau6IsCqWcFGvdgs9sOgaewjgNWeg+G/XG96ez7gcr5PNuJj4fzbZ31YNMJCsQpoqX1QltCOdWh8+N9v23FQ168Du2I8vy9aTIrO1a1YKx6rmbbobzWYbHeb7aXtt+2dEtRfTXt0R8BrYh+jKaCehYQtPwkGKgDHZZm1HWvw9pOc1oroC/y6hWsdbbYJbLtqeP6qZgYtt7EY5Nu0D5z2ZZ/7yfveztHP6f6wdHPipLW2gz5+XXTcr4W/ofA3Ajo97qGJGqQuuGbRfrT1uAuuv9QP9xj9irpTRcHv+3XbE3AVfv542Ffv7eVtJ5WOSubnjtsn1mG7A+bmy89zlfB/+oFCIDWm5CDQN8JKOioYKR1gS4fj9QmjcmCoqEHadqr1M92b9vOgqCNUlU9UW1xDz/UYNImPV5vgVFbpoKlSYBUwVK3bJn9jk//YWh0MY4hMAsB9aCabaB06vH7its+uthtW7jYlfahti+US8bHsuBoeMQ+C5KmkzkNKTJblvTJ8jkbE1jLT7b476uhaM2HzhU2MVMIkqaP3k8FTC1Qqp6mc5QaB+eslfkAVQhqxUGr/LYvYw3O56f7WXBO+4IoqjPk6Yu9yoX9uD3Kqzuelg/n2G5oR81107aEY9l9ZteJ6onL1h2fqj+rS2UKHnO1kj2d4n8F4u2evukuvDn9SCTf4PTj57/J+f2p/BBeTo5NlbHy/t/65NWdylf58IoXbdsxOy+r3wcA7ZL646q+kKoHWM3awn8KHIbFxoTVdpanMWKVF601trPytFRtbGM/HILKaFvjaoY8v5/ku4WhnK5veXWL2laUn+bZ7+1WffYZtckzR/UXPksr7Q/P++wzd7/z/UX24n/VMQto7dIsd3ZyCLjqd6NSvI6P15VTYSug3+PhWLz2/5ymx+vKRefE11OV2i+4rv/3LRwP64JyNe335ex/cbvCOQ3bF9pg506zfbMvp2aG69p6Wu0L5XLttOy6e275fdg10tdVHT20aT9Nfl1z7Zr7UAESAi0QCO8rX5Xe8O1J+ufN//vVnst15VUIgHbly0ajEWi/QGXIZt1bs8YN2FKWqmNjFiTVDPbWYzTrQaptm4RJwdLNNmmTlSlN9sEqG8u0ZM4mp3ZYIDQLkCpYqt6jflzSdNsexych0A6B2QRKfW9S9SS1R++3j1SsR+kit377Ivd0dVVp0xfvGZua4T48cp9O4rRsd9LDdIGNXdowbbXHF7U8aH+QiArG20uWDLlFqxa4qn2ZHxwYtHigfW3Ql5N4qQvO6bhVWFYmvkB0XTYRmFcBBaIs8KS3uIJSFR8gU57tKwCXHq8LWClYlZ5TWiYf5FJgzecl1yqss+acgnJxkEzti/f9Nx+7l0nLt583rau6sXRbP5/a9/n2y8uXs8lw/L792kjWOm7X1b5fbH/CFsWi8muN0zpu9Ws9MWhlrJyeaPeLeulaPVo6IfnfTdaQ+W6PntS10YCKxpCtHRPWwrwLtChwqvK70nVyriZBnjoWb4fyYW33nNWR5E3ustdGT7Hb38L0hxr/xxp7GX0Ka9tpVcA1rXlGq8qwQWnpohTRdVGr+6Opm2xC2UGb9HXVqvLPV80kqvmAfBwM1ucb/Y7RL1ut88fi/cJyBefEAWHVH9ehff1boTLp0xp+u6hcOC+rT1VZwbKyhe0L5aN2ZPWFYyXrWZeLrql2N2xfaIPd3qyvG+pK103rS9s5rfbl7yN3j3Y4e73LrmtFShO/jEppdIAAaEMeDiKAwEwENBFS5aCDbdKmg0tPq9osNJMWJE1mp7fH7LPepOmj9pq0yXqblib1RN24wSZt2lBaxFk7Blan45FmwdK0F6l6ltoHoMqw9XQjIdAmgb0JlMaP2/vH732gdNgCpcNu4/aV/rNRUfMX2cRM6jmqSZr84/b2eH2ynsobnmzwM2aVVkbH3ZAtpHkU0AfYugCXZepLj+ICWpceT8vZKimf7sfBNR/Ai/JnHJzTuWn9od6aYFxUtz9e3pYkKJiWj+uwrNoAX66MD1A2KGM99fyXpVCnBVTKxujaaBMBDtu/HSs0XAyppQKTGrYgBEVr1vYdb48F4KK84nKhjJXXOLQWvNN5CmbG507VVVTvVB3+i39L73AGlYXAsgUhp1K8PZU7t1vJH4o3CNwvc3Q1/Qz7wHx9/frxzVLYDuvsQLoR8sO65HhtnQWF46x4O9QX50XbNfU2KRsOZx2VlZHWVVhPdNz/Ts8qiDZCW8I6OuRPD/lh7TNzhfJ5cdlQNMqraWuUH4qGe/L7NYXTEvE56XZRseT8gnPSrLLjhXUVXFPn79ljv/vthF0LbCbMkAoqqMkqqSucXnv/We7URnR+Vu/UxlQ5bYWyYV17NDte80eJorJxXrwd6ovzou2sWaGc1tHxmu1QpsnxmjrDTnxOqCe+lo6HpeB4qMYfKqorzou3Q11RXvO64sKhgmgdHQ4+NXVGRcPxbB0f03aoK6xzx7N64+PaDoFs/1fOpJ7d1tFot3WWsD9J5mphNwgQAA0SrBFAoC0ClaVL3aAt7rDnF15Pf5Ws2qRM6jWq3qDZmKTPpb1I1ZN0i03apF/6Zcl++U8++aTNvG1LWbI2+J6jWQ9SC4xq8ibfmzQNklpvUxIC7RSIA6XPO7j8yuqhpRntt1tQtLYnqXqULrQepQvdxpEV7mHNel/wo7JwYk8SILXgqJ/hvmBs0n2sTFlSlZP2iUyPouoxVT9KYra2a2bbSZm4rI75xYJivtdd2NdagbJ0rTL+y6DK+QBaWj7d9oG9/HYIdKX58gwBQP9IkOVnaz2yqn0t+lG3cwds8QEyPd6q7bDYvj8W7evxV+sc68sMqLz2w6JyylOg0rbr2hrydI9hO7RZQTsSAj0kMGCPf6u34dS3vPm9Od/rMQq6hiBqbfDVfo/lgrOhnNbTm+jLyk1j4rB575U6ly+H/rGwoG9RKvinqajYjPJq66zdm1FF81a4G9s8b1gzuHDy7+p42ZtxBjVRFIHOFrD3+uAiN3iWzRtAKhTg230hC5kIIDBfAvrrpmaMd1qOOKKwGX7SJgVCFRRNe5D6YGkImloPUx8dKjw7zVRPVEWQHnu09OOQn5RJAdE0SLpAs9jbEAATBx/i8yrLbVInJm1qpMyxORJQYG/Z8mSZVqA0e9Q+PHK/wAKnCyyAutw9o8mcCgKlQ/Yo/aBFWmuDmwpCWjCjG5IeQ/KPIs1vY/3QgxYI9Wt73cLansbLtuvKNDqW1hHO13thWnWqXFxvvJ2rM9SnteoP18ry43OjbT/BrpUnIdDJAskfNqyFizrjd5l/HHWavVmTIG3j4GwI3E4FaWvLj9uEMRM2AZLq0mPB9qmr/uWK43DpdtEf0/yJoWxY52sLJ5YcD4drOiwVlY3z4u30elk92o+Px9uhbXFevJ0dn8rM6p3KCqWSdcgP69qjU22Jjmd1xmWj4zXtD2WaHQ/lWCOAAAIIlAoQAC2l4QACCHSqgJ+0afX+NpHL/uWTNu3ZkxuHVL1Jk16lyTilNh7prsZ/HVNPU9/b9KEHfZDU5tf2KTvLogF+7FE9Zp8GSrUftv04pZpJh4TAPAnUBEobtEHzAygIGh61f2bDTrdl87g9NlZxCxfazPHWlVFlNLyoX2s7XvL5tj9hx9VTNT5PeYV1pOcXfils0O5uOBScuqGtrWpjFihVYDUKkMbbfqjN9FgI4tYFWnV+vo4G+yEAW1dP3IaSOrfaHwQW2SPyo/YHAd+e6Jy4rdm9RceVR0JgbwX8Y61+nE/VUBCM3NuKS84b8ZMg7fJHO3USpJKmk90iAT/ua6grBFbDOuSn6+zf5fh4vB3Kx3nxdsHxrE4dy8pmG1FefDxUlMtLT6upMyqq+p+zz/8az7xwiJNw2bBW9dF2VlWcF2+HG4jz4u20gpo64+PxdrhYnBdvFxzP6i0qp/IhP6x9HdFO2AxrnRJt++L6X5wXb4cCcV603bq6piqtqTNkh3VoT1iH/LAO+WGd5hfWGcpoHZ8fb4cycV607f/AFcqEdXS8pt4Gx2vaF8ppHepK12Nju9yuRvNtxOf26TYB0D594bltBHpdoGK9NSsHHugGbClL1V273KQNjJ5NvOR7k2osUpvIyU/aZOOR7tZMASXJIhtVnW+LxXWKk9qhAKnGHlWQVAFSbe+32gKlybiklQ6cgbX4ZsjtVQEFcLIepXaTaw7a7Xbs2OFvd999F9jYiO37uBACpIXB0nygNRdgDcFGrSfisvF2URA2fzw6PwviRnnZdeLz4u2iaxSdb3mqv9dS8Omu+9r7yTF0n76nbElwNQ78lgVQld8wcJsLuBbVGZ8fgsp19TaqJ38svZ+43rj93fX60loEEAgCfiiYsNNkPfch+dCAubvSgAWH9DtzaJX9UiMh0MMCle273Z5t9oGUVCrQvm80pU3gAAIIIDA/ApVFNkbKIYc4p6UkVW2K7jAO6dZHHnYLd4y6BcoLwVJN2qRIS1lST9QN692ELaXJ2jFgAVE9au+DpQqMaj8ES1fZ/kI/gFppFRxAoFcEfGBHX1R65YamcR8h6BsCh3UBXAVUtTQLskbH4wBwCOLGefG1GtYb11nUhunmWT0+qG3lezHoq3sKk/FO4yXviSJxkLUu0BqCwVrnA6vxfrSd72kb6i8LwGbB2CbXmNb5RXWkeb5d6XZPvHDcBAIIIIAAAn0q0E/fL/r0Jea2EUBgNgKVZcvcoC2atGmPzW6/cMkSt0j7afKTNulRefUYtaBoCJb6tc+zHqUjW+0bf3hGIZwZrdUT9cknbNImW8qSXTNM0DRgkzUlAVI9eq9tC5yuWGmTrvArvYyPfAQ6WSAEfTu5ja1uW7MAbAiWhsCvAoyFvYItvy6AW5JXEwCOAru6xujoTj/Uw9DgwuJgs64fnROCyuHaWXujMuFYuNdWG853feE1sVvum6QhkH3gNQrchkBsTaA1PZ71DM6Xz+9bgFXnh6BvqFO/G7IAbD5Im68jv6/yab1Zfba/Y+eAGxsbckMLqjY/W8XtHrPrpp3vZrS2c/xpe7NOr9c3bxxuFAEEEECgIwT4ttwRLwONQACBbhXwkzatskcntRxxZOFtVO1bsyZsime1n5q8KZnIyQ/AWHh2mqlep7a4Rx8pnrTJvrWESZvCGKTJo/cWIPWP3luQdPly+3Jl335ICCCAwDwLhIDMPDcju/zGjdtsqIdhGyNu7nrbh0Botm4QLFWwNQuyKqCbC8BmdehYg3riY3EAV+eH+vP5vu64zibXaHR+BtwjG/pbpu5XS/empdZ0LZ2dFIxVUFhRVh8vjdc+Y/4Ct2WB4sK2illt79A2l7WrG9vs7yV+n6T227cP2x8SBtziJU1eh4Jz/cs2nXxfsEn9eisUlZtO/em9+FVcxwzO9afF5eN6ytpWlh/Xk7atrv6y/PS6OkxCoN0CBEDbLc71EECg7wQq9gm+sr9N2mSLPssXpaqNNZrMZJ/0JK0JlqbBU2c9RUuTfSurbt7sl8kHHygupnbocXrrMRrGJE2CpUmQ1G8v7fwvRcU3Ry4CCCDQ2QKdFvRth1YIsvoAbj6Qqv3p5inoGMpH5/heqPlgbXTc15+ep6Bl3J5w7azefD3N9qN64+tkk1K0A7iHr6Fg8/h4D98gt9ZGgaknt9p4US41TYGywHVpQDUNoBYGk+2aDfPt3NJ61d5Gx5tcdzbntqrNE+PD9m/loDv1jC3T1O+/YgRA++81544RQKADBTTGZ+XA59mkTc8rbV11545k7FGNPxoet9dj9hYg9T1KN9vM9jbmaGmyb3/VTc/4xb63FSe1I560ScHSdLImHzRVAJVJm4rtyEUAAQQQqBEIj4Drj3820XlfJAXu4p63ITiqAGzYztb5vHg/3rZ/tMP5+SBuyM/qVGA2PjfetmNjY3tsfscJN76n4oZs6JwBPWdvSe1uurYyvljBejbnltWZ5fuNabbRGlJzLwVtzer1ja6/J2WTEECgPQL+5zX8nLbnkj18FZt8d2DIAqA9fIuzvDUCoLME5HQEEECgXQKVfRbbpE2LbdKmQ0svWR0ZSSdomhqPNOlNqtntLViqSZv0LaksqSfq+qfdhC2lafHirAdpMmmTZrWPepHacABM2lSqxwEEEEAAgR4WUE+eQfuGVfbEx3zf+sjIThvzdtQ3Y+XKlW4f/qg545fE90wNAZtGax9pzQVk7Wo1Adqy/Ub1qsWNjueu27Bsvq7cudNqa7iHRm3KXye/P83rFt5Lk3O3bx+1XoEVe6/bZ2hLNffUhjbXXC9cv0mbC8+JzvWn703b5+i6da6hrWG9N231leZer1DfdNd7cV1dtptT2lG1m29hTttOAHROeakcAQQQaK+AxvkctMUdfnjhhasW/FQQNOs16nuQWrD02WSMUgVLq1tt0qZGaYf1RLXFPf54aSk/3qjGHvU9SG2dTtYUJnLy45X6wb1Kq+AAAggggAACCCDQcQLMOdlxL0nDBm3atNPGkx204fqTAGjDwhxEIBXwQei9CKD6GLPO8xt7ud7L6+4Y3ZH9gYsXsliAAGixC7kIIIBATwpoEiT12nS2DB55VOE9Vq1rQzZpk3qNWlA0md0+ncjJ8tyOpPdIYQWWqZ6oWtwjD5dP2qSeonrcPg2UKkiabWtm+2U2aVMYFKfsQuQjgAACCCCAAAIIIIAAAi0U8F9BrDtlN/Wo3L590i3axuDJjd4GBEAb6XAMAQQQ6EOBinVtqBxwgHO2lD3CVx0bqx2H1I9JGgKkm3wA1QYaK9ezP4smQVYbv9TdX1xOkzZlPUiTx+yzHqQhf4lN6UlCAAEEEEAAAQQQQAABBBBAoIEAAdAGOBxCAAEEECgWqAwPu8pBB7kBW8pS1cYY85MzhcfstbZH7SefTQKkVU3a1GiKV03atHGjm7ClNC20digYqh6jvjdpMst9Zb/V6eRNtj+8qPR0DiCAAAIIIIAAAggggAACCPS+AAHQ3n+NuUMEEEBgXgQq1jtzUD00164tvH5VvUD1qLwPjKaP2duM9lULkCaBU9vWpE1hEJ2iWnZbT9Snn3ITtpQma8NUz9HwmH0aIFXgVDPbM6BXKR8HEEAAAQQQQAABBBBAAIFuFyAA2u2vIO1HAAEEulRA43tWVqxwTsvh6wrvwk/atFmTNoVxSNWLNA6W2v42G2u0UVJPVM14+/hjpaXUDvUg9b1INaO970GqfdtWvs2Uq/FTSQgggAACCCCAAAIIIIAAAt0nQAC0+14zWowAAgj0jYCftMl6aTpbSscj3bPHjyfqJ2qKe5P6CZzskXvLc5q1vkHSzPda3MMPFU/apMmjVtqkTdaOAT+j/eqpYKl/9N6CpMuXN7gChxBAAAEEEEAAAQQQQAABBOZLgADofMlzXQQQQACBlghUFixwlTVr3IAtZam6a1fSi1RB0awHaTomqYKm9ui9s8fpS9PkpD/f90QtK6R22OP0YTzSqQmc1KM0ne1+8eKys8lHAAEEEEAAAQQQQAABBBCYIwECoHMES7UIIIAAAp0jUFm0yCZtOtgmbTq4tFHV7dt9b1EFSH2gM6z9uKSWp0mbbGKm0qSeqBs32KRNG0qLOLVDPUYtIDq1Th6zD3mVhQvLz+cIAggggAACCCCAAAIIIIDAjAUIgM6YjBMQQAABBHpRoLJ0qRu0xa09rPD2/KRNelQ+C4yqB2nSezR7/H7LlsaTNqkn6lNPuglbStOSpUmANPQa1RikNi5pNpHTKnsUn0mbSvk4gAACCCCAAAIIIIAAAgjkBQiA5kXYRwABBBBAoEDAT9pkkyE5LUccUVDCYp/WQ1Q9RfVIfTKTfehNqrxk8ia3bVvhuVnmqPVEtcU99mjxeKTp5FF+cqYsSBpmt096lvpJnZi0KSNlAwEEEEAAAQQQQAABBPpbgABof7/+3D0CCCCAQAsFKoODrrJ6f+dsKZ20affuJEDqxx5NepFO6jF77VuPUgVO3a6d5a2qVl3VeppqcQ89WBwkVTvUUzRM0OQfuZ8KkvrH7ZcuK78GRxBAAAEEEEAAAQQQQACBHhIgANpDLya3ggACCCDQ+QIa47Ny4IFuwJayVN25M9eDNHnUPhmbdJMPoDobc7Q0qSfqJitny2RZIU3aFI1HWrHZ7cM4pG7hsHOLbBleVHY2+QgggAACCCCAAAIIIIBA1wgQAO2al4qGIoAAAgj0i0Bln33c4CGHOKelJFXtUXo/9qh6jaYz2Sc9SJMAaXXL5uaTNm1Y7yZsySf1XlX/0Ko9br/HAqV7rEeps3FH1cPVDdpHh6Fk7fc1Hql6nKZrbSdlk3xtFx/P1RXOr6k7lEmvHcpYGyq+XHKt2vrVPjvOEAD5l5V9BBBAAAEEEEAAAQT6VsC+JZAQQAABBBBAoNsEKsuWuUFb3GHPL2x6dXLSVTVpU3i0Pg2STj6rAKket7fH7ke2Npy0qWKP2zt7ZD8k26tJ+f2ag52wkwZjFbRNAqZTQdkkmNsggOrPDQFYC/Aq8JvVFwV8Q4A3CwwndU4Fi5Pz6gPEU3Un7UvrDwFkCz6TEEAAAQQQQAABBBBAoDUC9mmbhAACCCCAAAK9JqAekBoH1Gk54sjC26uOj9ukTZt9QDTpTarJmza5PRs3+F6lFZu1fsCCoBU9Um+Ls/JOay0KjnZ6Cm11Yy7f2vx+x92KAqA+uJoLoIYesuk6BGV9gDbqFVsc4E2DrOohq0BrUUDXB4vTcoXHk8BtFlAOdaWBYF+nnadJw0gIIIAAAggggAACCHSKgH3CJSGAAAIIIIBAPwqoV2Jlf5u0yRYLa2VpzHqO7tixw+/va2ODDg/beKC5VFUAVOOQ+iCjBVLHFRi1AKlfW8A0C5Yqz46rXJaXP64Aa1IuBFinzk/Omzo/CcKWH0/aER/PtqPr526n83aDbzrWaz5gm9/vuBsoDbCG3rO5YGwUQJ3qLWtlCgKsU8ftXeuPq1wSmFUAtv54Us4P3xAfj4PJFux39kcD9Zxm+ISOezfRIAQQQAABBBBAYNYCBEBnTUgFCCCAAAII9J+A7+FnEzqF1G39/RToygK4dQFaBXSTQKsCstl2XV4uGJsenwrW5oKxRcctYFwb/G0eTO6q3rfpEApxwDbeDu+f+V4vThswGhoSArI1AdgkaFseYE2CsFnvWAWBa87X8RCgnQra+t642fXseDacQny9UD6cn9RVGACm9214FVkjgAACCCCAAAKZgH2aIiGAAAIIIIAAAv0l4Hv5RT1buy6Am/W+DQFa9aBNA65lvW19ADbXGzcEYKNz8gHfJECb1K1rTAV4pxsADuemQeVueKvJSstYFw6foAnAFHxNA6lJQDUJpk4FYEsCqNYrdmq826SOLKAbesxmAdooGJsGcIuDt1ZPdnxqu2bs2/h4N7w/aCMCCCCAAAIIdJ0AAdCue8loMAIIIIAAAgj0u0BlwQLntFjquuCtet+mwdiiHrbZcAppULYm4BoCsHXDLShgOZ0AcL7HbRJA3qPxbq1dFjqMhnLIB4vtGmp7pye1UUtXD5+Q9HitD6gmQdkw5MFUb9xQPh9gDeWTAHBNb9usN244Jx0bN/TGrTseeucmddUEk0MAV8FnEgIIIIAAAgh0pID9C05CAAEEEEAAAQQQQKA9Ar73rR8+IRlCoRMCuBs3bvRj3S5bsaIpQtJDNgRcQw/cNPiaBmELg7EW9PXB3Li3bTz2benxtAetnVffO9eO+WBysva9dbP6J9Py1taQ102Tl+22udZyr0Z+P3d4/nezycsUeC3rIdsggKqeuz6YmgZsQzA2BFiz40lgNwsAFx4P17e6Qu9drXfuchXr2Wwzlbmq/fBNjtn4t3HaJ/82AAAfeklEQVRqhtz0PdSkgiaH61/1uHG23ez6s64/d738brPr171rcxXMun1NKmhyeLa+TW+/6f03aWCTw3vT/sqWLTbG86CbGNmaezEKdpvd4By0r6YVc11/zcUKdpref9MGFlQaZc1x/X58+uhydZvNrl93Qi5jrs+fbf02fv/Qtm1u/Jhjcw1nNwgQAA0SrBFAAAEEEEAAAQQQaCLgg04KOKVzg3VCALdJk7PD/suhAqZp0HSqd21RAFW9ZfMBVtuPgrbFx8M59T1ok/JpHVlANwSTrbwPIIdrxNdPg7jZnXTohr68qudtB/e+VR/VpSmf+jMn0911qCfNQqAFAmEax50tqIsqEOh0gUX2JML2y6/o9GbOW/sIgM4bPRdGAAEEEEAAAQQQQKB9An7ysm4ePkEB2SgoWzOBWGEP2qlgbDJ+bdQb1gdg42CrjhUEY7Ng8dSx4rrSutP21fbGtet0w/AJ7XsrciUEEEAAAQTaLkAAdI7JJ+xD0Lh9cNqirvc9lnanM7vqtrZZV+sBxj3qsVeY28kLqOfMLhsnTj/XJAR6WSD+/b59+3a3cyf9Jnr59ebeFJuatPmOxnry81pvv77W/3bIxsLVErp5deoNq3eoPj/ULWngVL1fJ9Pj9t2hooCpyqYB2NrzomBrWl8lrlfnZHWl9ab1aBgFP5SCtafpZ3c90t8oNTve6Fwdm/Pzm7W/SQPnvH2zvX6n398s29dshOsm1Yf31+SE+jrrKfj8GL1NKmhyuOkI3HN9ftP3Z5MGNDk89/fXpAFNDs99+5r8fDZ9fza9gcYXaPb6FlSv9/qEH2LIevfb4/Dx5/nGF+uOo/qcpqTPbHubCIDurdw0z1PARIuCoL2W/GNU6U0pIDSbN2Kv2XA/vSug93kv/jz37ivGne2NQP73e7y/N/VxDgKdLqD3uBZ+v3f6K9UD7dM4nlrmKcWf2QetHU2DoPPUTi6LQKsEwu/1IQ1dQkKghwXi3++9+J01/CzP5iXkt8Bs9KZxrn7RLrBHjVavXj2N0t1VZPPmzb43nFq9cuVKf5/ddQe0FoGZCaxfv94tXrzYLVu2bGYnUhqBLhPYunWr/8uxmr3CJoUZHu70rlVdBkxzO04gTIKk9zsJgV4WGBkZcaOjo/4W9Xlmn3326eXb5d4QcJs2bbK/OQy6VatWoYFATwvoqS09mau0dOlS/721l2449ACdzR/u8v3Ae8mHe0EAAQQQQAABBBBAAAEEEEAAAQQQQACBPhcgANrnbwBuHwEEEEAAAQQQQAABBBBAAAEEEEAAgV4WIADay68u94YAAggggAACCCCAAAIIIIAAAggggECfCxAA7fM3ALePAAIIIIAAAggggAACCCCAAAIIIIBALwsQAO3lV5d7QwABBBBAAAEEEEAAAQQQQAABBBBAoM8FCID2+RuA20cAAQQQQAABBBBAAAEEEEAAAQQQQKCXBQiA9vKry70hgAACCCCAAAIIIIAAAggggAACCCDQ5wIEQPv8DcDtI4AAAggggAACCCCAAAIIIIAAAggg0MsCBEB7+dXl3hBAAAEEEEAAAQQQQAABBBBAAAEEEOhzAQKgff4G4PYRQAABBBBAAAEEEEAAAQQQQAABBBDoZQECoL386nJvCCCAAAIIIIAAAggggAACCCCAAAII9LkAAdA+fwNw+wgggAACCCCAAAIIIIAAAggggAACCPSyAAHQXn51uTcEEEAAAQQQQAABBBBAAAEEEEAAAQT6XIAAaJ+/Abh9BBBAAAEEEEAAAQQQQAABBBBAAAEEelmAAGgvv7rcGwIIIIAAAggggAACCCCAAAIIIIAAAn0uQAC0z98A3D4CCCCAAAIIIIAAAggggAACCCCAAAK9LDDUyzfXKff2zDPPuJtuuqlTmtOydoyOjro9e/b4+pYtW+YGBwdbVjcVIdCJAlu3bnXDw8Nu0aJFndg82oRAywR27Njhdu/e7etbsmSJW7BgQcvqpiIEOlFgZGTEDQ0NucWLF3di82gTAi0T2LlzpxsbG/P16f2+cOHCltVNRQh0osC2bdvcwMCA0+cZEgK9LLBr1y6nRakXf7+H7yazeQ0JgM5Gb5rnPvbYY+7973//NEtTDAEEEEAAAQQQQAABBBBAAAEEEEAAAQRaJVCpWmpVZdRTLzAxMeEmJyfrD/RAzh//8R+7r3zlK/5O/vmf/9kdccQRPXBX3AICCCCAwGWXXeZuueUWD/F3f/d37oQTTgAFAQQQQKAHBD7xiU+4a6+91t/JlVde6U4//fQeuCtuAQEEEEDg+uuvd1dddZWHUAe8c845pydR9MROpVLZq3ujB+hesU3/JD0W3quPhiuwOz4+7jH0WAGPSE7/fUFJBBBAoJMF9LdRfr938itE2xBAAIG9E+D3+965cRYCCCDQDQLh87sChMRn6l8xJkGqNyEHAQQQQAABBBBAAAEEEEAAAQQQQAABBHpEgABoj7yQ3AYCCCCAAAIIIIAAAggggAACCCCAAAII1AsQAK03IQcBBBBAAAEEEEAAAQQQQAABBBBAAAEEekSAAGiPvJDcBgIIIIAAAggggAACCCCAAAIIIIAAAgjUCxAArTchBwEEEEAAAQQQQAABBBBAAAEEEEAAAQR6RKBiMwFWe+ReuI02C3zve99z69ev91d9xSte4ZYuXdrmFnA5BBBAAIG5EPjBD37gHn/8cV/1SSed5Pbdd9+5uAx1IoAAAgi0WeD+++93Dz74oL/qS1/6UrdmzZo2t4DLIYAAAgjMhcAjjzzifvzjH/uqjznmGHfooYfOxWW6uk4CoF398tF4BBBAAAEEEEAAAQQQQAABBBBAAAEEEGgkwCPwjXQ4hgACCCCAAAIIIIAAAggggAACCCCAAAJdLUAAtKtfPhqPAAIIIIAAAggggAACCCCAAAIIIIAAAo0ECIA20uEYAggggAACCCCAAAIIIIAAAggggAACCHS1AAHQrn75aDwCCCCAAAIIIIAAAggggAACCCCAAAIINBIYanSQYwgUCTz77LPupptu8jNIbtiwwR1wwAHu8MMPd29605vc/vvvX3QKeQgggAACXSCwadMmd+ONNzrNErxz506nGSQ1S/App5zSBa2niQgggAAC0xX47ne/666++mr3spe9zJ1//vnTPY1yCCCAAAIdJLBjxw73t3/7tw1bdNZZZ7kjjzyyYZl+OUgAtF9e6Rbd51133eUuv/xy/8V4cHDQ7bfffu6ee+5xd999t7v11lvde97zHnfaaae16GpUgwACCCDQLoH//u//dhdffLHbtWuXv+SyZcvcfffd5z7/+c+7M8880/3Jn/yJ0+99EgIIIIBAdwts27bNXXbZZW7jxo3u0EMP7e6bofUIIIBAHws88MAD7pZbbmkocPzxxxMATYUIgDZ8q3AwFnjyySez4Ofb3vY295a3vMUNDw+7sbExd9111/nlIx/5iDv66KP5MBXDsY0AAgh0uIC+BF966aU++PnLv/zL7o1vfKNbs2aN+5//+R/fQ+j22293Coi+853v7PA7oXkIIIAAAs0ErrrqKh/8bFaO4wgggAACnS2gp7aUTjjhBPea17ymsLFHHXVUYX4/ZhIA7cdXfS/v+bbbbvM9P08//XT39re/PatFQVA9OvPYY4859RBVuQsuuCA7zgYCCCCAQGcL/Ou//qtTj6CDDz7YXXjhhW5gIBki/OSTT/b5H/jAB/zvdwKgnf060joEEECgmcAdd9zhvvrVr7qVK1e6LVu2NCvOcQQQQACBDhYIAVAFP88+++wObmlnNC35htMZbaEVHS6gsYKUXvnKVxa2VGMIKakbNgkBBBBAoHsE1LvzpJNOcr/+67+eBT9D68PvfI35vHnz5pDNGgEEEECgywTWr1/vPvaxj/k/dp177rld1nqaiwACCCCQFwixlxe84AX5Q+wXCNADtACFrGKBv/7rv3aaAEl/MS5Kzz33nM8uO150DnkIIIAAAvMv8IY3vMFpKUoPPfSQzz7ooIPcqlWrioqQhwACCCDQ4QKTk5N+3E9NcKdH4DXGMwkBBBBAoHsFxsfHnT6nDw0NuXXr1vkbGRkZ8cMU6ildUr0AAdB6E3JKBPRDpC/ARUk/fF/+8pf9Ic0aTEIAAQQQ6G4Bje+snv9/+Zd/6W+kLEDa3XdJ6xFAAIH+ELjxxhvd97//ffcbv/EbTp/VCYD2x+vOXSKAQO8KPProo27Pnj1u7dq1Tr/jv/CFL/gOaxrKSnlvfetb3ete97reBdiLOyMAuhdonFIv8MlPftI98cQT/pGas846q74AOQgggAACXSNw5ZVX+j9q7d6928/8/r73vc+dccYZXdN+GooAAgggMCWgYOe1117r9IjkeeedN3WALQQQQACBrhUI439qLhb9jl+9erWfDOmRRx5xWj74wQ+673znO+6iiy7q2ntsdcMJgLZatA/r+9znPue06C8N733ve92iRYv6UIFbRgABBHpHQB+W9CFKs8Orh78muDv++OPdgQce2Ds3yZ0ggAACfSCg3vyayG5wcNC9//3v949K9sFtc4sIIIBAzwuE8T81lv/ll1/uP6vrpqvVqu8Nqqe4vvSlLzlNanrKKaf0vMd0bpAA6HSUKFMq8KlPfcpdf/31Pvh58cUXuxe/+MWlZTmAAAIIINAdAp/5zGdcpVLxj9Vcd9117h//8R/d//7v/7qPf/zj7rjjjuuOm6CVCCCAAALu6quvduod9K53vcsddthhiCCAAAII9IiAhjQ57bTT3IoVK2qGKtRn+F/6pV/yvUD1WPwNN9xAADR9zZkFvkfe/O2+DY01oS7VCn4uXLjQ/2X5ta99bbubwfUQQAABBOZAQB+clBYsWODe8Y53+PGD1Ivo05/+9BxcjSoRQAABBOZC4Fvf+pbvBXTiiSe6c845Zy4uQZ0IIIAAAvMkoJ6fL3rRi2qCn3FTTj/9dL/78MMPO02ER3KOHqC8C2YssG3bNqfx4DQ5xvLly91HPvIRegTNWJETEEAAge4ROPXUU90dd9zBpBnd85LRUgQQQMB98Ytf9Ao//OEP3dlnn10joj9qKX3ta19zr3/9630PIvUSIiGAAAII9IbAmjVr/I1oTP/R0VGngGm/JwKg/f4OmOH9j4yMuN///d93Dz74oDvkkEPcFVdc4Q499NAZ1kJxBBBAAIFOElDPzscff9ydf/75LnxYitunnqBKQ0N8bIhd2EYAAQQ6WUDjfmpRsDMEPEN7NUacksZ5VucGlSMhgAACCHSPwM033+xnfddEpc9//vPrGr5hwwafp05rBD8THr7J1L1NyCgT0AclzSCm4Kdmkbzqqqv8X4vLypOPAAIIINAdAnfffbe799573dFHH+1+5Vd+pa7R6vGvpOMkBBBAAIHuENCkGGXp85//vB/XWePHXXLJJWXFyEcAAQQQ6FCBf//3f3fq4a9AZ9Hv8W984xu+5cccc0yH3kH7m8UYoO0379or3nbbbe7//u///MzAH/3oRwl+du0rScMRQACBWgF9AVZST9Ann3yy5qCCn//0T//k897whjfUHGMHAQQQQAABBBBAAAEE2i+gIaqU/uM//sN3UotbcM899zj1EFXSeP6kRIAeoLwTpiWgx2auueYaX3bTpk2u0ZfgI4880l177bXTqpdCCCCAAALzL6Df6d/+9redJsx485vf7DRhxktf+lL3wAMP+A9VegLgTW96kzv55JPnv7G0AAEEEEAAAQQQQACBPhd44xvf6L75zW/6uVnOO+88d8IJJ/hFn9/vvPNOr3PBBRf4p3f7nCq7fQKgGQUbjQQ0c5jGBwppYmIibNatNZYQCQEEEECgewQ06/tll13mPvvZz7rrr7/e6ZF4LUoHHHCAu/DCC90pp5zi9/kfAggggAACCCCAAAIIzK+Axm7WnCyf+cxn3I033ujU61OLkuZp0dwtdF6ofY0q1qsjGQG7Np89BBBAAAEEEOhDAf0R64knnnCbN292a9eudfvtt18fKnDLCCCAAAIIIIAAAgh0h4A+vz/11FNuy5Ytbt26dW7p0qXd0fA2t5IAaJvBuRwCCCCAAAIIIIAAAggggAACCCCAAAIItE+ASZDaZ82VEEAAAQQQQAABBBBAAAEEEEAAAQQQQKDNAgRA2wzO5RBAAAEEEEAAAQQQQAABBBBAAAEEEECgfQIEQNtnzZUQQAABBBBAAAEEEEAAAQQQQAABBBBAoM0CBEDbDM7lEEAAAQQQQAABBBBAAAEEEEAAAQQQQKB9AgRA22fNlRBAAAEEEEAAAQQQQAABBBBAAAEEEECgzQIEQNsMzuUQQAABBBBAAAEEEEAAAQQQQAABBBBAoH0CBEDbZ82VEEAAAQQQQAABBBBAAAEEEEAAAQQQQKDNAgRA2wzO5RBAAAEEEEAAAQQQQAABBBBAAAEEEECgfQIEQNtnzZUQQAABBBBAAAEEEEAAAQQQQAABBBBAoM0CBEDbDM7lEEAAAQQQQAABBBBAAAEEEEAAAQQQQKB9AgRA22fNlRBAAAEEEEAAAQQQQAABBBBAAAEEEECgzQIEQNsMzuUQQAABBBBAAAEEagW++c1v1mawhwACCCCAAAIIIIBACwUIgLYQk6oQQAABBBBAAAEEpi+wYcMG99a3vtWddtpp0z+JkggggAACCCCAAAIIzFCAAOgMwSiOAAIIIIAAAggg0BqBP//zP3c33HCDq1arramQWhBAAAEEEEAAAQQQKBAgAFqAQhYCCCCAAAIIIIAAAggggAACCCCAAAII9IYAAdDeeB25CwQQQAABBBBAAAEEEEAAAQQQQAABBBAoEBgqyCMLAQQQQAABBBBAAIE5E3jqqafcE0884TZu3OivoUfg7777br994IEHurVr19Zde+vWre773/++X7T94he/2B1//PGFZcPJjzzyiL/GihUr3Ate8AK/feutt/r1y1/+cnfKKae4iYkJd8899/hTfuqnfsotXbrUjY+Pu+985zvua1/7mtt33319uSOOOCJU69fhvLvuussNDg66F73oRe51r3udGxoq/3i9e/dud+edd7r777/fafzTdevWOV1Ty7Jly2rqZwcBBBBAAAEEEECgdQIV+8DJoEut86QmBBBAAAEEEEAAgSYCH/rQh9zFF19cWOrd7363+/jHP54d00fVj33sY+5973ufGxsby/LDxpvf/GZ39dVXu5UrV4asbP07v/M77pOf/KQPTH7wgx90p59+utu2bVt2/AMf+IC78MIL3apVq3ze17/+dbd9+3Z37rnnOgVZ46Rgq44rUPmNb3zD/cIv/IJ77rnn4iI+IPvZz37WvfCFL6zJ187111/vLrroIqfgbz4p6Kp7/s3f/M38IfYRQAABBBBAAAEEWiDAI/AtQKQKBBBAAAEEEEAAgekLPO95z3Mnnnii23///f1JlUrF7yvv0EMPzSrauXOnD1r+0R/9kQ9+rlmzxp199tl+5nj1mlS68cYb3Ute8hJ33333ZeflN1SPAqVx8FNlfvZnf7am6M033+wDmwp+HnTQQX52+tDG733ve+5tb3ub++pXv+rOOOMMNzIy4o477jj3qle9yg0PD/t6VOa8886rm9TpC1/4gs9X8FPB1nPOOcedf/75vt06UUFX7f/BH/xBTXvYQQABBBBAAAEEEGiNAD1AW+NILQgggAACCCCAAAIzFPjd3/1dd8011/gA4q5du+rOVg/NSy65xOer7Ec/+lG3ZMmSrNznPvc532tydHTUvfa1r3V33HFHdkwboQdoyHzLW97ifuu3fssHHL/1rW859QrdsmVL1gNU5RSgvP32293JJ5/sT1Nw8ud//uf94/DKGBgY8I+7q6enAqBKCqzqcXo9Nq+kx+Jf/epX+239T4/H//jHP/aPvN97770196CgqB7Hf/TRR33++vXr/WP42clsIIAAAggggAACCMxagB6gsyakAgQQ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" width="672" /></p>
<div class="page-break-after"></div>
</div>
<div id="leave-one-out-cross-validation" class="section level2">
<h2><span class="header-section-number">2.2</span> Leave-One-Out Cross Validation</h2>
<p><em>Leave-one-out cross-validation</em> (LOOCV) is closely related to the validation set approach, but it attempts to address the methods drawbacks.</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>The LOOCV estimate for the test MSE is</p>
<p><br /><br /><br /><br /></p>
<p>LOOCV has a couple major advantages and a few disadvantages.</p>
<div class="page-break-after"></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">## perform LOOCV on the mpg dataset</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">res &lt;-<span class="st"> </span><span class="kw">data.frame</span>() <span class="co">## store results</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_len</span>(n)) { <span class="co"># repeat for each observation</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  trn &lt;-<span class="st"> </span><span class="kw">seq_len</span>(n) <span class="op">!=</span><span class="st"> </span>i <span class="co"># leave one out</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="co">## fit models</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  m0 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ, <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  m1 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">2</span>), <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  m2 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">3</span>), <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  m3 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">3</span>) <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">4</span>), <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  </a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  <span class="co">## predict on validation set</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  pred0 &lt;-<span class="st"> </span><span class="kw">predict</span>(m0, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  pred1 &lt;-<span class="st"> </span><span class="kw">predict</span>(m1, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  pred2 &lt;-<span class="st"> </span><span class="kw">predict</span>(m2, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">  pred3 &lt;-<span class="st"> </span><span class="kw">predict</span>(m3, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">  </a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  <span class="co">## estimate test MSE</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">  true_hwy &lt;-<span class="st"> </span>mpg[<span class="op">!</span>trn, ]<span class="op">$</span>hwy <span class="co"># get truth vector</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">  </a>
<a class="sourceLine" id="cb2-21" data-line-number="21">  res <span class="op">%&gt;%</span><span class="st"> </span><span class="co">## store results for use outside the loop</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22"><span class="st">    </span><span class="kw">bind_rows</span>(<span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">2</span>, <span class="dt">model =</span> <span class="st">&quot;linear&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred0)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23"><span class="st">    </span><span class="kw">bind_rows</span>(<span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">3</span>, <span class="dt">model =</span> <span class="st">&quot;quadratic&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred1)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24"><span class="st">    </span><span class="kw">bind_rows</span>(<span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">4</span>, <span class="dt">model =</span> <span class="st">&quot;cubic&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred2)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb2-25" data-line-number="25"><span class="st">    </span><span class="kw">bind_rows</span>(<span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">5</span>, <span class="dt">model =</span> <span class="st">&quot;quartic&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred3)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co">## bind predictions together</span></a>
<a class="sourceLine" id="cb2-26" data-line-number="26"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">mse =</span> (true <span class="op">-</span><span class="st"> </span>pred)<span class="op">^</span><span class="dv">2</span>) -&gt;<span class="st"> </span>res</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">}</a>
<a class="sourceLine" id="cb2-28" data-line-number="28"></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">res <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb2-30" data-line-number="30"><span class="st">  </span><span class="kw">group_by</span>(terms, model) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb2-31" data-line-number="31"><span class="st">  </span><span class="kw">summarise</span>(<span class="dt">LOOCV_test_MSE =</span> <span class="kw">mean</span>(mse)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb2-32" data-line-number="32"><span class="st">  </span><span class="kw">kable</span>()</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">terms</th>
<th align="left">model</th>
<th align="right">LOOCV_test_MSE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">2</td>
<td align="left">linear</td>
<td align="right">14.92437</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="left">quadratic</td>
<td align="right">11.91775</td>
</tr>
<tr class="odd">
<td align="right">4</td>
<td align="left">cubic</td>
<td align="right">11.78047</td>
</tr>
<tr class="even">
<td align="right">5</td>
<td align="left">quartic</td>
<td align="right">11.93978</td>
</tr>
</tbody>
</table>
</div>
<div id="k-fold-cross-validation" class="section level2">
<h2><span class="header-section-number">2.3</span> k-Fold Cross Validation</h2>
<p>An alternative to LOOCV is <span class="math inline">\(k\)</span>-fold CV.</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>The <span class="math inline">\(k\)</span>-fold CV estimate is computed by averaging</p>
<p><br /><br /><br /><br /><br /><br /></p>
<p>Why <span class="math inline">\(k\)</span>-fold over LOOCV?</p>
<div class="page-break-after"></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">## perform k-fold on the mpg dataset</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">res &lt;-<span class="st"> </span><span class="kw">data.frame</span>() <span class="co">## store results</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">## get the folds</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">k &lt;-<span class="st"> </span><span class="dv">10</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">folds &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">seq_len</span>(<span class="dv">10</span>), n, <span class="dt">replace =</span> <span class="ot">TRUE</span>) <span class="co">## approximately equal sized</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_len</span>(k)) { <span class="co"># repeat for each observation</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  trn &lt;-<span class="st"> </span>folds <span class="op">!=</span><span class="st"> </span>i <span class="co"># leave ith fold out</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  <span class="co">## fit models</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  m0 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ, <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  m1 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">2</span>), <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  m2 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">3</span>), <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">  m3 &lt;-<span class="st"> </span><span class="kw">lm</span>(hwy <span class="op">~</span><span class="st"> </span>displ <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">2</span>) <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">3</span>) <span class="op">+</span><span class="st"> </span><span class="kw">I</span>(displ<span class="op">^</span><span class="dv">4</span>), <span class="dt">data =</span> mpg[trn, ])</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">  </a>
<a class="sourceLine" id="cb3-17" data-line-number="17">  <span class="co">## predict on validation set</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">  pred0 &lt;-<span class="st"> </span><span class="kw">predict</span>(m0, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">  pred1 &lt;-<span class="st"> </span><span class="kw">predict</span>(m1, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">  pred2 &lt;-<span class="st"> </span><span class="kw">predict</span>(m2, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">  pred3 &lt;-<span class="st"> </span><span class="kw">predict</span>(m3, mpg[<span class="op">!</span>trn, ])</a>
<a class="sourceLine" id="cb3-22" data-line-number="22">  </a>
<a class="sourceLine" id="cb3-23" data-line-number="23">  <span class="co">## estimate test MSE</span></a>
<a class="sourceLine" id="cb3-24" data-line-number="24">  true_hwy &lt;-<span class="st"> </span>mpg[<span class="op">!</span>trn, ]<span class="op">$</span>hwy <span class="co"># get truth vector</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25">  </a>
<a class="sourceLine" id="cb3-26" data-line-number="26">  <span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">2</span>, <span class="dt">model =</span> <span class="st">&quot;linear&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred0) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3-27" data-line-number="27"><span class="st">    </span><span class="kw">bind_rows</span>(<span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">3</span>, <span class="dt">model =</span> <span class="st">&quot;quadratic&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred1)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3-28" data-line-number="28"><span class="st">    </span><span class="kw">bind_rows</span>(<span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">4</span>, <span class="dt">model =</span> <span class="st">&quot;cubic&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred2)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3-29" data-line-number="29"><span class="st">    </span><span class="kw">bind_rows</span>(<span class="kw">data.frame</span>(<span class="dt">terms =</span> <span class="dv">5</span>, <span class="dt">model =</span> <span class="st">&quot;quartic&quot;</span>, <span class="dt">true =</span> true_hwy, <span class="dt">pred =</span> pred3)) <span class="op">%&gt;%</span><span class="st"> </span><span class="co">## bind predictions together</span></a>
<a class="sourceLine" id="cb3-30" data-line-number="30"><span class="st">    </span><span class="kw">mutate</span>(<span class="dt">mse =</span> (true <span class="op">-</span><span class="st"> </span>pred)<span class="op">^</span><span class="dv">2</span>) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3-31" data-line-number="31"><span class="st">    </span><span class="kw">group_by</span>(terms, model) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3-32" data-line-number="32"><span class="st">    </span><span class="kw">summarise</span>(<span class="dt">mse =</span> <span class="kw">mean</span>(mse)) -&gt;<span class="st"> </span>test_mse_k</a>
<a class="sourceLine" id="cb3-33" data-line-number="33">  </a>
<a class="sourceLine" id="cb3-34" data-line-number="34">  res <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">bind_rows</span>(test_mse_k) -&gt;<span class="st"> </span>res</a>
<a class="sourceLine" id="cb3-35" data-line-number="35">}</a>
<a class="sourceLine" id="cb3-36" data-line-number="36"></a>
<a class="sourceLine" id="cb3-37" data-line-number="37"></a>
<a class="sourceLine" id="cb3-38" data-line-number="38"></a>
<a class="sourceLine" id="cb3-39" data-line-number="39"></a>
<a class="sourceLine" id="cb3-40" data-line-number="40">res <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3-41" data-line-number="41"><span class="st">  </span><span class="kw">group_by</span>(terms, model) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3-42" data-line-number="42"><span class="st">  </span><span class="kw">summarise</span>(<span class="dt">kfoldCV_test_MSE =</span> <span class="kw">mean</span>(mse)) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb3-43" data-line-number="43"><span class="st">  </span><span class="kw">kable</span>()</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">terms</th>
<th align="left">model</th>
<th align="right">kfoldCV_test_MSE</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">2</td>
<td align="left">linear</td>
<td align="right">14.77098</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="left">quadratic</td>
<td align="right">12.14423</td>
</tr>
<tr class="odd">
<td align="right">4</td>
<td align="left">cubic</td>
<td align="right">11.94037</td>
</tr>
<tr class="even">
<td align="right">5</td>
<td align="left">quartic</td>
<td align="right">11.78830</td>
</tr>
</tbody>
</table>
<p><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p><img src="data:image/png;base64,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AiyC1DjWnAkCEIAABCAAAQhAAAIQgAAEIAABCEAAAhBoMAEE0AYD53QQgAAEIAABCEAAAhCAAAQgAAEIQAACEIBA4wgggDaONWeCAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEGkwAAbTBwDkdBCAAAQhAAAIQgAAEIAABCEAAAhCAAAQg0DgCCKCNY82ZIAABCEAAAhCAAAQgAAEIQAACEIAABCAAgQYTQABtMHBOBwEIQAACEIAABCAAAQhAAAIQgAAEIAABCDSOAAJo41hzJghAAAIQgAAEIAABCEAAAhCAAAQgAAEIQKDBBBBAGwyc00EAAhCAAAQgAAEIQAACEIAABCAAAQhAAAKNI4AA2jjWnAkCEIAABCAAAQhAAAIQgAAEIAABCEAAAhBoMAEE0AYD53QQgAAEIAABCEAAAhCAAAQgAAEIQAACEIBA4wgggDaONWeCAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEGkwAAbTBwDkdBCAAAQhAAAIQgEA5gZ///OflBRxBAAIQgAAEIAABCECgjgQQQOsIk6EgAAEIQAACEIAABGZO4L777rNXvOIVdtRRR828Ey0hAAEIQAACEIAABCAwSwIIoLMERnMIQAACEIAABCAAgfoQeM973mMXX3yxTU5O1mdARoEABCAAAQhAAAIQgEAVAgigVaBQBAEIQAACEIAABCAAAQhAAAIQgAAEIAABCLQGAQTQ1riPXAUEIAABCEAAAhCAAAQgAAEIQAACEIAABCBQhUCxShlFEIAABCAAAQhAAAIQmDcCd999t9155512//33h3PIBf6aa64J+d1228322muvKefesmWL/e53vwub8o997GPtoIMOqto2dr7tttvCOVasWGGPetSjQv6b3/xm2B9xxBF25JFH2vj4uF177bWhy6Mf/WhbunSpjY2N2W9+8xv78Y9/bKtXrw7t9tlnnzhs2Md+V199tRUKBdt///3tWc96lhWL0z9ej4yM2I9+9CO7+eabTfFP9957b9M5tS1btqxsfA4gAAEIQAACEIAABOpHoM0fOAm6VD+ejAQBCEAAAhCAAAQgsAMC73vf++z000+v2upNb3qTfexjH8vq9Kj60Y9+1N75znfa8PBwVh4zL3vZy+y8886zlStXxqJs/8///M92/vnnB2HyrLPOsqOPPtr6+/uz+jPPPNNOOeUU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" width="672" /></p>
<div class="page-break-after"></div>
</div>
<div id="bias-variance-trade-off-for-k-fold-cross-validation" class="section level2">
<h2><span class="header-section-number">2.4</span> Bias-Variance Trade-off for <span class="math inline">\(k\)</span>-Fold Cross Validation</h2>
</div>
<div id="cross-validation-for-classification-problems" class="section level2">
<h2><span class="header-section-number">2.5</span> Cross-Validation for Classification Problems</h2>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
