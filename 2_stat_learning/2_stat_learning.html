<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Chapter 2: Statistical Learning" />






<meta name="description" content="Chapter 2: Statistical Learning">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","output":{"pagedown::html_paged":{"self_contained":true,"css":["../style/my-style-page.css","default-fonts","default-page","default"],"number_sections":true}},"title":"Chapter 2: Statistical Learning"}
</script>

<title>Chapter 2: Statistical Learning</title>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  let beforePaged = PagedConfig.before;
  window.PagedConfig.before = async () => {
    if (beforePaged) await beforePaged();
    return new Promise((resolve, reject) => {
      var script = document.createElement("script");
      script.type = "text/javascript";
      var src = `https://mathjax.rstudio.com/latest/MathJax.js` + "?config=TeX-MML-AM_CHTML";
      if (location.protocol !== "file:" && /^https?:/.test(src))
        src = src.replace(/^https?:/, '');
      script.src = src;
      window.MathJax = {
        AuthorInit: () => {
          MathJax.Hub.Register.StartupHook("Begin", () => {
            MathJax.Hub.Queue(resolve);
          });
        }
      };
      document.getElementsByTagName("head")[0].appendChild(script);
    });
  };
})();
</script>

<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: local('Old Standard TT Regular'), local('OldStandardTT-Regular'), url(data:font/ttf;base64,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AYoAPgIcACwC9AA+Ap4APgKeAD4DRgA+AwIAPgMCAD4CvABGArwARgK8AEYCvABGArwARgK8AEYCvABGBBgARgKoAD4CqAA+ArwARgLMAD4CbABYAsoASAMMADQDDAA0AwwANAMMADQDDAA0AwQALAQsACYC7gAuAtgAKgLYACoCjABEAe4ALgHuAC4B7gAuAe4ALgHuAC4B7gAuAe4ALgK8AC4CAAAWAbQAMAG0ADACCgAwAfQAMAHMADABzAAwAcwAMAHMADABzAAwAUoAHAIcADQCIAAcAQ4AJgEOACYBDgAmARoABwEaAAsBDv/0AUD/2gIIABwBDgAcAXQAHAMaACYCHAAmAhwAJgHwADAB8AAwAfAAMAHwADAB8AAwAfAAMAHwADAC/gAwAgYAHAH0ABoB9gAwAZoAJgGyADQCDgAcAV4AHAIWACACFgAgAhYAIAIWACACFgAgAhIAEgMIABICCAAiAhIAEgISABICEgASAbgAKAISABwCEgAcAXwAPgF8AEYCRAAwAkQAeAJEAEoCRABIAkQAOAJEAFYCRABQAkQAWgJEADwCRABOAXwAHgF8AFQBfAA0AXwARAF8ACwBfAA2AXwANgF8ADwBfAAoAXwAMgF8AB4BfABUAXwANAF8AEQBfAAsAXwANgF8ADYBfAA8AXwAKAF8ADIBfAAeAXwAVAF8ADQBfABEAXwALAF8ADYBfAA2AXwAPAF8ACgBfAAyAFL/gAM0AFQDNABUAzQARAH2AEgBwgA4ARgATgH0AIgBGABOARgASANIAE4BGABOARgATgKsAFEBGABOAdYAQAHWACIBigBWAPAAVgEYAEgBwgA4AggAAAGkAGgBpABUAXwAeAF8AEYBcgBiAXIAMAPoADwCbAA8AXIAPAFyADwB4ABsAeAAcgFKAGwBSgBbAdIASAHSAEYB0gBIARgARgEYAEgBGABIARgAAACkAAAAAAAAAkQAcAJEADQCRAA+AkQAIgLQAEACRAAOAjAAMAOsADADrAAwA6wAnAOsADADrAAwA6wAUAOsAFQDrAAwApQAMAJEADACXgA+A1wAYAF4ADABeAAwAzQAMAMSADYCHABAAoAAZAM0ADADNAAwA9QAHgJEAJoBHAB4ARwAeAJEAD4BBAAsAawALADIACgAyAAoAXEAZAGCAGQBzgBkAeQAZAFxAGQBzABkAYwAZAHkAGQAAQAAAvr/EgDsBZj8zP0iBWoAAQAAAAAAAAAAAAAAAAAAAQAABAJcAZAABQAAAooCWAAAAEsCigJYAAABXgAyAREAAAAABQAAAAAAAAAAAAAHAAAAAQAAAAAAAAAAUGZFZADAAAAiFQL6/xIA7AO0ARogAAGXAAAAAAHIAsgAAAAgAAMAAAACAAAAAwAAABQAAwABAAAAFAAEAnwAAAA8ACAABAAcAAAADQAvADkAfgD/ATEBUwK8AsYC2gLcIAkgCyAUIBogHiAiICYgMyA6IEQgdCCsISIhkSGTIhIiFf//AAAAAAANACAAMAA6AKABMQFSArsCxgLaAtwgCSALIBMgGCAcICIgJiAyIDkgRCB0IKwhIiGRIZMiEiIV//8AAf/1AAAATwAAAAD/IwAAAAD+NP4k/iPgyeDIAADgtgAA4Izgi+DC4JDgY+At4Cvfzd9W31Xeyt7FAAEAAAAAADgAAABUANwAAAGYAZoAAAAAAAAAAAAAAZIAAAGSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwCyALgAtADWAOYA6gC5AMEAwgCrANsAsADFALUAuwCvALoA4QDfAOAAtgDpAAQADAANAA8AEQAWABcAGAAZAB4AHwAgACIAIwAlAC0ALwAwADEAMgAzADgAOQA6ADsAPQC/AKwAwADzALwA/AA+AEYARwBJAEsAUABRAFIAUwBZAFoAWwBdAF4AYABoAGoAawBsAG4AbwB0AHUAdgB3AHoAvQDxAL4A4wDRALMA1ADYANUA2QDyAOwA+wDtAH0AxwDkAMYA7gD9APAA4gCfAKAA+ADlAOsArQD5AJ4AfgDIAKkAqACqALcACAAFAAYACgAHAAkACwAOABUAEgATABQAHQAaABsAHAAQACQAKQAmACcAKwAoAN0AKgA3ADQANQA2ADwALgBtAEIAPwBAAEQAQQBDAEUASABPAEwATQBOAFgAVQBWAFcASgBfAGQAYQBiAGYAYwDeAGUAcwBwAHEAcgB4AGkAeQAsAGcA9wD2AMQAwwDMAM0Ay7AALCCwAFVYRVkgIEu4AA5RS7AGU1pYsDQbsChZYGYgilVYsAIlYbkIAAgAY2MjYhshIbAAWbAAQyNEsgABAENgQi2wASywIGBmLbACLCBkILDAULAEJlqyKAEKQ0VjRbAGRVghsAMlWVJbWCEjIRuKWCCwUFBYIbBAWRsgsDhQWCGwOFlZILEBCkNFY0VhZLAoUFghsQEKQ0VjRSCwMFBYIbAwWRsgsMBQWCBmIIqKYSCwClBYYBsgsCBQWCGwCmAbILA2UFghsDZgG2BZWVkbsAErWVkjsABQWGVZWS2wAywgRSCwBCVhZCCwBUNQWLAFI0KwBiNCGyEhWbABYC2wBCwjISMhIGSxBWJCILAGI0KwBkVYG7EBCkNFY7EBCkOwBGBFY7ADKiEgsAZDIIogirABK7EwBSWwBCZRWGBQG2FSWVgjWSFZILBAU1iwASsbIbBAWSOwAFBYZVktsAUssAdDK7IAAgBDYEItsAYssAcjQiMgsAAjQmGwAmJmsAFjsAFgsAUqLbAHLCAgRSCwC0NjuAQAYiCwAFBYsEBgWWawAWNgRLABYC2wCCyyBwsAQ0VCKiGyAAEAQ2BCLbAJLLAAQyNEsgABAENgQi2wCiwgIEUgsAErI7AAQ7AEJWAgRYojYSBkILAgUFghsAAbsDBQWLAgG7BAWVkjsABQWGVZsAMlI2FERLABYC2wCywgIEUgsAErI7AAQ7AEJWAgRYojYSBksCRQWLAAG7BAWSOwAFBYZVmwAyUjYUREsAFgLbAMLCCwACNCsgsKA0VYIRsjIVkqIS2wDSyxAgJFsGRhRC2wDiywAWAgILAMQ0qwAFBYILAMI0JZsA1DSrAAUlggsA0jQlktsA8sILAQYmawAWMguAQAY4ojYbAOQ2AgimAgsA4jQiMtsBAsS1RYsQRkRFkksA1lI3gtsBEsS1FYS1NYsQRkRFkbIVkksBNlI3gtsBIssQAPQ1VYsQ8PQ7ABYUKwDytZsABDsAIlQrEMAiVCsQ0CJUKwARYjILADJVBYsQEAQ2CwBCVCioogiiNhsA4qISOwAWEgiiNhsA4qIRuxAQBDYLACJUKwAiVhsA4qIVmwDENHsA1DR2CwAmIgsABQWLBAYFlmsAFjILALQ2O4BABiILAAUFiwQGBZZrABY2CxAAATI0SwAUOwAD6yAQEBQ2BCLbATLACxAAJFVFiwDyNCIEWwCyNCsAojsARgQiBgsAFhtRERAQAOAEJCimCxEgYrsIkrGyJZLbAULLEAEystsBUssQETKy2wFiyxAhMrLbAXLLEDEystsBgssQQTKy2wGSyxBRMrLbAaLLEGEystsBsssQcTKy2wHCyxCBMrLbAdLLEJEystsCksIyCwEGJmsAFjsAZgS1RYIyAusAFdGyEhWS2wKiwjILAQYmawAWOwFmBLVFgjIC6wAXEbISFZLbArLCMgsBBiZrABY7AmYEtUWCMgLrABchshIVktsB4sALANK7EAAkVUWLAPI0IgRbALI0KwCiOwBGBCIGCwAWG1EREBAA4AQkKKYLESBiuwiSsbIlktsB8ssQAeKy2wICyxAR4rLbAhLLECHistsCIssQMeKy2wIyyxBB4rLbAkLLEFHistsCUssQYeKy2wJiyxBx4rLbAnLLEIHistsCgssQkeKy2wLCwgPLABYC2wLSwgYLARYCBDI7ABYEOwAiVhsAFgsCwqIS2wLiywLSuwLSotsC8sICBHICCwC0NjuAQAYiCwAFBYsEBgWWawAWNgI2E4IyCKVVggRyAgsAtDY7gEAGIgsABQWLBAYFlmsAFjYCNhOBshWS2wMCwAsQACRVRYsAEWsC8qsQUBFUVYMFkbIlktsDEsALANK7EAAkVUWLABFrAvKrEFARVFWDBZGyJZLbAyLCA1sAFgLbAzLACwAUVjuAQAYiCwAFBYsEBgWWawAWOwASuwC0NjuAQAYiCwAFBYsEBgWWawAWOwASuwABa0AAAAAABEPiM4sTIBFSohLbA0LCA8IEcgsAtDY7gEAGIgsABQWLBAYFlmsAFjYLAAQ2E4LbA1LC4XPC2wNiwgPCBHILALQ2O4BABiILAAUFiwQGBZZrABY2CwAENhsAFDYzgtsDcssQIAFiUgLiBHsAAjQrACJUmKikcjRyNhIFhiGyFZsAEjQrI2AQEVFCotsDgssAAWsBAjQrAEJbAEJUcjRyNhsAlDK2WKLiMgIDyKOC2wOSywABawECNCsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgsAhDIIojRyNHI2EjRmCwBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2EjICCwBCYjRmE4GyOwCENGsAIlsAhDRyNHI2FgILAEQ7ACYiCwAFBYsEBgWWawAWNgIyCwASsjsARDYLABK7AFJWGwBSWwAmIgsABQWLBAYFlmsAFjsAQmYSCwBCVgZCOwAyVgZFBYIRsjIVkjICCwBCYjRmE4WS2wOiywABawECNCICAgsAUmIC5HI0cjYSM8OC2wOyywABawECNCILAII0IgICBGI0ewASsjYTgtsDwssAAWsBAjQrADJbACJUcjRyNhsABUWC4gPCMhG7ACJbACJUcjRyNhILAFJbAEJUcjRyNhsAYlsAUlSbACJWG5CAAIAGNjIyBYYhshWWO4BABiILAAUFiwQGBZZrABY2AjLiMgIDyKOCMhWS2wPSywABawECNCILAIQyAuRyNHI2EgYLAgYGawAmIgsABQWLBAYFlmsAFjIyAgPIo4LbA+LCMgLkawAiVGsBBDWFAbUllYIDxZLrEuARQrLbA/LCMgLkawAiVGsBBDWFIbUFlYIDxZLrEuARQrLbBALCMgLkawAiVGsBBDWFAbUllYIDxZIyAuRrACJUawEENYUhtQWVggPFkusS4BFCstsEEssDgrIyAuRrACJUawEENYUBtSWVggPFkusS4BFCstsEIssDkriiAgPLAEI0KKOCMgLkawAiVGsBBDWFAbUllYIDxZLrEuARQrsARDLrAuKy2wQyywABawBCWwBCYgLkcjRyNhsAlDKyMgPCAuIzixLgEUKy2wRCyxCAQlQrAAFrAEJbAEJSAuRyNHI2EgsAQjQrAJQysgsGBQWCCwQFFYswIgAyAbswImAxpZQkIjIEewBEOwAmIgsABQWLBAYFlmsAFjYCCwASsgiophILACQ2BkI7ADQ2FkUFiwAkNhG7ADQ2BZsAMlsAJiILAAUFiwQGBZZrABY2GwAiVGYTgjIDwjOBshICBGI0ewASsjYTghWbEuARQrLbBFLLEAOCsusS4BFCstsEYssQA5KyEjICA8sAQjQiM4sS4BFCuwBEMusC4rLbBHLLAAFSBHsAAjQrIAAQEVFBMusDQqLbBILLAAFSBHsAAjQrIAAQEVFBMusDQqLbBJLLEAARQTsDUqLbBKLLA3Ki2wSyywABZFIyAuIEaKI2E4sS4BFCstsEwssAgjQrBLKy2wTSyyAABEKy2wTiyyAAFEKy2wTyyyAQBEKy2wUCyyAQFEKy2wUSyyAABFKy2wUiyyAAFFKy2wUyyyAQBFKy2wVCyyAQFFKy2wVSyzAAAAQSstsFYsswABAEErLbBXLLMBAABBKy2wWCyzAQEAQSstsFksswAAAUErLbBaLLMAAQFBKy2wWyyzAQABQSstsFwsswEBAUErLbBdLLIAAEMrLbBeLLIAAUMrLbBfLLIBAEMrLbBgLLIBAUMrLbBhLLIAAEYrLbBiLLIAAUYrLbBjLLIBAEYrLbBkLLIBAUYrLbBlLLMAAABCKy2wZiyzAAEAQistsGcsswEAAEIrLbBoLLMBAQBCKy2waSyzAAABQistsGosswABAUIrLbBrLLMBAAFCKy2wbCyzAQEBQistsG0ssQA6Ky6xLgEUKy2wbiyxADorsD4rLbBvLLEAOiuwPystsHAssAAWsQA6K7BAKy2wcSyxATorsD4rLbByLLEBOiuwPystsHMssAAWsQE6K7BAKy2wdCyxADsrLrEuARQrLbB1LLEAOyuwPistsHYssQA7K7A/Ky2wdyyxADsrsEArLbB4LLEBOyuwPistsHkssQE7K7A/Ky2weiyxATsrsEArLbB7LLEAPCsusS4BFCstsHwssQA8K7A+Ky2wfSyxADwrsD8rLbB+LLEAPCuwQCstsH8ssQE8K7A+Ky2wgCyxATwrsD8rLbCBLLEBPCuwQCstsIIssQA9Ky6xLgEUKy2wgyyxAD0rsD4rLbCELLEAPSuwPystsIUssQA9K7BAKy2whiyxAT0rsD4rLbCHLLEBPSuwPystsIgssQE9K7BAKy2wiSyzCQQCA0VYIRsjIVlCK7AIZbADJFB4sQUBFUVYMFktAAAAS7gAyFJYsQEBjlmwAbkIAAgAY3CxAAdCtVxINCAEACqxAAdCQApPCDsIJwgVBwQIKrEAB0JAClkGRQYxBh4FBAgqsQALQr0UAA8ACgAFgAAEAAkqsQAPQr0AQABAAEAAQAAEAAkqsQMARLEkAYhRWLBAiFixA2REsSYBiFFYugiAAAEEQIhjVFixAwBEWVlZWUAKUQg9CCkIFwcEDCq4Af+FsASNsQIARLMFZAYAREQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAFgAGAAYAsgAAAHIAAD/GgO0/uYC2v/uAdT/9P8SA7T+5gBYAFgAGAAYAsgAAAK6AcgAAP8aA7T+5gLa/+4CugHU//T/EgO0/uYAWABYABgAGAEI/2QCugHIAAD/GgO0/uYBCP9aAroB1P/0/xoDtP7mAFgAWAAYABgCwgEWAroByAAA/xoDtP7mAsIBDgK6AdT/9P8SA7T+5gAAAAAACABmAAMAAQQJAAAAigAAAAMAAQQJAAEAHgCKAAMAAQQJAAIADgCoAAMAAQQJAAMAQAC2AAMAAQQJAAQALgD2AAMAAQQJAAUAGgEkAAMAAQQJAAYAKgE+AAMAAQQJAA4ANAFoAEMAbwBwAHkAcgBpAGcAaAB0ACAAMgAwADEAMQAgAFQAaABlACAATwBsAGQAIABTAHQAYQBuAGQAYQByAGQAIABQAHIAbwBqAGUAYwB0ACAAQQB1AHQAaABvAHIAcwAgACgAYQBtAGsAcgB5AHUAawBvAHYAQABnAG0AYQBpAGwALgBjAG8AbQApAE8AbABkACAAUwB0AGEAbgBkAGEAcgBkACAAVABUAFIAZQBnAHUAbABhAHIAMwAuADAAMAAwADsAUABmAEUAZAA7AE8AbABkAFMAdABhAG4AZABhAHIAZABUAFQALQBSAGUAZwB1AGwAYQByAE8AbABkACAAUwB0AGEAbgBkAGEAcgBkACAAVABUACAAUgBlAGcAdQBsAGEAcgBWAGUAcgBzAGkAbwBuACAAMwAuADAAMAAwAE8AbABkAFMAdABhAG4AZABhAHIAZABUAFQALQBSAGUAZwB1AGwAYQByAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATAAAAAIAAAAAAAD/tQAyAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQIAAgADACQAyQDHAGIArQBjAK4AkAAlACYAZAAnAOkAKABlAMgAygDLACkAKgArACwAzADNAM4AzwAtAC4ALwEDADAAMQBmADIA0ADRAGcA0wCRAK8AsAAzAO0ANAA1ADYANwA4ANQA1QBoANYAOQA6ADsAPADrAD0ARABpAGsAbABqAG4AbQCgAEUARgBvAEcA6gBIAHAAcgBzAHEASQBKAEsATADXAHQAdgB3AHUATQBOAE8BBABQAFEAeABSAHkAewB8AHoAoQB9ALEAUwDuAFQAVQBWAIkAVwBYAH4AgACBAH8AWQBaAFsAXADsALoAXQDAAMEAnQCeABMAFAAVABYAFwAYABkAGgAbABwBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIAvAD0APUA9gANAD8AwwCHAB0ADwCrAAQAowAGABEAIgCiAAUACgAeABIAQgBeAGAAPgBAAAsADACzALIAEAEjAKkAqgC+AL8AxQC0ALUAtgC3AMQBJAElASYAhAC9AAcBJwCFAJYBKAAOAO8A8AC4ACAAIQAfAJMAYQCkASkACAEqASsAIwAJAIgAhgCLAIoAjACDAF8A6ABBASwBLQEuAS8AjQDeANgAjgBDANoA3QDZBE5VTEwETGRvdARsZG90CXplcm8uZG5vbQhvbmUuZG5vbQh0d28uZG5vbQp0aHJlZS5kbm9tCWZvdXIuZG5vbQlmaXZlLmRub20Ic2l4LmRub20Kc2V2ZW4uZG5vbQplaWdodC5kbm9tCW5pbmUuZG5vbQl6ZXJvLm51bXIIb25lLm51bXIIdHdvLm51bXIKdGhyZWUubnVtcglmb3VyLm51bXIJZml2ZS5udW1yCHNpeC5udW1yCnNldmVuLm51bXIKZWlnaHQubnVtcgluaW5lLm51bXIHdW5pMjA3MAd1bmkwMEI5B3VuaTAwQjIHdW5pMDBCMwd1bmkyMDc0B3VuaTIwNzUHdW5pMjA3Ngd1bmkyMDc3B3VuaTIwNzgHdW5pMjA3OQd1bmkwMEFEB3VuaTAwQTAHdW5pMjAwOQd1bmkyMDBCBEV1cm8HdW5pMjIxNQd1bmkwMEI1B2Fycm93dXAJYXJyb3dkb3duBm1pbnV0ZQZzZWNvbmQHdW5pMDJCQwd1bmkwMkJCAAAAAQAB//8ADwABAAAADAAAAAAAAAACAAwABAAEAAEAEQARAAEAGQAZAAEAJQAlAAEAMwAzAAEAOwA7AAEAPgA+AAEASwBLAAEAUwBUAAEAYABgAAEAbwBvAAEAdwB3AAEAAQAAAAoAQgBcAANERkxUABRjeXJsACBsYXRuACwABAAAAAD//wABAAAABAAAAAD//wABAAEABAAAAAD//wABAAIAA2tlcm4AFGtlcm4AFGtlcm4AFAAAAAEAAAABAAQAAgAIAAQADgTGBc4F9AACA0wABAAAA4AD6AASABcAAP/Q/9D/qP+w/1z/iP9w/8D/wP/UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/6v/g/9gAAAAAAAAAAP/Y/9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zP+4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/U/9T/0AAAAAAAAAAA/8D/qAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+o/2z/qP/A/9D/uP+4/7j/3AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4P/IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8D/ogAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2P/YAAAAAAAAAAAAAAAAAAAAAAAAAAD/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8T/yP/I/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/k/7D/wAAAAAAAAAAA/8T/sAAAAAAAAAAAAAAAAAAA/+AAAAAAAAAAAAAAAAD/6gAAAAAAAAAAAAAAAP+4/3L/gP/U/+T/zP+i/9wAAAAAAAAAAAAAAAAAAAAA/9wAAP/UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/oAAAAAAAAAAAAAAAA/+j/1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+w/5j/uP/M/9z/vP/A/9T/5AAAAAAAAAAA/+T/6AAAAAAAAAAAAAAAAAAAAAD/oP+GAAD/0AAA/9AAAP/UAAAAAAAAAAAAAAAA/8AAAAAAAAAAAAAAAAAAAAAA/3D/aAAA/7D/yP+g/2j/oAAAAAD/1P/UAAD/6P/oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/5AAAAAAAAAAAAAAAAAAAAAD/0AAAAAAAAAAAAAD/4P/o//D/kP+IAAD/wP/U/7j/qP+4AAAAAP/A/+AAAgAIAAQACgAAAAwAEAAHABYAFwAMAB4AIAAOACMAKQARACsAKwAYAC0ALQAZADAAPAAaAAEADAAxAAEAAgACAAMAAwAAAAAAAAAAAAAABAAFAAAAAAAAAAAAAAAAAAYABwAIAAAAAAAFAAUACQAJAAkACQAJAAAACQAAAAoAAAAAAAsADAANAA4ADgAOAA4ADgAPAA8AEAARABEAAgAiAAQACgALAAsACwAMAA0ADgABABcAFwABAB4AHgANACUAKQACACsALAACAC8ALwACADIAMgADADMANwAEADgAOQAFADoAOgAUADsAPAAGAD4APwAOAEAARAAPAEUARQAOAEcASQAQAEsATAAQAFEAUQASAFMAVQAVAFgAWAAVAFkAWQATAF0AXgAVAGAAYQAQAGcAZwAQAG8AcAAWAHMAcwAWAHQAdAAIAHUAdQAJAHcAeAAKALAAsQARALUAtQARAM0AzQAHAM8AzwAHAAIAYAAEAAAAiAC2AAUACAAA/+D/6P/wAAAAAAAAAAAAAP/W//AAAP/oAAAAAAAAAAAAAAAAAAAAAP/g/9D/8AAAAAAAAAAAAAAAAP/oAAAAAAAAAAAAAAAA/+D/0P/wAAIABgA+AEQAAABGAEYABwBgAGQACABmAGYADQBoAGkADgB0AHkAEAACAAcARgBGAAEAYABkAAEAZgBmAAEAaABpAAEAdAB1AAIAdgB2AAMAdwB5AAQAAgANAD4APwAFAEUARQAFAEcASQAGAEsATAAGAE0ATwAHAGAAYQAGAGIAZAAHAGYAZgAHAGcAZwAGAHQAdAABAHUAdQACAHYAdgAEAHcAeAADAAIAOAAEAAAAQAAWAAEAAwAA/0z/mgACAAIABAAKAAEAHgAeAAIAAgASAAQAAAAaABoAAQABAAAAAQACAMwAzgACAAAAAAABAAAACgBqAPQAA0RGTFQAFGN5cmwAJmxhdG4AOAAEAAAAAP//AAQAAAAEAAgADQAEAAAAAP//AAQAAQAFAAkADgAKAAFDQVQgABgAAP//AAQAAgAGAAoADwAA//8ABQADAAcACwAMABAAEWRub20AaGRub20AaGRub20AaGRub20AaGZyYWMAbmZyYWMAbmZyYWMAbmZyYWMAbmxpZ2EAeGxpZ2EAeGxpZ2EAeGxpZ2EAeGxvY2wAfm51bXIAhG51bXIAhG51bXIAhG51bXIAhAAAAAEAAgAAAAMAAwAEAAUAAAABAAYAAAABAAAAAAABAAEACQAUAHoAWABmAHoAkgDaAQIBMAAGAAAAAgAKACQAAwAAAAIAFAAuAAEAFAABAAAABwABAAEAWwADAAAAAgAaABQAAQAaAAEAAAAHAAEAAQCtAAEAAQAgAAEAAAABAAgAAQAoAAoAAQAAAAEACAABAAb/7AABAAEAuwABAAAAAQAIAAEABgAUAAIAAQB/AIgAAAAGAAAAAgAKACIAAwABABIAAQA0AAAAAQAAAAgAAQABAKcAAwABABIAAQAcAAAAAQAAAAgAAgABAIkAkgAAAAIAAQCTAJwAAAAEAAAAAQAIAAEAGgABAAgAAgAGAAwAewACAFMAfAACAFsAAQABAFAABAAAAAEACAABAB4AAgAKABQAAQAEACEAAgCtAAEABABcAAIArQABAAIAIABbAAEAAAABAAgAAgAiAA4AfQB+AH0AfgCJAIoAiwCMAI0AjgCPAJAAkQCSAAEADgAEACUAPgBgAJMAlACVAJYAlwCYAJkAmgCbAJwAAA==) format('truetype');
}
body {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;
}
blockquote {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '', 'SimKai', 'DFKai-SB', 'NSimSun', serif;
}
code {
font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;
}
pre, code {
font-size: .95em;
}
</style>
<style type="text/css">
@page {
size: 6in 9in; 
}
@page :blank {
}

.shorttitle1 {
string-set: h1-text content(text);
}
.shorttitle2 {
string-set: h2-text content(text);
}

.running-h1-title {
position: running(runningH1Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h1-title:before {
content: string(h1-text);
}
@page chapter:left {
@top-left {
content: counter(page);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}

.running-h2-title {
position: running(runningH2Title);
width: var(--running-title-width);
text-overflow: ellipsis;
overflow: hidden;
}
.running-h2-title:before {



content: string(h2-text);
}
@page chapter:right {
@top-right {
content: counter(page);
}
@top-left {
content: element(runningH2Title);
white-space: nowrap !important;
}
}

@page chapter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page);
}
}
@page :first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: none !important;
}
background-image: var(--front-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.front-cover {
break-after: recto;
}

.front-page {
counter-reset: page;
}

@page frontmatter:left {
@top-left {
content: counter(page, lower-roman);
}
@top-right {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:right {
@top-right {
content: counter(page, lower-roman);
}
@top-left {
content: element(runningH1Title);
white-space: nowrap !important;
}
}
@page frontmatter:first {
@top-left {
content: none;
}
@top-right {
content: none;
}
@bottom-right {
content: counter(page, lower-roman);
}
}

.back-cover {
break-before: verso;
}
.pagedjs_page:last-of-type {
background-image: var(--back-cover);
background-position: center;
background-size: contain;
background-repeat: no-repeat;
}

.level1 {
break-before: recto;
page: chapter;
}
.front-matter-container .level1 {
page: frontmatter;
}
.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {
break-after: avoid;
}
.footenotes {
break-before: always;
break-after: always;
}
.figure {
break-inside: avoid;
}

.main .level1:first-child h1 {
counter-reset: page;
}

caption {
break-inside: avoid;
break-after: avoid;
}
</style>
<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: hidden;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = window.location.hash.replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	global.PagedPolyfill = factory();
}(typeof self !== 'undefined' ? self : this, function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n.default || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function"){
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if(element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: theres no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, []
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), []
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), []
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, []
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), []
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		let after = node;

		if (after.nextSibling) {
			if (limiter && node === limiter) {
				return;
			}
			after = after.nextSibling;
		} else {
			while (after) {
				after = after.parentNode;
				if (limiter && after === limiter) {
					after = undefined;
					break;
				}
				if (after && after.nextSibling) {
					after = after.nextSibling;
					break;
				}
			}
		}

		return after;
	}

	function nodeBefore(node, limiter) {
		let before = node;
		if (before.previousSibling) {
			if (limiter && node === limiter) {
				return;
			}
			before = before.previousSibling;
		} else {
			while (before) {
				before = before.parentNode;
				if (limiter && before === limiter) {
					before = undefined;
					break;
				}
				if (before && before.previousSibling) {
					before = before.previousSibling;
					break;
				}
			}
		}

		return before;
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after);
		}

		return after;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				(node.dataset.page || node.dataset.afterPage)
			 ) {
			return true;
		}

		return false;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

	  /**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
	  triggerSync(){
	    var args = arguments;
	    var context = this.context;
	    var results = [];

	    this.hooks.forEach(function(task) {
	      var executing = task.apply(context, args);

	      results.push(executing);
	    });


	    return results;
	  }

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, maxChars) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.maxChars = maxChars || MAX_CHARS_PER_BREAK;
		}

		async renderTo(wrapper, source, breakToken, bounds=this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			while (!done && !newBreakToken) {
				next = walker.next();
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds);

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset=0) {
			return {
				node,
				offset
			};
		}

		shouldBreak(node) {
			let previousSibling = node.previousSibling;
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node);
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow=true, rebuild=true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function() {
						let { width, height } = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function(e) {
						let { width, height } = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let { width, height } = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if(window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						renderedNode = findElement(prevValidNode(temp), rendered);
						return;
					}

					node = findElement(renderedNode, source);
					offset = 0;
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					node = child(parent, index);
					offset = 0;
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return {
				node,
				offset
			};

		}

		findBreakToken(rendered, source, bounds=this.bounds, extract=true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);

				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});


				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds=this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let { width } = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds=this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end =  Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.floor(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						if (isElement(node) ) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.setStartBefore(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.setStartBefore(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.setStartBefore(node);
							break;
						}

					}

					if (!range && isText(node) &&
							node.textContent.trim().length &&
							window.getComputedStyle(node.parentNode)["break-inside"] !== "avoid") {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if(left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right < end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds=this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if(!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer);

			return extracted;
		}

		hyphenateAtBreak(startContainer) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length-1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (/^\w|\u00AD$/.test(prevLetter)) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += "\u2011";
				}
			}
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum+1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute('id', id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if(e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function() {
				if(this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element &&this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver( entries => {

				if (!this.listening) {
					return;
				}

				for (let entry of entries) {
					const cr = entry.contentRect;

					if (cr.height > prevHeight) {
						this.checkOverflowAfterResize(contents);
						prevHeight = wrapper.getBoundingClientRect().height;
					} else if (cr.height < prevHeight ) { // TODO: calc line height && (prevHeight - cr.height) >= 22
						this.checkUnderflowAfterResize(contents);
						prevHeight = cr.height;
					}
				}
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			// let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);
			this.removeEmpty(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);
			this.removeEmpty(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				{ acceptNode: function(node) { return NodeFilter.FILTER_ACCEPT; } },
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		removeEmpty(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_TEXT,
				{ acceptNode: function(node) {
					// Only remove more than a single space
					if (node.textContent.length > 1 && !node.textContent.trim()) {

						// Don't touch whitespace if text is preformated
						let parent = node.parentNode;
						let pre = isElement(parent) && parent.closest("pre");
						if (pre) {
							return NodeFilter.FILTER_REJECT;
						}

						return NodeFilter.FILTER_ACCEPT;
					} else {
						return NodeFilter.FILTER_REJECT;
					}
				} },
				false
			);

			let node;
			let current;
			node = treeWalker.nextNode();
			while(node) {
				current = node;
				node = treeWalker.nextNode();
				// if (!current.nextSibling || (current.nextSibling && current.nextSibling.nodeType === 1)) {
				current.parentNode.removeChild(current);
				// }
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		// isWrapper(element) {
		//   return wrappersRegex.test(element.nodeName);
		// }

		isText(node) {
			return node.tagName === "TAG";
		}

		isElement(node) {
			return node.nodeType === 1;
		}

		hasChildren(node) {
			return node.childNodes && node.childNodes.length;
		}


		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo) {
			// this.preview = preview;

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this._total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", content);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);

			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt);

			let done = false;
			let result;

			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && (true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}
		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/

		get total() {
			return this._total;
		}

		set total(num) {
			this.pagesArea.style.setProperty("--pagedjs-page-count", num);
			this._total = num;
		}

		loadFonts() {
			let fontPromises = [];
			document.fonts.forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//            item        item        item        item
	//          /------\    /------\    /------\    /------\
	//          | data |    | data |    | data |    | data |
	//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
	//          | next-+--->| next-+--->| next-+--->| next-+--> null
	//          \------/    \------/    \------/    \------/
	//             ^                                    ^
	//             |                list                |
	//             |              /------\              |
	//             \--------------+-head |              |
	//                            | tail-+--------------/
	//                            \------/
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var list = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var CssSyntaxError = function(message, source, offset, line, column) {
	    var error = createCustomError('CssSyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var error = CssSyntaxError;

	// token types (note: value shouldn't intersect with used char codes)
	var WHITESPACE = 1;
	var IDENTIFIER = 2;
	var NUMBER = 3;
	var STRING = 4;
	var COMMENT = 5;
	var PUNCTUATOR = 6;
	var CDO = 7;
	var CDC = 8;
	var ATKEYWORD = 14;
	var FUNCTION = 15;
	var URL$1 = 16;
	var RAW = 17;

	var TAB = 9;
	var N = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var TYPE = {
	    WhiteSpace:   WHITESPACE,
	    Identifier:   IDENTIFIER,
	    Number:           NUMBER,
	    String:           STRING,
	    Comment:         COMMENT,
	    Punctuator:   PUNCTUATOR,
	    CDO:                 CDO,
	    CDC:                 CDC,
	    AtKeyword:     ATKEYWORD,
	    Function:       FUNCTION,
	    Url:                 URL$1,
	    Raw:                 RAW,

	    ExclamationMark:      33,  // !
	    QuotationMark:        34,  // "
	    NumberSign:           35,  // #
	    DollarSign:           36,  // $
	    PercentSign:          37,  // %
	    Ampersand:            38,  // &
	    Apostrophe:           39,  // '
	    LeftParenthesis:      40,  // (
	    RightParenthesis:     41,  // )
	    Asterisk:             42,  // *
	    PlusSign:             43,  // +
	    Comma:                44,  // ,
	    HyphenMinus:          45,  // -
	    FullStop:             46,  // .
	    Solidus:              47,  // /
	    Colon:                58,  // :
	    Semicolon:            59,  // ;
	    LessThanSign:         60,  // <
	    EqualsSign:           61,  // =
	    GreaterThanSign:      62,  // >
	    QuestionMark:         63,  // ?
	    CommercialAt:         64,  // @
	    LeftSquareBracket:    91,  // [
	    Backslash:            92,  // \
	    RightSquareBracket:   93,  // ]
	    CircumflexAccent:     94,  // ^
	    LowLine:              95,  // _
	    GraveAccent:          96,  // `
	    LeftCurlyBracket:    123,  // {
	    VerticalLine:        124,  // |
	    RightCurlyBracket:   125,  // }
	    Tilde:               126   // ~
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we a maps for 0..127 codes only
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported
	var SYMBOL_TYPE = new SafeUint32Array(0x80);
	var PUNCTUATION = new SafeUint32Array(0x80);
	var STOP_URL_RAW = new SafeUint32Array(0x80);

	for (var i = 0; i < SYMBOL_TYPE.length; i++) {
	    SYMBOL_TYPE[i] = IDENTIFIER;
	}

	// fill categories
	[
	    TYPE.ExclamationMark,    // !
	    TYPE.QuotationMark,      // "
	    TYPE.NumberSign,         // #
	    TYPE.DollarSign,         // $
	    TYPE.PercentSign,        // %
	    TYPE.Ampersand,          // &
	    TYPE.Apostrophe,         // '
	    TYPE.LeftParenthesis,    // (
	    TYPE.RightParenthesis,   // )
	    TYPE.Asterisk,           // *
	    TYPE.PlusSign,           // +
	    TYPE.Comma,              // ,
	    TYPE.HyphenMinus,        // -
	    TYPE.FullStop,           // .
	    TYPE.Solidus,            // /
	    TYPE.Colon,              // :
	    TYPE.Semicolon,          // ;
	    TYPE.LessThanSign,       // <
	    TYPE.EqualsSign,         // =
	    TYPE.GreaterThanSign,    // >
	    TYPE.QuestionMark,       // ?
	    TYPE.CommercialAt,       // @
	    TYPE.LeftSquareBracket,  // [
	    // TYPE.Backslash,          // \
	    TYPE.RightSquareBracket, // ]
	    TYPE.CircumflexAccent,   // ^
	    // TYPE.LowLine,            // _
	    TYPE.GraveAccent,        // `
	    TYPE.LeftCurlyBracket,   // {
	    TYPE.VerticalLine,       // |
	    TYPE.RightCurlyBracket,  // }
	    TYPE.Tilde               // ~
	].forEach(function(key) {
	    SYMBOL_TYPE[Number(key)] = PUNCTUATOR;
	    PUNCTUATION[Number(key)] = PUNCTUATOR;
	});

	for (var i = 48; i <= 57; i++) {
	    SYMBOL_TYPE[i] = NUMBER;
	}

	SYMBOL_TYPE[SPACE] = WHITESPACE;
	SYMBOL_TYPE[TAB] = WHITESPACE;
	SYMBOL_TYPE[N] = WHITESPACE;
	SYMBOL_TYPE[R] = WHITESPACE;
	SYMBOL_TYPE[F] = WHITESPACE;

	SYMBOL_TYPE[TYPE.Apostrophe] = STRING;
	SYMBOL_TYPE[TYPE.QuotationMark] = STRING;

	STOP_URL_RAW[SPACE] = 1;
	STOP_URL_RAW[TAB] = 1;
	STOP_URL_RAW[N] = 1;
	STOP_URL_RAW[R] = 1;
	STOP_URL_RAW[F] = 1;
	STOP_URL_RAW[TYPE.Apostrophe] = 1;
	STOP_URL_RAW[TYPE.QuotationMark] = 1;
	STOP_URL_RAW[TYPE.LeftParenthesis] = 1;
	STOP_URL_RAW[TYPE.RightParenthesis] = 1;

	// whitespace is punctuation ...
	PUNCTUATION[SPACE] = PUNCTUATOR;
	PUNCTUATION[TAB] = PUNCTUATOR;
	PUNCTUATION[N] = PUNCTUATOR;
	PUNCTUATION[R] = PUNCTUATOR;
	PUNCTUATION[F] = PUNCTUATOR;
	// ... hyper minus is not
	PUNCTUATION[TYPE.HyphenMinus] = 0;

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME,

	    SYMBOL_TYPE: SYMBOL_TYPE,
	    PUNCTUATION: PUNCTUATION,
	    STOP_URL_RAW: STOP_URL_RAW
	};

	var PUNCTUATION$1 = _const.PUNCTUATION;
	var STOP_URL_RAW$1 = _const.STOP_URL_RAW;
	var TYPE$1 = _const.TYPE;
	var FULLSTOP = TYPE$1.FullStop;
	var PLUSSIGN = TYPE$1.PlusSign;
	var HYPHENMINUS = TYPE$1.HyphenMinus;
	var PUNCTUATOR$1 = TYPE$1.Punctuator;
	var TAB$1 = 9;
	var N$1 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var BACK_SLASH = 92;
	var E = 101; // 'e'.charCodeAt(0)

	function firstCharOffset(source) {
	    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	    if (source.charCodeAt(0) === 0xFEFF ||  // UTF-16BE
	        source.charCodeAt(0) === 0xFFFE) {  // UTF-16LE
	        return 1;
	    }

	    return 0;
	}

	function isHex(code) {
	    return (code >= 48 && code <= 57) || // 0 .. 9
	           (code >= 65 && code <= 70) || // A .. F
	           (code >= 97 && code <= 102);  // a .. f
	}

	function isNumber(code) {
	    return code >= 48 && code <= 57;
	}

	function isWhiteSpace(code) {
	    return code === SPACE$1 || code === TAB$1 || isNewline(code);
	}

	function isNewline(code) {
	    return code === R$1 || code === N$1 || code === F$1;
	}

	function getNewlineLength(source, offset, code) {
	    if (isNewline(code)) {
	        if (code === R$1 && offset + 1 < source.length && source.charCodeAt(offset + 1) === N$1) {
	            return 2;
	        }

	        return 1;
	    }

	    return 0;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (code >= 65 && code <= 90) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var refCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (testCode >= 65 && testCode <= 90) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== refCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    while (offset >= 0 && isWhiteSpace(source.charCodeAt(offset))) {
	        offset--;
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    while (offset < source.length && isWhiteSpace(source.charCodeAt(offset))) {
	        offset++;
	    }

	    return offset;
	}

	function findCommentEnd(source, offset) {
	    var commentEnd = source.indexOf('*/', offset);

	    if (commentEnd === -1) {
	        return source.length;
	    }

	    return commentEnd + 2;
	}

	function findStringEnd(source, offset, quote) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // TODO: bad string
	        if (code === BACK_SLASH) {
	            offset++;
	        } else if (code === quote) {
	            offset++;
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    while (offset < source.length && isNumber(source.charCodeAt(offset))) {
	        offset++;
	    }

	    return offset;
	}

	function findNumberEnd(source, offset, allowFraction) {
	    var code;

	    offset = findDecimalNumberEnd(source, offset);

	    // fraction: .\d+
	    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP) {
	        code = source.charCodeAt(offset + 1);

	        if (isNumber(code)) {
	            offset = findDecimalNumberEnd(source, offset + 1);
	        }
	    }

	    // exponent: e[+-]\d+
	    if (offset + 1 < source.length) {
	        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`
	            code = source.charCodeAt(offset + 1);

	            if (code === PLUSSIGN || code === HYPHENMINUS) {
	                if (offset + 2 < source.length) {
	                    code = source.charCodeAt(offset + 2);
	                }
	            }

	            if (isNumber(code)) {
	                offset = findDecimalNumberEnd(source, offset + 2);
	            }
	        }
	    }

	    return offset;
	}

	// skip escaped unicode sequence that can ends with space
	// [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
	function findEscapeEnd(source, offset) {
	    for (var i = 0; i < 7 && offset + i < source.length; i++) {
	        var code = source.charCodeAt(offset + i);

	        if (i !== 6 && isHex(code)) {
	            continue;
	        }

	        if (i > 0) {
	            offset += i - 1 + getNewlineLength(source, offset + i, code);
	            if (code === SPACE$1 || code === TAB$1) {
	                offset++;
	            }
	        }

	        break;
	    }

	    return offset;
	}

	function findIdentifierEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        if (code === BACK_SLASH) {
	            offset = findEscapeEnd(source, offset + 1);
	        } else if (code < 0x80 && PUNCTUATION$1[code] === PUNCTUATOR$1) {
	            break;
	        }
	    }

	    return offset;
	}

	function findUrlRawEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        if (code === BACK_SLASH) {
	            offset = findEscapeEnd(source, offset + 1);
	        } else if (code < 0x80 && STOP_URL_RAW$1[code] === 1) {
	            break;
	        }
	    }

	    return offset;
	}

	var utils = {
	    firstCharOffset: firstCharOffset,

	    isHex: isHex,
	    isNumber: isNumber,
	    isWhiteSpace: isWhiteSpace,
	    isNewline: isNewline,
	    getNewlineLength: getNewlineLength,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd,
	    findCommentEnd: findCommentEnd,
	    findStringEnd: findStringEnd,
	    findDecimalNumberEnd: findDecimalNumberEnd,
	    findNumberEnd: findNumberEnd,
	    findEscapeEnd: findEscapeEnd,
	    findIdentifierEnd: findIdentifierEnd,
	    findUrlRawEnd: findUrlRawEnd
	};

	var TYPE$2 = _const.TYPE;
	var NAME$1 = _const.NAME;
	var SYMBOL_TYPE$1 = _const.SYMBOL_TYPE;


	var firstCharOffset$1 = utils.firstCharOffset;
	var cmpStr$1 = utils.cmpStr;
	var isNumber$1 = utils.isNumber;
	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var findCommentEnd$1 = utils.findCommentEnd;
	var findStringEnd$1 = utils.findStringEnd;
	var findNumberEnd$1 = utils.findNumberEnd;
	var findIdentifierEnd$1 = utils.findIdentifierEnd;
	var findUrlRawEnd$1 = utils.findUrlRawEnd;

	var NULL = 0;
	var WHITESPACE$1 = TYPE$2.WhiteSpace;
	var IDENTIFIER$1 = TYPE$2.Identifier;
	var NUMBER$1 = TYPE$2.Number;
	var STRING$1 = TYPE$2.String;
	var COMMENT$1 = TYPE$2.Comment;
	var PUNCTUATOR$2 = TYPE$2.Punctuator;
	var CDO$1 = TYPE$2.CDO;
	var CDC$1 = TYPE$2.CDC;
	var ATKEYWORD$1 = TYPE$2.AtKeyword;
	var FUNCTION$1 = TYPE$2.Function;
	var URL$2 = TYPE$2.Url;
	var RAW$1 = TYPE$2.Raw;

	var N$2 = 10;
	var F$2 = 12;
	var R$2 = 13;
	var STAR = TYPE$2.Asterisk;
	var SLASH = TYPE$2.Solidus;
	var FULLSTOP$1 = TYPE$2.FullStop;
	var PLUSSIGN$1 = TYPE$2.PlusSign;
	var HYPHENMINUS$1 = TYPE$2.HyphenMinus;
	var GREATERTHANSIGN = TYPE$2.GreaterThanSign;
	var LESSTHANSIGN = TYPE$2.LessThanSign;
	var EXCLAMATIONMARK = TYPE$2.ExclamationMark;
	var COMMERCIALAT = TYPE$2.CommercialAt;
	var QUOTATIONMARK = TYPE$2.QuotationMark;
	var APOSTROPHE = TYPE$2.Apostrophe;
	var LEFTPARENTHESIS = TYPE$2.LeftParenthesis;
	var RIGHTPARENTHESIS = TYPE$2.RightParenthesis;
	var LEFTCURLYBRACKET = TYPE$2.LeftCurlyBracket;
	var RIGHTCURLYBRACKET = TYPE$2.RightCurlyBracket;
	var LEFTSQUAREBRACKET = TYPE$2.LeftSquareBracket;
	var RIGHTSQUAREBRACKET = TYPE$2.RightSquareBracket;

	var MIN_BUFFER_SIZE = 16 * 1024;
	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;
	var SafeUint32Array$1 = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	function computeLinesAndColumns(tokenizer, source) {
	    var sourceLength = source.length;
	    var start = firstCharOffset$1(source);
	    var lines = tokenizer.lines;
	    var line = tokenizer.startLine;
	    var columns = tokenizer.columns;
	    var column = tokenizer.startColumn;

	    if (lines === null || lines.length < sourceLength + 1) {
	        lines = new SafeUint32Array$1(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));
	        columns = new SafeUint32Array$1(lines.length);
	    }

	    for (var i = start; i < sourceLength; i++) {
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$2 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$2) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    tokenizer.linesAnsColumnsComputed = true;
	    tokenizer.lines = lines;
	    tokenizer.columns = columns;
	}

	function tokenLayout(tokenizer, source, startPos) {
	    var sourceLength = source.length;
	    var offsetAndType = tokenizer.offsetAndType;
	    var balance = tokenizer.balance;
	    var tokenCount = 0;
	    var prevType = 0;
	    var offset = startPos;
	    var anchor = 0;
	    var balanceCloseCode = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {
	        offsetAndType = new SafeUint32Array$1(sourceLength + 1024);
	        balance = new SafeUint32Array$1(sourceLength + 1024);
	    }

	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = code < 0x80 ? SYMBOL_TYPE$1[code] : IDENTIFIER$1;

	        balance[tokenCount] = sourceLength;

	        switch (type) {
	            case WHITESPACE$1:
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            case PUNCTUATOR$2:
	                switch (code) {
	                    case balanceCloseCode:
	                        balancePrev = balanceStart & OFFSET_MASK;
	                        balanceStart = balance[balancePrev];
	                        balanceCloseCode = balanceStart >> TYPE_SHIFT;
	                        balance[tokenCount] = balancePrev;
	                        balance[balancePrev++] = tokenCount;
	                        for (; balancePrev < tokenCount; balancePrev++) {
	                            if (balance[balancePrev] === sourceLength) {
	                                balance[balancePrev] = tokenCount;
	                            }
	                        }
	                        break;

	                    case LEFTSQUAREBRACKET:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTSQUAREBRACKET;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;

	                    case LEFTCURLYBRACKET:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTCURLYBRACKET;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;

	                    case LEFTPARENTHESIS:
	                        balance[tokenCount] = balanceStart;
	                        balanceCloseCode = RIGHTPARENTHESIS;
	                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
	                        break;
	                }

	                // /*
	                if (code === STAR && prevType === SLASH) {
	                    type = COMMENT$1;
	                    offset = findCommentEnd$1(source, offset + 1);
	                    tokenCount--; // rewrite prev token
	                    break;
	                }

	                // edge case for -.123 and +.123
	                if (code === FULLSTOP$1 && (prevType === PLUSSIGN$1 || prevType === HYPHENMINUS$1)) {
	                    if (offset + 1 < sourceLength && isNumber$1(source.charCodeAt(offset + 1))) {
	                        type = NUMBER$1;
	                        offset = findNumberEnd$1(source, offset + 2, false);
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // <!--
	                if (code === EXCLAMATIONMARK && prevType === LESSTHANSIGN) {
	                    if (offset + 2 < sourceLength &&
	                        source.charCodeAt(offset + 1) === HYPHENMINUS$1 &&
	                        source.charCodeAt(offset + 2) === HYPHENMINUS$1) {
	                        type = CDO$1;
	                        offset = offset + 3;
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // -->
	                if (code === HYPHENMINUS$1 && prevType === HYPHENMINUS$1) {
	                    if (offset + 1 < sourceLength && source.charCodeAt(offset + 1) === GREATERTHANSIGN) {
	                        type = CDC$1;
	                        offset = offset + 2;
	                        tokenCount--; // rewrite prev token
	                        break;
	                    }
	                }

	                // ident(
	                if (code === LEFTPARENTHESIS && prevType === IDENTIFIER$1) {
	                    offset = offset + 1;
	                    tokenCount--; // rewrite prev token
	                    balance[tokenCount] = balance[tokenCount + 1];
	                    balanceStart--;

	                    // 4 char length identifier and equal to `url(` (case insensitive)
	                    if (offset - anchor === 4 && cmpStr$1(source, anchor, offset, 'url(')) {
	                        // special case for url() because it can contain any symbols sequence with few exceptions
	                        anchor = findWhiteSpaceEnd$1(source, offset);
	                        code = source.charCodeAt(anchor);
	                        if (code !== LEFTPARENTHESIS &&
	                            code !== RIGHTPARENTHESIS &&
	                            code !== QUOTATIONMARK &&
	                            code !== APOSTROPHE) {
	                            // url(
	                            offsetAndType[tokenCount++] = (URL$2 << TYPE_SHIFT) | offset;
	                            balance[tokenCount] = sourceLength;

	                            // ws*
	                            if (anchor !== offset) {
	                                offsetAndType[tokenCount++] = (WHITESPACE$1 << TYPE_SHIFT) | anchor;
	                                balance[tokenCount] = sourceLength;
	                            }

	                            // raw
	                            type = RAW$1;
	                            offset = findUrlRawEnd$1(source, anchor);
	                        } else {
	                            type = URL$2;
	                        }
	                    } else {
	                        type = FUNCTION$1;
	                    }
	                    break;
	                }

	                type = code;
	                offset = offset + 1;
	                break;

	            case NUMBER$1:
	                offset = findNumberEnd$1(source, offset + 1, prevType !== FULLSTOP$1);

	                // merge number with a preceding dot, dash or plus
	                if (prevType === FULLSTOP$1 ||
	                    prevType === HYPHENMINUS$1 ||
	                    prevType === PLUSSIGN$1) {
	                    tokenCount--; // rewrite prev token
	                }

	                break;

	            case STRING$1:
	                offset = findStringEnd$1(source, offset + 1, code);
	                break;

	            default:
	                anchor = offset;
	                offset = findIdentifierEnd$1(source, offset);

	                // merge identifier with a preceding dash
	                if (prevType === HYPHENMINUS$1) {
	                    // rewrite prev token
	                    tokenCount--;
	                    // restore prev prev token type
	                    // for case @-prefix-ident
	                    prevType = tokenCount === 0 ? 0 : offsetAndType[tokenCount - 1] >> TYPE_SHIFT;
	                }

	                if (prevType === COMMERCIALAT) {
	                    // rewrite prev token and change type to <at-keyword-token>
	                    tokenCount--;
	                    type = ATKEYWORD$1;
	                }
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
	        prevType = type;
	    }

	    // finalize arrays
	    offsetAndType[tokenCount] = offset;
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    tokenizer.offsetAndType = offsetAndType;
	    tokenizer.tokenCount = tokenCount;
	    tokenizer.balance = balance;
	}

	//
	// tokenizer
	//

	var Tokenizer = function(source, startOffset, startLine, startColumn) {
	    this.offsetAndType = null;
	    this.balance = null;
	    this.lines = null;
	    this.columns = null;

	    this.setSource(source, startOffset, startLine, startColumn);
	};

	Tokenizer.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        var safeSource = String(source || '');
	        var start = firstCharOffset$1(safeSource);

	        this.source = safeSource;
	        this.firstCharOffset = start;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAnsColumnsComputed = false;

	        this.eof = false;
	        this.currentToken = -1;
	        this.tokenType = 0;
	        this.tokenStart = start;
	        this.tokenEnd = start;

	        tokenLayout(this, safeSource, start);
	        this.next();
	    },

	    lookupType: function(offset) {
	        offset += this.currentToken;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return NULL;
	    },
	    lookupNonWSType: function(offset) {
	        offset += this.currentToken;

	        for (var type; offset < this.tokenCount; offset++) {
	            type = this.offsetAndType[offset] >> TYPE_SHIFT;

	            if (type !== WHITESPACE$1) {
	                return type;
	            }
	        }

	        return NULL;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.currentToken;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenNum) {
	        if (tokenNum === this.currentToken) {
	            return this.tokenStart;
	        }

	        if (tokenNum > 0) {
	            return tokenNum < this.tokenCount
	                ? this.offsetAndType[tokenNum - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },
	    getOffsetExcludeWS: function() {
	        if (this.currentToken > 0) {
	            if ((this.offsetAndType[this.currentToken - 1] >> TYPE_SHIFT) === WHITESPACE$1) {
	                return this.currentToken > 1
	                    ? this.offsetAndType[this.currentToken - 2] & OFFSET_MASK
	                    : this.firstCharOffset;
	            }
	        }
	        return this.tokenStart;
	    },
	    getRawLength: function(startToken, endTokenType1, endTokenType2, includeTokenType2) {
	        var cursor = startToken;
	        var balanceEnd;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // belance end points to offset before start
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            // check token is stop type
	            switch (this.offsetAndType[cursor] >> TYPE_SHIFT) {
	                case endTokenType1:
	                    break loop;

	                case endTokenType2:
	                    if (includeTokenType2) {
	                        cursor++;
	                    }
	                    break loop;

	                default:
	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }

	        }

	        return cursor - this.currentToken;
	    },
	    isBalanceEdge: function(pos) {
	        var balanceStart = this.balance[this.currentToken];
	        return balanceStart < pos;
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE$1) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE$1 || this.tokenType === COMMENT$1) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.currentToken + tokenCount;

	        if (next < this.tokenCount) {
	            this.currentToken = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.currentToken = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.currentToken + 1;

	        if (next < this.tokenCount) {
	            this.currentToken = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.currentToken = this.tokenCount;
	            this.eof = true;
	            this.tokenType = NULL;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    eat: function(tokenType) {
	        if (this.tokenType !== tokenType) {
	            var offset = this.tokenStart;
	            var message = NAME$1[tokenType] + ' is expected';

	            // tweak message and offset
	            if (tokenType === IDENTIFIER$1) {
	                // when identifier is expected but there is a function or url
	                if (this.tokenType === FUNCTION$1 || this.tokenType === URL$2) {
	                    offset = this.tokenEnd - 1;
	                    message += ' but function found';
	                }
	            } else {
	                // when test type is part of another token show error for current position + 1
	                // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                if (this.source.charCodeAt(this.tokenStart) === tokenType) {
	                    offset = offset + 1;
	                }
	            }

	            this.error(message, offset);
	        }

	        this.next();
	    },
	    eatNonWS: function(tokenType) {
	        this.skipWS();
	        this.eat(tokenType);
	    },

	    consume: function(tokenType) {
	        var value = this.getTokenValue();

	        this.eat(tokenType);

	        return value;
	    },
	    consumeFunctionName: function() {
	        var name = this.source.substring(this.tokenStart, this.tokenEnd - 1);

	        this.eat(FUNCTION$1);

	        return name;
	    },
	    consumeNonWS: function(tokenType) {
	        this.skipWS();

	        return this.consume(tokenType);
	    },

	    expectIdentifier: function(name) {
	        if (this.tokenType !== IDENTIFIER$1 || cmpStr$1(this.source, this.tokenStart, this.tokenEnd, name) === false) {
	            this.error('Identifier `' + name + '` is expected');
	        }

	        this.next();
	    },

	    getLocation: function(offset, filename) {
	        if (!this.linesAnsColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	        }

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },

	    getLocationRange: function(start, end, filename) {
	        if (!this.linesAnsColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	        }

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    },

	    error: function(message, offset) {
	        var location = typeof offset !== 'undefined' && offset < this.source.length
	            ? this.getLocation(offset)
	            : this.eof
	                ? this.getLocation(findWhiteSpaceStart$1(this.source, this.source.length - 1))
	                : this.getLocation(this.tokenStart);

	        throw new error(
	            message || 'Unexpected input',
	            this.source,
	            location.offset,
	            location.line,
	            location.column
	        );
	    },

	    dump: function() {
	        var offset = 0;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	// extend with error class
	Tokenizer.CssSyntaxError = error;

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    Tokenizer[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(utils).forEach(function(key) {
	    Tokenizer[key] = utils[key];
	});

	// warm up tokenizer to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	new Tokenizer('\n\r\r\n\f<!---->//""\'\'/*\r\n\f*/1a;.\\31\t\+2{url(a);func();+1.2e3 -.4e-5 .6e+7}').getLocation();

	var Tokenizer_1 = Tokenizer;

	var tokenizer = Tokenizer_1;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateSequence(node, forceBraces, decorate) {
	    var result = node.terms.map(function(term) {
	        return generate(term, forceBraces, decorate);
	    }).join(node.combinator === ' ' ? ' ' : ' ' + node.combinator + ' ');

	    if (node.explicit || forceBraces) {
	        result = (result[0] !== ',' ? '[ ' : '[') + result + ' ]';
	    }

	    return result;
	}

	function generate(node, forceBraces, decorate) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, forceBraces, decorate) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, forceBraces, decorate) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, forceBraces, decorate);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = 0;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    if (node === null) {
	        mismatchOffset = css.length;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, lexer, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error$1 = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS$2 = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS$2 &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS$2;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS$2 &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS$2) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var findIdentifierEnd$2 = utils.findIdentifierEnd;
	var findNumberEnd$2 = utils.findNumberEnd;
	var findDecimalNumberEnd$1 = utils.findDecimalNumberEnd;
	var isHex$1 = utils.isHex;

	var SYMBOL_TYPE$2 = _const.SYMBOL_TYPE;
	var IDENTIFIER$2 = _const.TYPE.Identifier;
	var PLUSSIGN$2 = _const.TYPE.PlusSign;
	var HYPHENMINUS$3 = _const.TYPE.HyphenMinus;
	var NUMBERSIGN = _const.TYPE.NumberSign;

	var PERCENTAGE = {
	    '%': true
	};

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	function consumeFunction(token, addTokenToMatch, getNextToken) {
	    var length = 1;
	    var cursor;

	    do {
	        cursor = getNextToken(length++);
	    } while (cursor !== null && cursor.node !== token.node);

	    if (cursor === null) {
	        return false;
	    }

	    while (true) {
	        // consume tokens until cursor
	        if (addTokenToMatch() === cursor) {
	            break;
	        }
	    }

	    return true;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(token, addTokenToMatch, getNextToken) {
	    if (token === null) {
	        return false;
	    }

	    var name = token.value.toLowerCase();
	    if (name !== 'calc(' &&
	        name !== '-moz-calc(' &&
	        name !== '-webkit-calc(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function attr$1(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'attr(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function expression(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'expression(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function url(token, addTokenToMatch, getNextToken) {
	    if (token === null || token.value.toLowerCase() !== 'url(') {
	        return false;
	    }

	    return consumeFunction(token, addTokenToMatch, getNextToken);
	}

	function idSelector(token, addTokenToMatch) {
	    if (token === null) {
	        return false;
	    }

	    if (token.value.charCodeAt(0) !== NUMBERSIGN) {
	        return false;
	    }

	    if (consumeIdentifier(token.value, 1) !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function isNumber$2(str) {
	    return /^[-+]?(\d+|\d*\.\d+)([eE][-+]?\d+)?$/.test(str);
	}

	function consumeNumber(str, allowFraction) {
	    var code = str.charCodeAt(0);

	    return findNumberEnd$2(str, code === PLUSSIGN$2 || code === HYPHENMINUS$3 ? 1 : 0, allowFraction);
	}

	function consumeIdentifier(str, offset) {
	    var code = str.charCodeAt(offset);

	    if (code < 0x80 && SYMBOL_TYPE$2[code] !== IDENTIFIER$2 && code !== HYPHENMINUS$3) {
	        return offset;
	    }

	    return findIdentifierEnd$2(str, offset + 1);
	}

	function astNode(type) {
	    return function(token, addTokenToMatch) {
	        if (token === null || token.node.type !== type) {
	            return false;
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function dimension(type) {
	    return function(token, addTokenToMatch, getNextToken) {
	        if (calc(token, addTokenToMatch, getNextToken)) {
	            return true;
	        }

	        if (token === null) {
	            return false;
	        }

	        var numberEnd = consumeNumber(token.value, true);
	        if (numberEnd === 0) {
	            return false;
	        }

	        if (type) {
	            if (!type.hasOwnProperty(token.value.substr(numberEnd).toLowerCase())) {
	                return false;
	            }
	        } else {
	            var unitEnd = consumeIdentifier(token.value, numberEnd);
	            if (unitEnd === numberEnd || unitEnd !== token.value.length) {
	                return false;
	            }
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function zeroUnitlessDimension(type) {
	    var isDimension = dimension(type);

	    return function(token, addTokenToMatch, getNextToken) {
	        if (isDimension(token, addTokenToMatch, getNextToken)) {
	            return true;
	        }

	        if (token === null || Number(token.value) !== 0) {
	            return false;
	        }

	        addTokenToMatch();
	        return true;
	    };
	}

	function number(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = consumeNumber(token.value, true);
	    if (numberEnd !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function numberZeroOne(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null || !isNumber$2(token.value)) {
	        return false;
	    }

	    var value = Number(token.value);
	    if (value < 0 || value > 1) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function numberOneOrGreater(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null || !isNumber$2(token.value)) {
	        return false;
	    }

	    var value = Number(token.value);
	    if (value < 1) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	// TODO: fail on 10e-2
	function integer(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = consumeNumber(token.value, false);
	    if (numberEnd !== token.value.length) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	// TODO: fail on 10e-2
	function positiveInteger(token, addTokenToMatch, getNextToken) {
	    if (calc(token, addTokenToMatch, getNextToken)) {
	        return true;
	    }

	    if (token === null) {
	        return false;
	    }

	    var numberEnd = findDecimalNumberEnd$1(token.value, 0);
	    if (numberEnd !== token.value.length || token.value.charCodeAt(0) === HYPHENMINUS$3) {
	        return false;
	    }

	    addTokenToMatch();
	    return true;
	}

	function hexColor(token, addTokenToMatch) {
	    if (token === null || token.value.charCodeAt(0) !== NUMBERSIGN) {
	        return false;
	    }

	    var length = token.value.length - 1;

	    // valid length is 3, 4, 6 and 8 (+1 for #)
	    if (length !== 3 && length !== 4 && length !== 6 && length !== 8) {
	        return false;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHex$1(token.value.charCodeAt(i))) {
	            return false;
	        }
	    }

	    addTokenToMatch();
	    return true;
	}

	// https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	// https://drafts.csswg.org/css-values-4/#identifier-value
	function customIdent(token, addTokenToMatch) {
	    if (token === null) {
	        return false;
	    }

	    var identEnd = consumeIdentifier(token.value, 0);
	    if (identEnd !== token.value.length) {
	        return false;
	    }

	    var name = token.value.toLowerCase();

	    //  3.2. Author-defined Identifiers: the <custom-ident> type
	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (name === 'unset' || name === 'initial' || name === 'inherit') {
	        return false;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (name === 'default') {
	        return false;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)

	    addTokenToMatch();
	    return true;
	}

	var generic = {
	    'angle': zeroUnitlessDimension(ANGLE),
	    'attr()': attr$1,
	    'custom-ident': customIdent,
	    'decibel': dimension(DECIBEL),
	    'dimension': dimension(),
	    'frequency': dimension(FREQUENCY),
	    'flex': dimension(FLEX),
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'ident': astNode('Identifier'),
	    'integer': integer,
	    'length': zeroUnitlessDimension(LENGTH),
	    'number': number,
	    'number-zero-one': numberZeroOne,
	    'number-one-or-greater': numberOneOrGreater,
	    'percentage': dimension(PERCENTAGE),
	    'positive-integer': positiveInteger,
	    'resolution': dimension(RESOLUTION),
	    'semitones': dimension(SEMITONES),
	    'string': astNode('String'),
	    'time': dimension(TIME),
	    'unicode-range': astNode('UnicodeRange'),
	    'url': url,

	    // old IE stuff
	    'progid': astNode('Raw'),
	    'expression': expression
	};

	var SyntaxParseError = function(message, input, offset) {
	    var error = createCustomError('SyntaxParseError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var error$2 = {
	    SyntaxParseError: SyntaxParseError
	};

	var SyntaxParseError$1 = error$2.SyntaxParseError;

	var TAB$2 = 9;
	var N$3 = 10;
	var F$3 = 12;
	var R$3 = 13;
	var SPACE$2 = 32;

	var Tokenizer$1 = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer$1.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R$3 && code !== N$3 && code !== F$3 && code !== SPACE$2 && code !== TAB$2) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new SyntaxParseError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer$1;

	var TAB$3 = 9;
	var N$4 = 10;
	var F$4 = 12;
	var R$4 = 13;
	var SPACE$3 = 32;
	var EXCLAMATIONMARK$1 = 33;    // !
	var NUMBERSIGN$1 = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE$1 = 39;         // '
	var LEFTPARENTHESIS$1 = 40;    // (
	var RIGHTPARENTHESIS$1 = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$3 = 43;           // +
	var COMMA = 44;              // ,
	var LESSTHANSIGN$1 = 60;       // <
	var GREATERTHANSIGN$1 = 62;    // >
	var QUESTIONMARK = 63;       // ?
	var COMMERCIALAT$1 = 64;       // @
	var LEFTSQUAREBRACKET$1 = 91;  // [
	var RIGHTSQUAREBRACKET$1 = 93; // ]
	var LEFTCURLYBRACKET$1 = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET$1 = 125; // }
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos + 1)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET$1);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET$1) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET$1);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$3:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN$1:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET$1) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET$1:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN$1);
	    tokenizer.eat(APOSTROPHE$1);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE$1);
	    tokenizer.eat(GREATERTHANSIGN$1);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	function readType(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN$1);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS$1 &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS$1) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    tokenizer.eat(GREATERTHANSIGN$1);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS$1) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET$1);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET$1);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK$1) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET$1:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET$1:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN$1:
	            return tokenizer.nextCharCode() === APOSTROPHE$1
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE$1:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$3:
	        case TAB$3:
	        case N$4:
	        case R$4:
	        case F$4:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT$1:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$3:
	        case QUESTIONMARK:
	        case NUMBERSIGN$1:
	        case EXCLAMATIONMARK$1:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET$1:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(str) {
	    var tokenizer = new tokenizer$1(str);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== str.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node, context);
	};

	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = null;
	        var tokens = [];

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                if (tokens.length > 0) {
	                    switch (curNode.type) {
	                        case 'Dimension':
	                        case 'HexColor':
	                        case 'IdSelector':
	                        case 'Percentage':
	                            if (prev.node === curNode) {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;

	                        case 'Function':
	                        case 'PseudoClassSelector':
	                        case 'PseudoElementSelector':
	                        case 'Url':
	                            if (chunk === '(') {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;

	                        case 'Atrule':
	                            if (prev.node === curNode && prev.value === '@') {
	                                prev.value += chunk;
	                                return;
	                            }
	                            break;
	                    }
	                }

	                tokens.push(prev = {
	                    value: chunk,
	                    node: curNode
	                });
	            },
	            result: function() {
	                return tokens;
	            }
	        };
	    }
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$2 = 40;  // (
	var RIGHTPARENTHESIS$2 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$2 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$2
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;

	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 10000;
	var totalIterationCount = 0;

	function mapList(list, fn) {
	    var result = [];

	    while (list) {
	        result.unshift(fn(list));
	        list = list.prev;
	    }

	    return result;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    token = token.value.charAt(token.value.length - 1);

	    return (
	        token === ',' ||
	        token === '(' ||
	        token === '[' ||
	        token === '/'
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    token = token.value.charAt(0);

	    return (
	        token === ')' ||
	        token === ']' ||
	        token === '/'
	    );
	}

	function internalMatch(tokens, syntax, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenCursor++;
	            token = tokenCursor < tokens.length ? tokens[tokenCursor] : null;
	        } while (token !== null && !/\S/.test(token.value));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenCursor + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function pushThenStack(nextSyntax) {
	        thenStack = {
	            nextSyntax: nextSyntax,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextSyntax) {
	        elseStack = {
	            nextSyntax: nextSyntax,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenCursor: tokenCursor,
	            token: token,
	            prev: elseStack
	        };
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: syntax.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();

	        if (tokenCursor > longestMatch) {
	            longestMatch = tokenCursor;
	        }

	        return matchStack.token;
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: syntax,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: syntax.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    var iterationCount = 0;
	    var exitReason = EXIT_REASON_MATCH;

	    var matchStack = { type: 'Stub', syntax: null, token: null, tokenCursor: -1, prev: null };
	    var longestMatch = 0;
	    var tokenCursor = -1;
	    var token = null;

	    moveToNextToken();

	    while (true) {
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? x.type + '!' + x.syntax.name : null),
	        //         elseStack: mapList(elseStack, x => x.id),
	        //         thenStack: mapList(thenStack, x => x.id),
	        //         token: token && token.value,
	        //         tokenCursor,
	        //         syntax
	        //     }, { depth: null })
	        // );

	        // prevent infinite loop
	        if (++iterationCount === ITERATION_LIMIT) {
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            break;
	        }

	        if (syntax === MATCH$1) {
	            if (thenStack === null) {
	                // turn to MISMATCH when some tokens left unmatched
	                if (token !== null) {
	                    // doesn't mismatch if just one token left and it's an IE hack
	                    if (tokenCursor !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                        syntax = MISMATCH$1;
	                        continue;
	                    }
	                }

	                // break the main loop, return a result - MATCH
	                exitReason = EXIT_REASON_MATCH;
	                break;
	            }

	            // go to next syntax (`then` branch)
	            syntax = thenStack.nextSyntax;

	            // check match is not empty
	            if (syntax === DISALLOW_EMPTY$1) {
	                if (thenStack.matchStack.token === matchStack.token) {
	                    syntax = MISMATCH$1;
	                    continue;
	                } else {
	                    syntax = MATCH$1;
	                }
	            }

	            // close syntax if needed
	            while (syntaxStack !== null && thenStack.syntaxStack !== syntaxStack) {
	                closeSyntax();
	            }

	            // pop stack
	            thenStack = thenStack.prev;
	            continue;
	        }

	        if (syntax === MISMATCH$1) {
	            if (elseStack === null) {
	                // break the main loop, return a result - MISMATCH
	                exitReason = EXIT_REASON_MISMATCH;
	                break;
	            }

	            // go to next syntax (`else` branch)
	            syntax = elseStack.nextSyntax;

	            // restore all the rest stack states
	            thenStack = elseStack.thenStack;
	            syntaxStack = elseStack.syntaxStack;
	            matchStack = elseStack.matchStack;
	            tokenCursor = elseStack.tokenCursor;
	            token = elseStack.token;

	            // pop stack
	            elseStack = elseStack.prev;
	            continue;
	        }

	        switch (syntax.type) {
	            case 'MatchGraph':
	                syntax = syntax.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (syntax.else !== MISMATCH$1) {
	                    pushElseStack(syntax.else);
	                }

	                if (syntax.then !== MATCH$1) {
	                    pushThenStack(syntax.then);
	                }

	                syntax = syntax.match;
	                break;

	            case 'MatchOnce':
	                syntax = {
	                    type: 'MatchOnceBuffer',
	                    terms: syntax.terms,
	                    all: syntax.all,
	                    matchStack: matchStack,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                if (syntax.index === syntax.terms.length) {
	                    // if no matches during a cycle
	                    if (syntax.matchStack === matchStack) {
	                        // no matches at all or it's required all terms to be matched
	                        if (syntax.mask === 0 || syntax.all) {
	                            syntax = MISMATCH$1;
	                            break;
	                        }

	                        // a partial match is ok
	                        syntax = MATCH$1;
	                        break;
	                    } else {
	                        // start trying to match from the start
	                        syntax.index = 0;
	                        syntax.matchStack = matchStack;
	                    }
	                }

	                for (; syntax.index < syntax.terms.length; syntax.index++) {
	                    if ((syntax.mask & (1 << syntax.index)) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(syntax);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            buffer: syntax
	                        });

	                        // match
	                        syntax = syntax.terms[syntax.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                syntax = syntax.buffer;

	                var newMask = syntax.mask | (1 << (syntax.index - 1));

	                // all terms are matched
	                if (newMask === (1 << syntax.terms.length) - 1) {
	                    syntax = MATCH$1;
	                    continue;
	                }

	                syntax = {
	                    type: 'MatchOnceBuffer',
	                    terms: syntax.terms,
	                    all: syntax.all,
	                    matchStack: syntax.matchStack,
	                    index: syntax.index,
	                    mask: newMask
	                };

	                break;

	            case 'Enum':
	                var name = token !== null ? token.value.toLowerCase() : '';

	                // drop \0 and \9 hack from keyword name
	                if (name.indexOf('\\') !== -1) {
	                    name = name.replace(/\\[09].*$/, '');
	                }

	                if (hasOwnProperty$1.call(syntax.map, name)) {
	                    syntax = syntax.map[name];
	                } else {
	                    syntax = MISMATCH$1;
	                }

	                break;

	            case 'Generic':
	                syntax = syntax.fn(token, addTokenToMatch, getNextToken) ? MATCH$1 : MISMATCH$1;
	                break;

	            case 'Type':
	            case 'Property':
	                openSyntax();

	                var syntaxDict = syntax.type === 'Type' ? 'types' : 'properties';

	                if (hasOwnProperty$1.call(syntaxes, syntaxDict) && syntaxes[syntaxDict][syntax.name]) {
	                    syntax = syntaxes[syntaxDict][syntax.name].match;
	                } else {
	                    syntax = undefined;
	                }

	                if (!syntax) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (syntaxStack.syntax.type === 'Type'
	                            ? '<' + syntaxStack.syntax.name + '>'
	                            : '<\'' + syntaxStack.syntax.name + '\'>')
	                    );
	                }

	                break;

	            case 'Keyword':
	                var name = syntax.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (keywordName.toLowerCase() === name) {
	                        addTokenToMatch();

	                        syntax = MATCH$1;
	                        break;
	                    }
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && token.value.toLowerCase() === syntax.name) {
	                    addTokenToMatch();

	                    syntax = MATCH$1;
	                    break;
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === syntax.value) {
	                    addTokenToMatch();

	                    syntax = MATCH$1;
	                    break;
	                }

	                syntax = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.value === ',') {
	                    if (isCommaContextStart(matchStack.token)) {
	                        syntax = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        syntax = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    syntax = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            // case 'String':
	            // TODO: strings with length other than 1 char

	            default:
	                throw new Error('Unknown node type: ' + syntax.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    if (exitReason === EXIT_REASON_MATCH) {
	        while (syntaxStack !== null) {
	            closeSyntax();
	        }
	    } else {
	        matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph$$1, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph$$1, syntaxes || {});

	    if (matchResult.match !== null) {
	        matchResult.match = mapList(matchResult.match, function(item) {
	            if (item.type === OPEN_SYNTAX || item.type === CLOSE_SYNTAX) {
	                return { type: item.type, syntax: item.syntax };
	            }

	            return {
	                syntax: item.syntax,
	                token: item.token && item.token.value,
	                node: item.token && item.token.node
	            };
	        }).slice(1);
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph$$1, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph$$1, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var cursor = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph$$1.syntax || null,
	        match: []
	    };
	    var stack = [host];

	    // revert a list
	    var prev = null;
	    var next = null;
	    while (cursor !== null) {
	        next = cursor.prev;
	        cursor.prev = prev;
	        prev = cursor;
	        cursor = next;
	    }

	    // init the cursor to start with 2nd item since 1st is a stub item
	    cursor = prev.prev;

	    // build a tree
	    while (cursor !== null && cursor.syntax !== null) {
	        var entry = cursor;

	        switch (entry.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: entry.syntax,
	                    match: []
	                });
	                stack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                stack.pop();
	                host = stack[stack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: entry.syntax || null,
	                    token: entry.token.value,
	                    node: entry.token.node
	                });
	        }

	        cursor = cursor.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list$$1) {
	                if (node === start) {
	                    var nodes = new list();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list$$1,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof list;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error$1.SyntaxReferenceError;
	var MatchError$1 = error$1.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords = buildMatchGraph$1(parse_1('inherit | initial | unset'));
	var cssWideKeywordsWithExpression = buildMatchGraph$1(parse_1('inherit | initial | unset | <expression>'));

	function dumpMapSyntax(map, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst ? map[name].syntax : generate_1(map[name].syntax);
	        }
	    }

	    return result;
	}

	function valueHasVar(value) {
	    var hasVar = false;

	    this.syntax.walk(value, function(node) {
	        if (node.type === 'Function' && node.name.toLowerCase() === 'var') {
	            hasVar = true;
	        }
	    });

	    return hasVar;
	}

	function buildMatchResult(match$$1, error, iterations) {
	    return {
	        matched: match$$1,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, node, useCommon) {
	    if (!node) {
	        return buildMatchResult(null, new Error('Node is undefined'));
	    }

	    if (valueHasVar.call(lexer, node)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    var tokens = lexer.syntax.generate(node, astToTokens);
	    var result;

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, lexer, syntax.syntax, node, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure$$1) {
	    this.valueCommonSyntax = cssWideKeywords;
	    this.syntax = syntax;
	    this.generic = false;
	    this.properties = {};
	    this.types = {};
	    this.structure = structure$$1 || getStructureFromConfig(config);

	    if (config) {
	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure$$1 = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure$$1.hasOwnProperty(node.type)) {
	                structure$$1[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic.expression) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (!syntax || !syntax.type) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (!syntax.match) {
	            syntax = this.createDescriptor(syntax);
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var grammar = {
	    SyntaxParseError: error$2.SyntaxParseError,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var TYPE$3 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$3.WhiteSpace;
	var COMMENT$2 = TYPE$3.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var noop$3 = function() {};

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new tokenizer(),
	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new list();
	        },
	        createSingleNodeList: function(node) {
	            return new list().appendData(node);
	        },
	        getFirstListNode: function(list$$1) {
	            return list$$1 && list$$1.first();
	        },
	        getLastListNode: function(list$$1) {
	            return list$$1.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.currentToken;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.scanner.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list$$1) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list$$1);
	                var tail = this.getLastListNode(list$$1);
	                return this.scanner.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        parser.scanner.setSource(source, options.offset, options.line, options.column);
	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.scanner.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var binarySearch = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;

	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	  // This function terminates when one of the following is true:
	  //
	  //   1. We find the exact element we are looking for.
	  //
	  //   2. We did not find the exact element, but we can return the index of
	  //      the next-closest element.
	  //
	  //   3. We did not find the exact element, and there is no next-closest
	  //      element than the one we are searching for, so we return -1.
	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
	  if (cmp === 0) {
	    // Found the element we are looking for.
	    return mid;
	  }
	  else if (cmp > 0) {
	    // Our needle is greater than aHaystack[mid].
	    if (aHigh - mid > 1) {
	      // The element is in the upper half.
	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // The exact needle element was not found in this haystack. Determine if
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return aHigh < aHaystack.length ? aHigh : -1;
	    } else {
	      return mid;
	    }
	  }
	  else {
	    // Our needle is less than aHaystack[mid].
	    if (mid - aLow > 1) {
	      // The element is in the lower half.
	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return mid;
	    } else {
	      return aLow < 0 ? -1 : aLow;
	    }
	  }
	}

	/**
	 * This is an implementation of binary search which will always try and return
	 * the index of the closest element if there is no exact hit. This is because
	 * mappings between original and generated line/col pairs are single points,
	 * and there is an implicit region between each of them, so a miss just means
	 * that you aren't on the very start of a region.
	 *
	 * @param aNeedle The element you are looking for.
	 * @param aHaystack The array that is being searched.
	 * @param aCompare A function which takes the needle and an element in the
	 *     array and returns -1, 0, or 1 depending on whether the needle is less
	 *     than, equal to, or greater than the element, respectively.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	 */
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	  if (aHaystack.length === 0) {
	    return -1;
	  }

	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	  if (index < 0) {
	    return -1;
	  }

	  // We have found either the exact element, or the next-closest element than
	  // the one we are searching for. However, there may be more than one such
	  // element. Make sure we always return the smallest of these.
	  while (index - 1 >= 0) {
	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	      break;
	    }
	    --index;
	  }

	  return index;
	};
	});
	var binarySearch_1 = binarySearch.GREATEST_LOWER_BOUND;
	var binarySearch_2 = binarySearch.LEAST_UPPER_BOUND;
	var binarySearch_3 = binarySearch.search;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	var quickSort_1 = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};

	var quickSort = {
		quickSort: quickSort_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$2 = arraySet.ArraySet;

	var quickSort$1 = quickSort.quickSort;

	function SourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap)
	    : new BasicSourceMapConsumer(sourceMap);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	};

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      if (source != null && sourceRoot != null) {
	        source = util.join(sourceRoot, source);
	      }
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: Optional. the column number in the original source.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    if (this.sourceRoot != null) {
	      needle.source = util.relative(this.sourceRoot, needle.source);
	    }
	    if (!this._sources.has(needle.source)) {
	      return [];
	    }
	    needle.source = this._sources.indexOf(needle.source);

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	var SourceMapConsumer_1 = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The only parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet$2.fromArray(names.map(String), true);
	  this._sources = ArraySet$2.fromArray(sources, true);

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet$2.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet$2.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort$1(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._sources.toArray().map(function (s) {
	      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	    }, this);
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64Vlq.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort$1(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort$1(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          if (this.sourceRoot != null) {
	            source = util.join(this.sourceRoot, source);
	          }
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    if (this.sourceRoot != null) {
	      aSource = util.relative(this.sourceRoot, aSource);
	    }

	    if (this._sources.has(aSource)) {
	      return this.sourcesContent[this._sources.indexOf(aSource)];
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + aSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    if (this.sourceRoot != null) {
	      source = util.relative(this.sourceRoot, source);
	    }
	    if (!this._sources.has(source)) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	    source = this._sources.indexOf(source);

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The only parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet$2();
	  this._names = new ArraySet$2();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        if (section.consumer.sourceRoot !== null) {
	          source = util.join(section.consumer.sourceRoot, source);
	        }
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = section.consumer._names.at(mapping.name);
	        this._names.add(name);
	        name = this._names.indexOf(name);

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort$1(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort$1(this.__originalMappings, util.compareByOriginalPositions);
	  };

	var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

	var sourceMapConsumer = {
		SourceMapConsumer: SourceMapConsumer_1,
		BasicSourceMapConsumer: BasicSourceMapConsumer_1,
		IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;


	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are accessed by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var remainingLinesIndex = 0;
	    var shiftNextLine = function() {
	      var lineContents = getNextLine();
	      // The last line of a file might not have a newline.
	      var newLine = getNextLine() || "";
	      return lineContents + newLine;

	      function getNextLine() {
	        return remainingLinesIndex < remainingLines.length ?
	            remainingLines[remainingLinesIndex++] : undefined;
	      }
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[remainingLinesIndex];
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[remainingLinesIndex];
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLinesIndex < remainingLines.length) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.splice(remainingLinesIndex).join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator$1(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	var SourceNode_1 = SourceNode;

	var sourceNode = {
		SourceNode: SourceNode_1
	};

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	var SourceMapGenerator$2 = sourceMapGenerator.SourceMapGenerator;
	var SourceMapConsumer$1 = sourceMapConsumer.SourceMapConsumer;
	var SourceNode$1 = sourceNode.SourceNode;

	var sourceMap = {
		SourceMapGenerator: SourceMapGenerator$2,
		SourceMapConsumer: SourceMapConsumer$1,
		SourceNode: SourceNode$1
	};

	var SourceMapGenerator$3 = sourceMap.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap$1 = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$3();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap$1(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof list === false) {
	                        node.children = new list().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof list) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = reverse ? config.fields.slice().reverse() : config.fields;
	    var body = fields.map(function(field) {
	        var ref = 'node.' + field.name;
	        var line;

	        if (field.type === 'list') {
	            line = reverse
	                ? ref + '.forEachRight(walk);'
	                : ref + '.forEach(walk);';
	        } else {
	            line = 'walk(' + ref + ');';
	        }

	        if (field.nullable) {
	            line = 'if (' + ref + ') {\n    ' + line + '}';
	        }

	        return line;
	    });

	    if (config.context) {
	        body = [].concat(
	            'var old = context.' + config.context + ';',
	            'context.' + config.context + ' = node;',
	            body,
	            'context.' + config.context + ' = old;'
	        );
	    }

	    return new Function('node', 'context', 'walk', body.join('\n'));
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    return function walk(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof list) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        var res = {};
	        for (var key in value) {
	            if (hasOwnProperty$5.call(value, key)) {
	                res[key] = value[key];
	            }
	        }
	        return res;
	    } else {
	        return value;
	    }
	}

	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function assign$1(dest, src) {
	    for (var key in src) {
	        dest[key] = src[key];
	    }

	    return dest;
	}

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: list,
	        Tokenizer: tokenizer,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        grammar: grammar,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        parse: parse,
	        walk: walk,
	        generate: generate,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, assign$1)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var appearance = {
		syntax: "auto | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var border = {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	};
	var opacity = {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var quotes = {
		syntax: "none | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var rotate = {
		syntax: "none | [ x | y | z | <number>{3} ]? && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"animation-timing-function": {
		syntax: "<single-timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		appearance: appearance,
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		border: border,
		"border-block-end": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-end-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-end-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-block-start-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-bottom": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-bottom-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-inline-end": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-end-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-inline-start-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-left": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-left-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-right-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"border-style": {
		syntax: "<br-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top": {
		syntax: "<br-width> || <br-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-style": {
		syntax: "<br-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-top-width": {
		syntax: "<br-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"border-width": {
		syntax: "<br-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-after": {
		syntax: "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-before": {
		syntax: "auto | avoid | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "paged",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		margin: margin,
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-block-end": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-block-start": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-inline-end": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-inline-start": {
		syntax: "<'left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angle",
		percentages: "no",
		groups: [
			"CSS Motion"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-style": {
		syntax: "auto | <br-style>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"outline-width": {
		syntax: "<br-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "<'overflow'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overflow-inline": {
		syntax: "<'overflow'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		padding: padding,
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		scale: scale,
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete"
	},
		"scroll-snap-type": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"shape-image-threshold": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"transition-timing-function": {
		syntax: "<single-transition-timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		default: properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"br-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"br-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color> <length-percentage>?"
	},
		"color-stop-list": {
		syntax: "<color-stop>#{2,}"
	},
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | subgrid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> {\n  <feature-value-declaration-list>\n}"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frames-timing-function": {
		syntax: "frames(<integer>)"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( [ [ <image> | <string> ]? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <border-radius> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number> [, <number> ]{5,5} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number> [, <number> ]{15,15} )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> {\n  <declaration-list>\n}"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( <angle> )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , <angle> )"
	},
		"rotateX()": {
		syntax: "rotateX( <angle> )"
	},
		"rotateY()": {
		syntax: "rotateY( <angle> )"
	},
		"rotateZ()": {
		syntax: "rotateZ( <angle> )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> [, <number> ]? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( <angle> [, <angle> ]? )"
	},
		"skewX()": {
		syntax: "skewX( <angle> )"
	},
		"skewY()": {
		syntax: "skewY( <angle> )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <single-timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function> | <frames-timing-function>"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <single-transition-timing-function> || <time>"
	},
		"single-transition-timing-function": {
		syntax: "<single-timing-function>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, [ start | end ] ]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> [, <length-percentage> ]? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | integer | color | url | integer | number | length | angle | time | frequency | em | ex | px | rem | vw | vh | vmin | vmax | mm | q | cm | in | pt | pc | deg | grad | rad | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> [, <declaration-value> ]? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		attachment: attachment,
		box: box,
		color: color$1,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		default: syntaxes
	});

	var properties$3 = {
		"--*": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-line-clamp": {
			comment: "non-standard and deprecated but may still using by some sites",
			syntax: "<positive-integer>"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-mask-clip": {
			comment: "change type to <-webkit-mask-clip-style> since it differ from <mask-clip>, extra space between [ and ,",
			syntax: "<-webkit-mask-clip-style> [, <-webkit-mask-clip-style> ]*"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			refenrences: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "none | inline | block | list-item | inline-list-item | inline-block | inline-table | table | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | flex | inline-flex | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter>"
		},
		font: {
			comment: "extend with non-standard fonts",
			syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar | <-non-standard-font>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		"line-height-step": {
			comment: "fix extra spaces around",
			syntax: "none | <length>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "visible | hidden | scroll | auto | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"transform-origin": {
			comment: "move first group to the end since less collecting",
			syntax: "[ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>? | [ <length-percentage> | left | center | right | top | bottom ]"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<unicode-range>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"word-break": {
			comment: "extend with non-standard keywords",
			syntax: "normal | break-all | keep-all | <-non-standard-word-break>"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to duoble sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			preferences: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-non-standard-word-break": {
			comment: "non-standard keywords https://css-tricks.com/almanac/properties/w/word-break/",
			syntax: "break-word"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter": {
			syntax: "[ <progid> | FlipH | FlipV ]+"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr()": {
			comment: "drop it since it's a generic",
			syntax: null
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"inset()": {
			comment: "changed <border-radius> to <'border-radius'>",
			syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added -webkit-gradient() since may to be used for legacy support",
			syntax: "<-legacy-gradient> | <linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"matrix()": {
			comment: "redundant max",
			syntax: "matrix( <number> [, <number> ]{5} )"
		},
		"matrix3d()": {
			comment: "redundant max",
			syntax: "matrix3d( <number> [, <number> ]{15} )"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "replaced <ident> to list of colors according to https://www.w3.org/TR/css-color-4/#named-colors",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		"outline-radius": {
			comment: "missed, looks like it's a similar to <border-radius> https://developer.mozilla.org/en/docs/Web/CSS/-moz-outline-radius",
			syntax: "<border-radius>"
		},
		paint: {
			comment: "simplified SVG syntax (omit <icccolor>, replace <funciri> for <url>) https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | currentColor | <color> | <url> [ none | currentColor | <color> ]?"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( [ [ <top>, <right>, <bottom>, <left> ] | [ <top> <right> <bottom> <left> ] ] )"
		},
		"single-transition": {
			comment: "moved <single-transition-timing-function> in the beginning to avoid wrong match to <single-transition-property>",
			syntax: "<single-transition-timing-function> || [ none | <single-transition-property> ] || <time> || <time>"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		"var()": {
			comment: "drop it since it's a generic (also syntax is incorrect and can't be parsed)",
			syntax: null
		},
		"an-plus-b": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-type": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-block": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-declaration": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-block-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"feature-value-declaration-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"general-enclosed": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"keyframe-block": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"keyframe-block-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-plain": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-range": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"mf-value": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-and": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-condition": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-not": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-or": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-in-parens": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-feature": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-condition-without-or": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-query": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"media-query-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		nth: {
			comment: "syntax has <an-plus-b> that doesn't support currently, drop for now",
			syntax: null
		},
		"page-selector": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-selector-list": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-body": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-margin-box": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"page-margin-box-type": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		},
		"pseudo-page": {
			comment: "syntax is incorrect and can't be parsed, drop for now",
			syntax: null
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		properties: properties$3,
		syntaxes: syntaxes$2,
		default: patch
	});

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    properties: buildDictionary(mdnProperties, patch$2.properties),
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes)
	};

	var cmpChar$1 = tokenizer.cmpChar;
	var isNumber$3 = tokenizer.isNumber;
	var TYPE$4 = tokenizer.TYPE;

	var IDENTIFIER$3 = TYPE$4.Identifier;
	var NUMBER$2 = TYPE$4.Number;
	var PLUSSIGN$4 = TYPE$4.PlusSign;
	var HYPHENMINUS$4 = TYPE$4.HyphenMinus;
	var N$5 = 110; // 'n'.charCodeAt(0)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function checkTokenIsInteger(scanner, disallowSign) {
	    var pos = scanner.tokenStart;

	    if (scanner.source.charCodeAt(pos) === PLUSSIGN$4 ||
	        scanner.source.charCodeAt(pos) === HYPHENMINUS$4) {
	        if (disallowSign) {
	            scanner.error();
	        }
	        pos++;
	    }

	    for (; pos < scanner.tokenEnd; pos++) {
	        if (!isNumber$3(scanner.source.charCodeAt(pos))) {
	            scanner.error('Unexpected input', pos);
	        }
	    }
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = start;
	        var prefix = '';
	        var a = null;
	        var b = null;

	        if (this.scanner.tokenType === NUMBER$2 ||
	            this.scanner.tokenType === PLUSSIGN$4) {
	            checkTokenIsInteger(this.scanner, ALLOW_SIGN);
	            prefix = this.scanner.getTokenValue();
	            this.scanner.next();
	            end = this.scanner.tokenStart;
	        }

	        if (this.scanner.tokenType === IDENTIFIER$3) {
	            var bStart = this.scanner.tokenStart;

	            if (cmpChar$1(this.scanner.source, bStart, HYPHENMINUS$4)) {
	                if (prefix === '') {
	                    prefix = '-';
	                    bStart++;
	                } else {
	                    this.scanner.error('Unexpected hyphen minus');
	                }
	            }

	            if (!cmpChar$1(this.scanner.source, bStart, N$5)) {
	                this.scanner.error();
	            }

	            a = prefix === ''  ? '1'  :
	                prefix === '+' ? '+1' :
	                prefix === '-' ? '-1' :
	                prefix;

	            var len = this.scanner.tokenEnd - bStart;
	            if (len > 1) {
	                // ..n-..
	                if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS$4) {
	                    this.scanner.error('Unexpected input', bStart + 1);
	                }

	                if (len > 2) {
	                    // ..n-{number}..
	                    this.scanner.tokenStart = bStart + 2;
	                } else {
	                    // ..n- {number}
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                }

	                checkTokenIsInteger(this.scanner, DISALLOW_SIGN);
	                b = '-' + this.scanner.getTokenValue();
	                this.scanner.next();
	                end = this.scanner.tokenStart;
	            } else {
	                prefix = '';
	                this.scanner.next();
	                end = this.scanner.tokenStart;
	                this.scanner.skipSC();

	                if (this.scanner.tokenType === HYPHENMINUS$4 ||
	                    this.scanner.tokenType === PLUSSIGN$4) {
	                    prefix = this.scanner.getTokenValue();
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                }

	                if (this.scanner.tokenType === NUMBER$2) {
	                    checkTokenIsInteger(this.scanner, prefix !== '');

	                    if (!isNumber$3(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
	                        prefix = this.scanner.source.charAt(this.scanner.tokenStart);
	                        this.scanner.tokenStart++;
	                    }

	                    if (prefix === '') {
	                        // should be an operator before number
	                        this.scanner.error();
	                    } else if (prefix === '+') {
	                        // plus is using by default
	                        prefix = '';
	                    }

	                    b = prefix + this.scanner.getTokenValue();

	                    this.scanner.next();
	                    end = this.scanner.tokenStart;
	                } else {
	                    if (prefix) {
	                        this.scanner.eat(NUMBER$2);
	                    }
	                }
	            }
	        } else {
	            if (prefix === '' || prefix === '+') { // no number
	                this.scanner.error(
	                    'Number or identifier is expected',
	                    this.scanner.tokenStart + (
	                        this.scanner.tokenType === PLUSSIGN$4 ||
	                        this.scanner.tokenType === HYPHENMINUS$4
	                    )
	                );
	            }

	            b = prefix;
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, end),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' :
	                node.a ===  '1' ?  'n' :
	                node.a === '-1' ? '-n' :
	                node.a + 'n'
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$5 = tokenizer.TYPE;

	var ATKEYWORD$2 = TYPE$5.AtKeyword;
	var SEMICOLON = TYPE$5.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$5.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$5.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, SEMICOLON, LEFTCURLYBRACKET$2, false, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$2) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$2 ||
	            type === ATKEYWORD$2) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.scanner.eat(ATKEYWORD$2);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.currentToken);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$2:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$6 = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$6.Semicolon;
	var LEFTCURLYBRACKET$3 = TYPE$6.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$3 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.scanner.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$7 = tokenizer.TYPE;

	var IDENTIFIER$4 = TYPE$7.Identifier;
	var STRING$2 = TYPE$7.String;
	var DOLLARSIGN = TYPE$7.DollarSign;
	var ASTERISK$1 = TYPE$7.Asterisk;
	var COLON = TYPE$7.Colon;
	var EQUALSSIGN = TYPE$7.EqualsSign;
	var LEFTSQUAREBRACKET$2 = TYPE$7.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$7.RightSquareBracket;
	var CIRCUMFLEXACCENT = TYPE$7.CircumflexAccent;
	var VERTICALLINE$1 = TYPE$7.VerticalLine;
	var TILDE = TYPE$7.Tilde;

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.scanner.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdentifier = false;
	    var checkColon = true;

	    if (this.scanner.tokenType === ASTERISK$1) {
	        expectIdentifier = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (this.scanner.tokenType !== VERTICALLINE$1) {
	        this.scanner.eat(IDENTIFIER$4);
	    }

	    if (this.scanner.tokenType === VERTICALLINE$1) {
	        if (this.scanner.lookupType(1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.scanner.eat(IDENTIFIER$4);
	        } else if (expectIdentifier) {
	            this.scanner.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdentifier) {
	        this.scanner.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.scanner.eat(IDENTIFIER$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var tokenType = this.scanner.tokenType;

	    if (tokenType !== EQUALSSIGN &&        // =
	        tokenType !== TILDE &&             // ~=
	        tokenType !== CIRCUMFLEXACCENT &&  // ^=
	        tokenType !== DOLLARSIGN &&        // $=
	        tokenType !== ASTERISK$1 &&          // *=
	        tokenType !== VERTICALLINE$1         // |=
	    ) {
	        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    if (tokenType === EQUALSSIGN) {
	        this.scanner.next();
	    } else {
	        this.scanner.next();
	        this.scanner.eat(EQUALSSIGN);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' S* attrib_name ']'
	// '[' S* attrib_name S* attrib_matcher S* [ IDENT | STRING ] S* attrib_flags? S* ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.scanner.eat(LEFTSQUAREBRACKET$2);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$2) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENTIFIER$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING$2
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENTIFIER$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.scanner.eat(RIGHTSQUAREBRACKET$2);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$8 = tokenizer.TYPE;

	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var COMMENT$3 = TYPE$8.Comment;
	var SEMICOLON$2 = TYPE$8.Semicolon;
	var ATKEYWORD$3 = TYPE$8.AtKeyword;
	var LEFTCURLYBRACKET$4 = TYPE$8.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$3 = TYPE$8.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, 0, 0, false, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, 0, SEMICOLON$2, true, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.currentToken);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.scanner.eat(LEFTCURLYBRACKET$4);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$3:
	                    break scan;

	                case WHITESPACE$3:
	                case COMMENT$3:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$3:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTCURLYBRACKET$3);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$9 = tokenizer.TYPE;
	var LEFTSQUAREBRACKET$3 = TYPE$9.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$3 = TYPE$9.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.scanner.eat(LEFTSQUAREBRACKET$3);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTSQUAREBRACKET$3);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC$2 = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(CDC$2); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO$2 = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(CDO$2); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$a = tokenizer.TYPE;
	var IDENTIFIER$5 = TYPE$a.Identifier;
	var FULLSTOP$2 = TYPE$a.FullStop;

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        this.scanner.eat(FULLSTOP$2);

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$b = tokenizer.TYPE;

	var PLUSSIGN$5 = TYPE$b.PlusSign;
	var SOLIDUS = TYPE$b.Solidus;
	var GREATERTHANSIGN$2 = TYPE$b.GreaterThanSign;
	var TILDE$1 = TYPE$b.Tilde;

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        switch (this.scanner.tokenType) {
	            case GREATERTHANSIGN$2:
	            case PLUSSIGN$5:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();
	                this.scanner.expectIdentifier('deep');
	                this.scanner.eat(SOLIDUS);
	                break;

	            default:
	                this.scanner.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$c = tokenizer.TYPE;

	var ASTERISK$2 = TYPE$c.Asterisk;
	var SOLIDUS$1 = TYPE$c.Solidus;

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        this.scanner.next();

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$d = tokenizer.TYPE;

	var IDENTIFIER$6 = TYPE$d.Identifier;
	var COLON$1 = TYPE$d.Colon;
	var EXCLAMATIONMARK$2 = TYPE$d.ExclamationMark;
	var SOLIDUS$2 = TYPE$d.Solidus;
	var ASTERISK$3 = TYPE$d.Asterisk;
	var DOLLARSIGN$1 = TYPE$d.DollarSign;
	var HYPHENMINUS$5 = TYPE$d.HyphenMinus;
	var SEMICOLON$3 = TYPE$d.Semicolon;
	var PLUSSIGN$6 = TYPE$d.PlusSign;
	var NUMBERSIGN$2 = TYPE$d.NumberSign;

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, EXCLAMATIONMARK$2, SEMICOLON$3, false, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, EXCLAMATIONMARK$2, SEMICOLON$3, false, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.currentToken;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.tokenType !== EXCLAMATIONMARK$2 &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.scanner.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.currentToken;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.scanner.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.currentToken);
	        }

	        if (this.scanner.tokenType === EXCLAMATIONMARK$2) {
	            important = getImportant(this.scanner);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.scanner.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;
	    var prefix = 0;

	    // hacks
	    switch (this.scanner.tokenType) {
	        case ASTERISK$3:
	        case DOLLARSIGN$1:
	        case PLUSSIGN$6:
	        case NUMBERSIGN$2:
	            prefix = 1;
	            break;

	        // TODO: not sure we should support this hack
	        case SOLIDUS$2:
	            prefix = this.scanner.lookupType(1) === SOLIDUS$2 ? 2 : 1;
	            break;
	    }

	    if (this.scanner.lookupType(prefix) === HYPHENMINUS$5) {
	        prefix++;
	    }

	    if (prefix) {
	        this.scanner.skip(prefix);
	    }

	    this.scanner.eat(IDENTIFIER$6);

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant(scanner) {
	    scanner.eat(EXCLAMATIONMARK$2);
	    scanner.skipSC();

	    var important = scanner.consume(IDENTIFIER$6);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$e = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$4 = TYPE$e.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, 0, SEMICOLON$4, true, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$4:
	                case COMMENT$4:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var NUMBER$3 = tokenizer.TYPE.Number;

	// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
	function readUnit(scanner) {
	    var unit = scanner.getTokenValue();
	    var backSlashPos = unit.indexOf('\\');

	    if (backSlashPos > 0) {
	        // patch token offset
	        scanner.tokenStart += backSlashPos;

	        // return part before backslash
	        return unit.substring(0, backSlashPos);
	    }

	    // no backslash in unit name
	    scanner.next();

	    return unit;
	}

	// number ident
	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value = this.scanner.consume(NUMBER$3);
	        var unit = readUnit(this.scanner);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value,
	            unit: unit
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$f = tokenizer.TYPE;
	var RIGHTPARENTHESIS$3 = TYPE$f.RightParenthesis;

	// <function-token> <sequence> ')'
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.scanner.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTPARENTHESIS$3);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var isHex$2 = tokenizer.isHex;
	var TYPE$g = tokenizer.TYPE;

	var IDENTIFIER$7 = TYPE$g.Identifier;
	var NUMBER$4 = TYPE$g.Number;
	var NUMBERSIGN$3 = TYPE$g.NumberSign;

	function consumeHexSequence(scanner, required) {
	    if (!isHex$2(scanner.source.charCodeAt(scanner.tokenStart))) {
	        if (required) {
	            scanner.error('Unexpected input', scanner.tokenStart);
	        } else {
	            return;
	        }
	    }

	    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
	        var code = scanner.source.charCodeAt(pos);

	        // break on non-hex char
	        if (!isHex$2(code)) {
	            // break token, exclude symbol
	            scanner.tokenStart = pos;
	            return;
	        }
	    }

	    // token is full hex sequence, go to next token
	    scanner.next();
	}

	// # ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.eat(NUMBERSIGN$3);

	        scan:
	        switch (this.scanner.tokenType) {
	            case NUMBER$4:
	                consumeHexSequence(this.scanner, true);

	                // if token is identifier then number consists of hex only,
	                // try to add identifier to result
	                if (this.scanner.tokenType === IDENTIFIER$7) {
	                    consumeHexSequence(this.scanner, false);
	                }

	                break;

	            case IDENTIFIER$7:
	                consumeHexSequence(this.scanner, true);
	                break;

	            default:
	                this.scanner.error('Number or identifier is expected');
	        }

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1) // skip #
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$h = tokenizer.TYPE;
	var IDENTIFIER$8 = TYPE$h.Identifier;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;
	var IDENTIFIER$9 = TYPE$i.Identifier;
	var NUMBERSIGN$4 = TYPE$i.NumberSign;

	// '#' ident
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        this.scanner.eat(NUMBERSIGN$4);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.scanner.consume(IDENTIFIER$9)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$j = tokenizer.TYPE;

	var IDENTIFIER$a = TYPE$j.Identifier;
	var NUMBER$5 = TYPE$j.Number;
	var LEFTPARENTHESIS$3 = TYPE$j.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$j.RightParenthesis;
	var COLON$2 = TYPE$j.Colon;
	var SOLIDUS$3 = TYPE$j.Solidus;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.scanner.eat(LEFTPARENTHESIS$3);
	        this.scanner.skipSC();

	        name = this.scanner.consume(IDENTIFIER$a);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$4) {
	            this.scanner.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$5:
	                    if (this.scanner.lookupType(1) === IDENTIFIER$a) {
	                        value = this.Dimension();
	                    } else if (this.scanner.lookupNonWSType(1) === SOLIDUS$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case IDENTIFIER$a:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.scanner.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.scanner.eat(RIGHTPARENTHESIS$4);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$k = tokenizer.TYPE;

	var WHITESPACE$5 = TYPE$k.WhiteSpace;
	var COMMENT$5 = TYPE$k.Comment;
	var IDENTIFIER$b = TYPE$k.Identifier;
	var LEFTPARENTHESIS$4 = TYPE$k.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$5:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$5:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENTIFIER$b:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$4:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.scanner.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	// https://drafts.csswg.org/css-syntax-3/#the-anb-type
	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$6 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.scanner.consume(NUMBER$6)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$l = tokenizer.TYPE;
	var LEFTPARENTHESIS$5 = TYPE$l.LeftParenthesis;
	var RIGHTPARENTHESIS$5 = TYPE$l.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.scanner.eat(LEFTPARENTHESIS$5);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.scanner.eat(RIGHTPARENTHESIS$5);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var NUMBER$7 = TYPE$m.Number;
	var PERCENTSIGN = TYPE$m.PercentSign;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var number = this.scanner.consume(NUMBER$7);

	        this.scanner.eat(PERCENTSIGN);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: number
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$n = tokenizer.TYPE;

	var IDENTIFIER$c = TYPE$n.Identifier;
	var FUNCTION$2 = TYPE$n.Function;
	var COLON$3 = TYPE$n.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$n.RightParenthesis;

	// : ident [ '(' .. ')' ]?
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.scanner.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.scanner.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
	                );
	            }

	            this.scanner.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.scanner.consume(IDENTIFIER$c);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENTIFIER$d = TYPE$o.Identifier;
	var FUNCTION$3 = TYPE$o.Function;
	var COLON$4 = TYPE$o.Colon;
	var RIGHTPARENTHESIS$7 = TYPE$o.RightParenthesis;

	// :: ident [ '(' .. ')' ]?
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.scanner.eat(COLON$4);
	        this.scanner.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$3) {
	            name = this.scanner.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
	                );
	            }

	            this.scanner.eat(RIGHTPARENTHESIS$7);
	        } else {
	            name = this.scanner.consume(IDENTIFIER$d);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isNumber$4 = tokenizer.isNumber;
	var TYPE$p = tokenizer.TYPE;
	var NUMBER$8 = TYPE$p.Number;
	var SOLIDUS$4 = TYPE$p.Solidus;
	var FULLSTOP$3 = TYPE$p.FullStop;

	// Terms of <ratio> should to be a positive number (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without exponent part.
	// Additional checks may to be applied on lexer validation.
	function consumeNumber$1(scanner) {
	    var value = scanner.consumeNonWS(NUMBER$8);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isNumber$4(code) && code !== FULLSTOP$3) {
	            scanner.error('Unsigned number is expected', scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        scanner.error('Zero number is not allowed', scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$1(this.scanner);
	        var right;

	        this.scanner.eatNonWS(SOLIDUS$4);
	        right = consumeNumber$1(this.scanner);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, endTokenType1, endTokenType2, includeTokenType2, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(
	                startToken,
	                endTokenType1,
	                endTokenType2,
	                includeTokenType2
	            )
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = this.scanner.getOffsetExcludeWS();
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var LEFTCURLYBRACKET$5 = TYPE$q.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, LEFTCURLYBRACKET$5, 0, false, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$5) {
	        this.scanner.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.currentToken;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.scanner.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var COMMA$2 = TYPE$r.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$3 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.scanner.consume(STRING$3)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var WHITESPACE$6 = TYPE$s.WhiteSpace;
	var COMMENT$6 = TYPE$s.Comment;
	var EXCLAMATIONMARK$3 = TYPE$s.ExclamationMark;
	var ATKEYWORD$4 = TYPE$s.AtKeyword;
	var CDO$3 = TYPE$s.CDO;
	var CDC$3 = TYPE$s.CDC;

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, 0, 0, false, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$6:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$3: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$3: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // 2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$4:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$t = tokenizer.TYPE;

	var IDENTIFIER$e = TYPE$t.Identifier;
	var ASTERISK$4 = TYPE$t.Asterisk;
	var VERTICALLINE$2 = TYPE$t.VerticalLine;

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENTIFIER$e &&
	        this.scanner.tokenType !== ASTERISK$4) {
	        this.scanner.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.tokenType === VERTICALLINE$2) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.tokenType === VERTICALLINE$2) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHex$3 = tokenizer.isHex;
	var TYPE$u = tokenizer.TYPE;

	var IDENTIFIER$f = TYPE$u.Identifier;
	var NUMBER$9 = TYPE$u.Number;
	var PLUSSIGN$7 = TYPE$u.PlusSign;
	var HYPHENMINUS$6 = TYPE$u.HyphenMinus;
	var FULLSTOP$4 = TYPE$u.FullStop;
	var QUESTIONMARK$1 = TYPE$u.QuestionMark;

	function scanUnicodeNumber(scanner) {
	    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
	        var code = scanner.source.charCodeAt(pos);

	        // break on fullstop or hyperminus/plussign after exponent
	        if (code === FULLSTOP$4 || code === PLUSSIGN$7) {
	            // break token, exclude symbol
	            scanner.tokenStart = pos;
	            return false;
	        }
	    }

	    return true;
	}

	// https://drafts.csswg.org/css-syntax-3/#urange
	function scanUnicodeRange(scanner) {
	    var hexStart = scanner.tokenStart + 1; // skip +
	    var hexLength = 0;

	    scan: {
	        if (scanner.tokenType === NUMBER$9) {
	            if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP$4 && scanUnicodeNumber(scanner)) {
	                scanner.next();
	            } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS$6) {
	                break scan;
	            }
	        } else {
	            scanner.next(); // PLUSSIGN
	        }

	        if (scanner.tokenType === HYPHENMINUS$6) {
	            scanner.next();
	        }

	        if (scanner.tokenType === NUMBER$9) {
	            scanner.next();
	        }

	        if (scanner.tokenType === IDENTIFIER$f) {
	            scanner.next();
	        }

	        if (scanner.tokenStart === hexStart) {
	            scanner.error('Unexpected input', hexStart);
	        }
	    }

	    // validate for U+x{1,6} or U+x{1,6}-x{1,6}
	    // where x is [0-9a-fA-F]
	    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {
	        var code = scanner.source.charCodeAt(i);

	        if (isHex$3(code) === false && (code !== HYPHENMINUS$6 || wasHyphenMinus)) {
	            scanner.error('Unexpected input', i);
	        }

	        if (code === HYPHENMINUS$6) {
	            // hex sequence shouldn't be an empty
	            if (hexLength === 0) {
	                scanner.error('Unexpected input', i);
	            }

	            wasHyphenMinus = true;
	            hexLength = 0;
	        } else {
	            hexLength++;

	            // too long hex sequence
	            if (hexLength > 6) {
	                scanner.error('Too long hex sequence', i);
	            }
	        }

	    }

	    // check we have a non-zero sequence
	    if (hexLength === 0) {
	        scanner.error('Unexpected input', i - 1);
	    }

	    // U+abc???
	    if (!wasHyphenMinus) {
	        // consume as many U+003F QUESTION MARK (?) code points as possible
	        for (; hexLength < 6 && !scanner.eof; scanner.next()) {
	            if (scanner.tokenType !== QUESTIONMARK$1) {
	                break;
	            }

	            hexLength++;
	        }
	    }
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next(); // U or u
	        scanUnicodeRange(this.scanner);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$v = tokenizer.TYPE;

	var STRING$4 = TYPE$v.String;
	var URL$3 = TYPE$v.Url;
	var RAW$2 = TYPE$v.Raw;
	var RIGHTPARENTHESIS$8 = TYPE$v.RightParenthesis;

	// url '(' S* (string | raw) S* ')'
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        this.scanner.eat(URL$3);
	        this.scanner.skipSC();

	        switch (this.scanner.tokenType) {
	            case STRING$4:
	                value = this.String();
	                break;

	            case RAW$2:
	                value = this.Raw(this.scanner.currentToken, 0, RAW$2, true, false);
	                break;

	            default:
	                this.scanner.error('String or Raw is expected');
	        }

	        this.scanner.skipSC();
	        this.scanner.eat(RIGHTPARENTHESIS$8);

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$7 = tokenizer.TYPE.WhiteSpace;
	var SPACE$4 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.scanner.eat(WHITESPACE$7);
	        return SPACE$4;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.scanner.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$w = tokenizer.TYPE;

	var IDENTIFIER$g = TYPE$w.Identifier;
	var STRING$5 = TYPE$w.String;
	var NUMBER$a = TYPE$w.Number;
	var FUNCTION$4 = TYPE$w.Function;
	var URL$4 = TYPE$w.Url;
	var NUMBERSIGN$5 = TYPE$w.NumberSign;
	var LEFTPARENTHESIS$6 = TYPE$w.LeftParenthesis;
	var LEFTSQUAREBRACKET$4 = TYPE$w.LeftSquareBracket;
	var PLUSSIGN$8 = TYPE$w.PlusSign;
	var HYPHENMINUS$7 = TYPE$w.HyphenMinus;
	var COMMA$3 = TYPE$w.Comma;
	var SOLIDUS$5 = TYPE$w.Solidus;
	var ASTERISK$5 = TYPE$w.Asterisk;
	var PERCENTSIGN$1 = TYPE$w.PercentSign;
	var BACKSLASH = TYPE$w.Backslash;
	var U = 117; // 'u'.charCodeAt(0)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case NUMBERSIGN$5:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case SOLIDUS$5:
	        case ASTERISK$5:
	        case PLUSSIGN$8:
	        case HYPHENMINUS$7:
	            return this.Operator();

	        case LEFTPARENTHESIS$6:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$4:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$5:
	            return this.String();

	        case NUMBER$a:
	            switch (this.scanner.lookupType(1)) {
	                case PERCENTSIGN$1:
	                    return this.Percentage();

	                case IDENTIFIER$g:
	                    // edge case: number with folowing \0 and \9 hack shouldn't to be a Dimension
	                    if (cmpChar$2(this.scanner.source, this.scanner.tokenEnd, BACKSLASH)) {
	                        return this.Number();
	                    } else {
	                        return this.Dimension();
	                    }

	                default:
	                    return this.Number();
	            }

	        case FUNCTION$4:
	            return this.Function(this.readSequence, context.recognizer);

	        case URL$4:
	            return this.Url();

	        case IDENTIFIER$g:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$2(this.scanner.source, this.scanner.tokenStart, U) &&
	                cmpChar$2(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$8)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$x = tokenizer.TYPE;

	var IDENTIFIER$h = TYPE$x.Identifier;
	var NUMBER$b = TYPE$x.Number;
	var NUMBERSIGN$6 = TYPE$x.NumberSign;
	var LEFTSQUAREBRACKET$5 = TYPE$x.LeftSquareBracket;
	var PLUSSIGN$9 = TYPE$x.PlusSign;
	var SOLIDUS$6 = TYPE$x.Solidus;
	var ASTERISK$6 = TYPE$x.Asterisk;
	var FULLSTOP$5 = TYPE$x.FullStop;
	var COLON$5 = TYPE$x.Colon;
	var GREATERTHANSIGN$3 = TYPE$x.GreaterThanSign;
	var VERTICALLINE$3 = TYPE$x.VerticalLine;
	var TILDE$2 = TYPE$x.Tilde;

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case PLUSSIGN$9:
	        case GREATERTHANSIGN$3:
	        case TILDE$2:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Combinator();

	        case SOLIDUS$6:  // /deep/
	            return this.Combinator();

	        case FULLSTOP$5:
	            return this.ClassSelector();

	        case LEFTSQUAREBRACKET$5:
	            return this.AttributeSelector();

	        case NUMBERSIGN$6:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENTIFIER$h:
	        case ASTERISK$6:
	        case VERTICALLINE$3:
	            return this.TypeSelector();

	        case NUMBER$b:
	            return this.Percentage();
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression '(' raw ')'
	var expression$1 = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.currentToken, 0, 0, false, false)
	    );
	};

	var TYPE$y = tokenizer.TYPE;

	var IDENTIFIER$i = TYPE$y.Identifier;
	var COMMA$4 = TYPE$y.Comma;
	var SEMICOLON$5 = TYPE$y.Semicolon;
	var HYPHENMINUS$8 = TYPE$y.HyphenMinus;
	var EXCLAMATIONMARK$4 = TYPE$y.ExclamationMark;

	// var '(' ident (',' <value>? )? ')'
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    var identStart = this.scanner.tokenStart;

	    this.scanner.eat(HYPHENMINUS$8);
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS$8) {
	        this.scanner.error('HyphenMinus is expected');
	    }
	    this.scanner.eat(IDENTIFIER$i);

	    children.push({
	        type: 'Identifier',
	        loc: this.getLocation(identStart, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(identStart)
	    });

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$4, SEMICOLON$5, false, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression$1,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var STRING$6 = TYPE$z.String;
	var IDENTIFIER$j = TYPE$z.Identifier;
	var URL$5 = TYPE$z.Url;
	var LEFTPARENTHESIS$7 = TYPE$z.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$6:
	                    children.push(this.String());
	                    break;

	                case URL$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.scanner.error('String or url() is expected');
	            }

	            if (this.scanner.lookupNonWSType(0) === IDENTIFIER$j ||
	                this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS$7) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$A = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$A.WhiteSpace;
	var COMMENT$7 = TYPE$A.Comment;
	var IDENTIFIER$k = TYPE$A.Identifier;
	var FUNCTION$5 = TYPE$A.Function;
	var LEFTPARENTHESIS$8 = TYPE$A.LeftParenthesis;
	var HYPHENMINUS$9 = TYPE$A.HyphenMinus;
	var COLON$6 = TYPE$A.Colon;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.currentToken, 0, 0, false, false)
	    );
	}

	function parentheses() {
	    var index = 0;

	    this.scanner.skipSC();

	    // TODO: make it simplier
	    if (this.scanner.tokenType === IDENTIFIER$k) {
	        index = 1;
	    } else if (this.scanner.tokenType === HYPHENMINUS$9 &&
	               this.scanner.lookupType(1) === IDENTIFIER$k) {
	        index = 2;
	    }

	    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$8:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$7:
	                this.scanner.next();
	                continue;

	            case FUNCTION$5:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENTIFIER$k:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$8:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.scanner.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}

		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let href = node.value.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					node.value.value = url.toString();
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-bleed-top: 0;
	--pagedjs-bleed-right: 0;
	--pagedjs-bleed-bottom: 0;
	--pagedjs-bleed-left: 0;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}


.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

img {
	height: auto;
}

@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: var(--pagedjs-width);
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || 'get', url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials=='include';

			request.onload = () => {
	 			// Chrome returns a status code of 0 for local files
	 			const status = request.status === 0 && url.startsWith('file://') ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "mm"
			},
			height: {
				value: 14,
				unit: "mm"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "mm"
			},
			height: {
				value: 17,
				unit: "mm"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;

			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin : {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclartations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;


				if ((width && height) &&
						(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed);

					this.emit("size", { width, height, orientation, format, bleed });
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclartations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);
					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);
					} else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									default:
										// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;
		}

		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let {value, unit} = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					margins.push(node);
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages && !pages["*"].added) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
				pages["*"].added = true;
			}
			// Add :left & :right
			if (":left" in pages && !pages[":left"].added) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
				pages[":left"].added = true;
			}
			if (":right" in pages && !pages[":right"].added) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
				pages[":right"].added = true;
			}
			// Add :first & :blank
			if (":first" in pages && !pages[":first"].first) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
				pages[":first"].added = true;
			}
			if (":blank" in pages && !pages[":blank"].added) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
				pages[":blank"].added = true;
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth && !pages[pg].added) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
					pages[pg].added = true;
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name && !pages[pg].added) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
					pages[pg].added = true;
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};
			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());

			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}

			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);
				}
			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent$$1 = false;

				if(block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent$$1 = false;
							} else {
								hasContent$$1 = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
							 loc === "top-center" ||
							 loc === "top-right" ||
							 loc === "bottom-left" ||
							 loc === "bottom-center" ||
							 loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
							 loc === "left-middle" ||
							 loc === "left-bottom" ||
							 loc === "right-top" ||
							 loc === "right-middle" ||
							 loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent$$1
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if(content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(bleedTop, bleedRight, bleedBottom, bleedLeft, pageWidthVar, pageHeightVar);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			rules.push(wVar, hVar);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let dimensions = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});


			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if(centerWidth === "none" || centerWidth === "auto") {
						if(!leftContent && !rightContent){
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						}else if(leftContent){
							if(!rightContent){
								if(leftWidth !== "none" && leftWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								}else{
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							}else{
								if(leftWidth !== "none" && leftWidth !== "auto"){
									if(rightWidth !== "none" && rightWidth !== "auto"){
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									}else{
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								}else{
									if(rightWidth !== "none" && rightWidth !== "auto"){
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									}else{
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if(newcenterWidth > 40){
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										}else{
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						}else{
							if(rightWidth !== "none" && rightWidth !== "auto"){
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							}else{
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					}else if(centerWidth !== "none" && centerWidth !== "auto"){
						if(leftContent && leftWidth !== "none" && leftWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						}else if(rightContent && rightWidth !== "none" && rightWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						}else{
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				}else{
					if(leftContent){
						if(!rightContent){
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						}else{
							if(leftWidth !== "none" && leftWidth !== "auto"){
								if(rightWidth !== "none" && rightWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								}else{
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							}else{
								if(rightWidth !== "none" && rightWidth !== "auto"){
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								}else{
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth  + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					}else{
						if(rightWidth !== "none" && rightWidth !== "auto"){
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						}else{
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if(middleHeight === "none" || middleHeight === "auto") {
						if(!topContent && !bottomContent){
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						}else if(topContent){
							if(!bottomContent){
								if(topHeight !== "none" && topHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							}else{
								if(topHeight !== "none" && topHeight !== "auto"){
									if(bottomHeight !== "none" && bottomHeight !== "auto"){
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									}else{
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								}else{
									if(bottomHeight !== "none" && bottomHeight !== "auto"){
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						}else{
							if(bottomHeight !== "none" && bottomHeight !== "auto"){
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					}else{
						if(topContent && topHeight !== "none" && topHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = topHeight +" " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						}else if(bottomContent && bottomHeight !== "none" && bottomHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						}else{
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				}else{
					if(topContent){
						if(!bottomContent){
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						}else{
							if(topHeight !== "none" && topHeight !== "auto"){
								if(bottomHeight !== "none" && bottomHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								}else{
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							}else{
								if(bottomHeight !== "none" && bottomHeight !== "auto"){
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								}else{
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					}else{
						if(bottomHeight !== "none" && bottomHeight !== "auto"){
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						}else{
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator="+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child$$1 = declaration.value.children.first();
				let value = child$$1.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter$$1 = elementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter$$1) {
								nodeAfter$$1.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter$$1 = elementAfter(elements[i], parsed);

							if (nodeAfter$$1) {
								nodeAfter$$1.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			splits.forEach((split) => {
				let ref = split.dataset.ref;
				let from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}

					this.handleAlignment(from);
				}
			});
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			if (align === "justify" && alignLast === "auto") {
				node.style["text-align-last"] = "justify";
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number: number || 1
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				this.addCounterValues(parsed, counter);
			}
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (var i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
				}
			}
		}

		addCounterValues(parsed, counter) {
			let counterName = counter.name;
			let elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;

			for (var i = 0; i < elements.length; i++) {
				element = elements[i];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					count = parseInt(reset);
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");

					this.styleSheet.insertRule(`[data-ref="${element.dataset.ref}"] { counter-reset: ${counterName} ${count} }`, this.styleSheet.cssRules.length);
					this.styleSheet.insertRule(`[data-ref="${element.dataset.ref}"] { counter-increment: ${counterName} ${increment}}`, this.styleSheet.cssRules.length);

					count += parseInt(increment);

					element.setAttribute("data-counter-"+counterName+"-value", count);
				}

			}
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				let value = reset.datasetCounterPageReset;
				this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-reset: page ${value} }`, this.styleSheet.cssRules.length);
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
				list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + 1);
			}
		}

	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier: identifier,
					value: value,
					selector: selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

				funcNode.children.append(funcNode.children.createItem({
					type: "Identifier",
					loc: null,
					name: "--pagedjs-string-" + identifier
				}));
			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.stringSetSelectors)) {
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					let cssVar;
					if (set.value === "content" || set.value === "content()" || set.value === "content(text)") {
						cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --pagedjs-string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--pagedjs-string-${name}`, `"${cssVar}"`);
						set.first = cssVar;
						fragment.style.setProperty(`--pagedjs-string-${name}`, `"${set.first}"`);
					} else {
						console.warn(set.value + "needs css replacement");
					}
				} else {
					// Use the previous values
					if (set.first) {
						fragment.style.setProperty(`--pagedjs-string-${name}`, `"${set.first}"`);
					}
				}
			}
		}
	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (var i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								pg += 1;

								if (pages[i].contains( element )){
									break;
								}
							}

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${psuedo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${psuedo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				selector.split(",").forEach((s) => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach((name) => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						if (target.style === "content") {
							let selector = UUID();
							selected.setAttribute("data-target-text", selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}

							let textContent = element.textContent.trim().replace(/["']/g, (match) => {
								return "\\" + match;
							}).replace(/[\n]/g, (match) => {
								return "\\00000A";
							});

							// this.styleSheet.insertRule(`[data-target-text="${selector}"]${psuedo} { content: "${element.textContent}" }`, this.styleSheet.cssRules.length);
							this.styleSheet.insertRule(`[data-target-text="${selector}"]${psuedo} { ${target.variable}: "${textContent}" }`, this.styleSheet.cssRules.length);

						}
					} else {
						console.warn("missed target", val);
					}
				});

			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		if (typeof Symbol !== 'function') return false;
		try { } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor() {
			// this.preview = this.getParams("preview") !== "false";

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker();

			// Hooks
			this.hooks = {};

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			let counter = 0;
			this.chunker.on("page", (page) => {
				counter += 1;
				this.emit("page", page);
				if (typeof window.PuppeteerLogger !== "undefined") {
					window.PuppeteerLogger("page", counter);
				}
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();
			let msg = "Rendering " + flow.total + " pages took " + (endTime - startTime) + " milliseconds.";

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", msg, this.size.width && this.size.width.value + this.size.width.unit, this.size.height && this.size.height.value + this.size.height.unit, this.size.orientation, this.size.format);
			if (typeof window.onPagesRendered !== "undefined") {
				window.onPagesRendered(msg, this.size.width && this.size.width.value + this.size.width.unit, this.size.height && this.size.height.value + this.size.height.unit, this.size.orientation, this.size.format);
			}

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);



	var Paged = /*#__PURE__*/Object.freeze({
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined
	};

	let previewer = new Previewer(config.content, config.stylesheets, config.renderTo);


	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview();
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

}));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      const abbreviations = content.querySelectorAll('abbr');
      if(abbreviations.length === 0) return;
      const loaTitle = 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });
}
</script>




<style type="text/css">@page {
size: 8.5in 11in; 
}
@page :blank {
}
.pagedjs_page {
--pagedjs-pagebox-width: 8.5in;
--pagedjs-pagebox-height: 11in;
}
.level1 {
break-before: avoid;
}
.red {
color: red;
}
.yourturn {
color: blue;
font-size: 2em;
}
.pagebreak {
break-after: always;
}</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Chapter 2: Statistical Learning</h1>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img src="data:image/jpeg;base64,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" /></p>
<p>Credit: <a href="https://www.instagram.com/sandserifcomics/" class="uri">https://www.instagram.com/sandserifcomics/</a></p>
<div id="what-is-statistical-learning" class="section level1">
<h1><span class="header-section-number">1</span> What is Statistical Learning?</h1>
<p>A scenario: We are consultants hired by a client to provide advice on how to improve sales of a product.</p>
<table>
<thead>
<tr class="header">
<th align="right">TV</th>
<th align="right">radio</th>
<th align="right">newspaper</th>
<th align="right">sales</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">230.1</td>
<td align="right">37.8</td>
<td align="right">69.2</td>
<td align="right">22.1</td>
</tr>
<tr class="even">
<td align="right">44.5</td>
<td align="right">39.3</td>
<td align="right">45.1</td>
<td align="right">10.4</td>
</tr>
<tr class="odd">
<td align="right">17.2</td>
<td align="right">45.9</td>
<td align="right">69.3</td>
<td align="right">9.3</td>
</tr>
<tr class="even">
<td align="right">151.5</td>
<td align="right">41.3</td>
<td align="right">58.5</td>
<td align="right">18.5</td>
</tr>
</tbody>
</table>
<p>We have the advertising budgets for that product in 200 markets and the sales in those markets. It is not possible to increase sales directly, but the client can change how they budget for advertising. <strong>How should we advise our client?</strong></p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAJACAYAAABMocy1AAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAABUCgAwAEAAAAAQAAAkAAAAAAzKugZgAAQABJREFUeAHsvQnYVMWV/18qiLgrqyuL4oasoiKCIgIi4opgwB0jcYuTmJnJTCa/xGQmyeSZZDIzycQYdRKNYmQRN0AFWQUUWcQVXBFQ3EEFAePy53P+qTf3vdzuvr3f2/2t5+m3++27VX3u7apzTp1zaoevthWnIgIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI1SGDHGmyTmiQCIiACIiACIiACIiACIiACIiACIiACIiACIiACRkAGUD0IIiACIiACIiACIiACIiACIiACIiACIiACIiACNUtABtCavbVqmAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAygegZEQAREQAREQAREQAREQAREQAREQAREQAREQARqloAMoDV7a9UwERABERABERABERABERABERABERABERABERABGUD1DIiACIiACIiACIiACIiACIiACIiACIiACIiACNQsARlAa/bWqmEiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIygOoZEAEREAEREAEREAEREAEREAEREAEREAEREAERqFkCMoDW7K1Vw0RABERABERABERABERABERABERABERABERABGQA1TMgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiJQswRkAK3ZW6uGiYAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIyACqZ0AEREAEREAEREAEREAEREAEREAEREAEREAERKBmCcgAWrO3Vg0TAREQAREQAREQAREQAREQAREQAREQAREQARFoIgTlJbBw4UK3atWq8l5EZxcBERABEah5Aqeccopr27Zt3u3csmWLmzx5ct7H6QAREAEREAERCBLYe++93emnnx78KvbnZcuWuRUrVsTeXzuKgAiIgAiIQBSB3r17uw4dOkRtyvmdDKA5ERW3wx133OFmzpxZ3El0tAiIgAiIQN0T2G+//QoygG7YsMHdeOONdc9PAERABERABIojcPDBBxdsAH3ggQfcuHHjiquAjhYBERABEah7Aug1MoAm+DE47LDD3A9+8IME11BVEwEREAERSCqBd955x33nO98punrf+ta3XK9evYo+j04gAiIgAiJQfwT+8Ic/uJdffrmohrdq1cr96le/KuocOlgEREAERKA+CXz22WduzJgxRTVeHqBF4Yt38I477uh23nnneDtrLxEQAREQAREIEGjatGngv8I/NmnSRGNR4fh0pAiIgAjUNYGddtqp6PbvsMMOGoeKpqgTiIAIiIAIFEpAiyAVSk7HiYAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIJJ6ADKCJv0WqoAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQKEEZAAtlJyOEwEREAEREAEREAEREAEREAEREAEREAEREAERSDwBGUATf4tUQREQAREQAREQAREQAREQAREQAREQAREQAREQgUIJyABaKDkdJwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIikHgCMoAm/hapgiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAoUSkAG0UHI6TgREQAREQAREQAREQAREQAREQAREQAREQAREIPEEZABN/C1SBUVABERABERABERABERABERABERABERABERABAolIANooeR0nAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQOIJyACa+FukCoqACIiACIiACIiACIiACIiACIiACIiACIiACBRKQAbQQsnpOBEQAREQAREQAREQAREQAREQAREQAREQAREQgcQTaJL4GqqCIiACIiACIiACIiACIlBBAmvWrHE//elPXevWrd2PfvSjhivfcMMNbvPmze4nP/mJ23fffRu+1wcREAEREAERgMCMGTPcpEmT8oLRqlUrd/HFF7v//M//tONuvPFG16ZNm5zn8Nc66KCD3Pe+972c+2sHEah3AjKA1vsToPaLgAiIgAiIgAiIgAg0IrBlyxb38ssvu08//bTR96+88op995e//KXR9/pHBERABERABCCwfv16Gz/yobFx40Z3yCGHuA0bNrj33nvPPfbYY2706NE5T3HffffZtfr3759zX+0gAiLgnAygegpEQAREQAREQAREQAREIAaBYcOGuc8++8ztuuuuMfbWLiIgAiIgAvVGYNCgQa5nz57bNfs73/mOw9B5zTXXuG7dujXa3rRpU7fjjju60047zd15552xDKCrV692K1ascDvttJMbPHhwo/PpHxEQgWgCMoBGc9G3IiACIiACIiACIiACItCIwNixYxv9r39EQAREQAREIEhg7733drzCBUMlpW3btubtGd7O/0OGDDED6BtvvOGIODj00EOjdrPvpk+fbu8nnHCC22effTLupw0iIAJ/IyAD6N9Y6JMIJJYAgyCzguR3+eqrrxy5yV588UW35557uk6dOrmWLVtmrPuXX37p1q5d61599VX3xRdf2EDKefwg7A/knGzfb7/9XLNmzfzX9v7BBx+4Tz75xK4XznlGLrR33nnHNW/evCFXDXWkflyX0q5dO3fwwQfbPvZF4E+wbYQUvvTSS+711193LVq0cN27d488xh+OFw7XoO6bNm1y+++/vzHi2HAp5jpxGXLN4HXefvtt9+yzz7rOnTtb3cJ10v8iIAIiIALxCMTtW/MZF4JXXrVqlVu5cqXr2LGjvYLbgp/xuGFMOPDAA12TJo3F6M8//9y99tprNg4wxnKuqPE2eD59FgEREAEREAFPAOMo3qNLly61XKKZDKCMQ94AOnToUH+43kVABHIQaCy55dhZm0VABKpD4NprrzVD4E033eT+6Z/+yaGoBcuoUaPcZZddtp1Rk/1YxAGFLFjat29vibJRznz5zW9+45YsWeIIzzj99NP91/b+b//2b2bIO/bYY93PfvazRtumTp3qqNf555/vrrrqKjO0sj9GyWDBQHrddddZaEfwe9pG2McvfvELaxt5c3zZY4893D/8wz+4Pn36+K8a3qdNm2bXDedn22GHHdxZZ53l8NIJGnILvU4+DKncN77xDVsYg/CWH//4x6Yo++9HjBjRUH99EAEREAERiE8gTt+a77jA1VlA4v/+7//cu+++21AZJuwuv/zyhv+DHxjHGHfuuuuuhkk/ti9atMj99re/bZj488dgAP3ud7/rjjjiCP+V3kVABERABEQgIwH0MAygs2bNMn0GJ5hwWbZsmXv//fdtob5e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VxEBERABESg/gULHBXJy/vSnPzVPUCbqGE+mTJliE2///u//HrviRx11lHmRYkBlAo50MEQj4PnJxCDGz6gc17EvoB1FQAREQATqlgB6FZNtTKzhKIK+pSICIlAYgR22/ZC+KuxQHRWHAB5tb731lnkZxNlf+4hAOQgQKo7XJh6R5OPcd999y3GZRufcvHmzeWn60D+/inujnbb9Q0JvvDVRFlnRff369e7999+3Vd2zrXpPmwiZx1tn//33d3jrZCuFXsefsxoM/bX1Xt8EWFwFDzPCa/tv83TLt3A83gJ4fB933HH5Hq79RSA1BPIdF4INYzxh7CFUPRw5ENwv12fSrxBCTyoZv0BSrmO0XQTSQIBUEaQzYkGWQsqPfvQjW8H6N7/5TSGH6xgREAEREIE6J4CMddFFF7kbb7zRok0LwaEQ+EKo6RgRSBkBQv1Q6ipZUP4KuSZeMnE8ZWgThk9ehZS41/HnrgZDf229i4AIiIAI5CZQzLjQpk0bx6vYQkoWoixUREAEREAEREAEREAEkkVAIfDJuh+qjQiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQAkJyABaQpg6lQiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQLIIKAQ+WfdDtRGBuiPAIk3k8yBssJylUtcpZxt0bhEQAREQAREQAREQAREQAREQAREQgfwJyACaPzMdIQIiUEICrAxfiVKp61SiLbqGCIiACIiACIiACIiACIiACIiACIhAfAIKgY/PSnuKgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAikjIAMoCm7YaquCIiACIiACIiACIiACIiACIiACIiACIiACIhAfAIygMZnpT1FQAREQAREQAREQAREQAREQAREQAREQAREQARSRkAG0JTdMFVXBERABERABERABERABERABERABERABERABEQgPgEZQOOz0p4iIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIpIyADaMpumKorAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIQn0CT+Ltqz0IJrF271v385z8v9HAdJwIiIAIiUMcEtm7dWpLWT5482c2aNask59JJREAEREAE6ovA6tWrXfPmzYtq9IYNG6QTFUVQB4uACIhA/RL46quvim68DKBFI8x+gv3339916NDBffbZZ9l3zLA1fJN32GGHDHsm92vfhjTWHaq+/nxOexvSXn/dAwhUp+h3UB3uXJXfbZcuXVzTpk0LqsSOO+5ox3NwrY1F/rlMSt/m6+NvVNLqlbT6iJMnEP2e9OeJWifxmVKdop8nvg0+U/lyatu2rWvVqlXmk+fYsu+++7rDDz+85sahHM0uyWZ/3/K9ZyW5eJVO4tvsL1+Pba/HNtfz/abt9XrP82k3OtGuu+7qH5W832UAzRtZfgd8+OGH7tlnn83vIO0tAiIgAiIgAiECX375ZeibeP+iRGgcisdKe4mACIiACGQmcMghh2TemGPLpk2bNBblYKTNIiACIiACuQn85S9/yb1Thj1kAM0AppRfd+7c2f3yl78s6JQfffRRw0wpM6c77bRTQeep5kEbN250hHC2aNGimtUo+Nrr1693n3/+uR1PG/CmSlv55JNPrA377LNP2qpu9f3ggw8cxh9mh1q2bJnKNhD2xbOz5557pq7+GNDef/99qzd9EH1RGgvP0c477+z22GOPVFV/3bp17vLLLy+6zv/v//0/d+KJJxZ0HvpA+kJKs2bNEvMcb9682THGFOOVVBCQDAd98cUXjolPCs/aXnvtlWHPyn69ZcsWxzhA/5nPLHu5akl/zu+Rgmfz3nvvXa5L5XVezykpY32QU5MmTVxSxnBkuo8//tjkuiTIREkdozynJMnv7733nv0muG/5yuW//vWv3YoVK/L6TYV3btOmjbv99tvDX8f6HwPqp59+avsyju+yyy6xjquFnfi90R8kpa+sBFP/++FapF7YfffdK3HZRFyDZx35Jq06TyEQg+NdkuSCQtqS7zH+WU+K7JFv/QvdH92S8Tsf/Z5ItrPOOqvQS9pxMoAWhS/ewQzQHbaFwRdSUKT4UVBQ8BCA01YYtOnEEXrSWBCy/CwDbUiCsJ8vR4xvGDDSOpDi5s7ASAdJCFYaC8o+z05SFNh8GDI4+bxf9EFJMTbl0wb23W233cx4lxSjVNz6l2rii/6r0LGIPtArH4xpSXmOURIYY/bbb7+4OMu6H/0szxkFQ3FSJgswGjChSv+ZBAMohmIfvoShOF9DTLluoueUlLGecc9zQiFMyhiOTIdc0bp160RMzCd1jMKgzsRRkuR3bzRkXOH+5VNKMYHLc1zoOMQkDhNeFMZx/9vIpw1p3ZfniP4gKX1lJTj63w/XYlwtxfNXiXqX4ho868g3adV5CmGQVLmgkLbke4x/1pMypuZb/0L3R7f0BtC4z7q3ixV6TY5LnytbMa3VsSIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAnVFQAbQurrdaqwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI1BcBGUDr636rtSIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiJQVwRkAK2r263GioAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEB9EZABtL7ut1orAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAnVFQAbQurrdaqwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI1BcBGUDr636rtSIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiJQVwRkAK2r263GioAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiEB9EZABtL7ut1orAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAnVFQAbQurrdaqwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI1BeBJvXVXLVWBNJP4KuvvnIvvviie+mll9xHH33kmjZt6g444ADXvXt3t9dee6W/gWqBCIiACIiACIiACIhAbAIff/yxW758uVu7dq3bunWryYOdOnVynTt3djvssEPs82hHERABERCB+iKATWHFihVu/fr1Zldo27at69atm2vRokVNgpABtCZvqxpVqwQ+/PBDN378ePf888+7d955x3366aeuSZMmbu+993YHH3ywGzJkiOvTp0+tNl/tEgEREAEREAEREAERCBB44okn3MMPP+zeeOMNU2A///xz17x5c9emTRt31FFHuZEjR7qWLVsGjtBHERABERCBeifAxNmECRPcM888495++22zK+y44442gYZdYcCAAfaqNU4ygNbaHVV7apbAJ5984m677Ta3aNEi99lnn7mDDjrI7bbbbg5B9/3337fv6ci++OIL169fv5rloIaJgAiIgAiIgAiIgAg4t2DBAjdx4kT3wgsvuNatW7tDDjnEJsY3bdpk3qAotciGV199taKE9MCIgAiIgAgYgc2bN7s//OEPjgm0jRs3ml2hffv2Zkf44IMP3FNPPWWRpn/5y1/caaedVlPUZACtqdupxtQygWnTprmnn37aBFtm9IMhTXvssYfN7uMZyn5HHnmkZvtr+WFQ20RABERABERABOqaAFFBU6dONeMncuGee+7ZwAMPULw+CW0kNH7KlClu9OjRDdv1QQREQAREoH4JzJgxwy1btsxh4OzZs2cju8Luu+/uWrVqZWPHY489ZqlUDjzwwJqBpUWQauZWqiG1TADvTzopZmTI6RQ0fvp2YwQlFyghUMzaqIiACIiACIiACIiACNQmgSVLlpjMt99++zUyfgZbe+ihh7oNGzaYIsu7igiIgAiIQH0TIJKU8eOtt95yRxxxRKRdYdddd3V4hGJXIPq0looMoLV0N9WWmiWwZs0ay+tEMmJyc2QqhD+RwJj9VURABERABERABERABGqTwOrVqx1eoMh+mQoyI7KjZMNMhPS9CIiACNQXAQyfOFWxhghriWQq3q7AWFNLJbMlpZZaqbaIQMoJbNmyxVzUWfE9W2E7ruzsryICIiACIiACIiACIlCbBJD1yAO/8847Z20g25ENyfmmIgIiIAIiUN8EGAsYE3KNHTvttJP78ssva86uIANofT//an1KCBDevssuu+QUXunQ2I/9VURABERABERABERABGqTALJes2bNbOXebC2UbJiNjraJgAiIQH0RIF809oJPP/00a8MJlcdDtNbsCjKAZr3t2igCySDQrl07C3Eif9PWrVszVurNN9+0pMWsAqoiAiIgAiIgAiIgAiJQmwSQ9QhRRPbLVFBgfZh8hw4dMu2m70VABERABOqEAHmj27ZtawbQbEbQWrUryABaJw+6mpluArio9+nTx2EIfe655xwCbbiQz+Ojjz5yJLw/9thjw5v1vwiIgAiIgAiIgAiIQI0Q6NWrl8l8GzdudGvXrt2uVYQ4IjMedNBB7oQTTjCPn+120hciIAIiIAJ1RYDc0P369XNMojFGRDlXvfvuu44X+zB+1FLJnPW0llqptohADRAYMGCALW60YMECW7mtVatWbrfddrP8T++//761sEePHm7EiBGuefPmNdBiNUEEREAEREAEREAERCCKAOHvI0eONC+eZ555xpRVZENCFvHqQXk98MADXe/evd3AgQOjTqHvREAEREAE6pAAjlWs8P7FF1+4pUuXupYtW7rdd9/d/meBJPJLd+/e3Q0fPtzttddeNUVIBtCaup1qTC0TIBHxJZdcYi7rGEHfeecdt2nTJsf3hDV16tTJnXnmme7ggw+uZQxqmwiIgAiIgAiIgAiIwDYCHTt2dGPHjnUPPvigW7lypfOpkpgIx0MUz53TTjst60q/AikCIiACIlBfBHbYYQf3ta99zdKozJs3z7399tsNdgWiBhhbhg0bZlEGtUZGBtBau6NqT00TYFZ/6NCh5rb+yiuvWMg74fEHHHCAGT7pzFQqQ4DQstWrV7tPPvnEwsoYLPDIVREBERABERABEUg/geA4j0ERb8okjvPU66qrrrIoIULhSZOExw6hiyx2oSICIiACIiACYQKEwhMdgDfoyy+/7NavX++aNm3qyBHavn17x/Zs5b333rNIA7xIW7Ro4fbff3+XBluEDKDZ7qq2iUBCCbAaG+HuKpUnQCc/Z84cN3/+fPPC3bJliw0W++67r92TIUOGWAhB5WumK4qACIiACIiACBRLgHF+9uzZNs4TRh4c53v27GkelYQKJqmgdBIBpCigJN0V1UUEREAEkk9g1113dd26dYtd0TVr1rhp06a5l156yRyBvvzyS9N9GX8GDRrkjj766NjnqsaOMoBWg7quKQIikEoCKEV33nmnW7hwoXv99dfNwwKvEFIRvPbaa5ZLZdWqVe6KK65w++yzTyrbqEqLgAiIgAiIQL0SIO/Zn/70J/fEE084xnM8KYPjPJEffpzfe++96xWT2i0CIiACIlCHBF544QU3btw49/zzz1u0AQ5ATMDhDYpBlCgEUvL1798/sXRkAE3srVHFREAEkkZg+vTp5hHy1ltvmbfnLrvs0lBFjKOEDyxatMjhoUtOrjSEATQ0QB9EQAREQAREoM4JPProo4486+RDw9uThYZ8YZxHwQuO836b3kVABERABESglgkQIj9+/HhbNInUK4S8BwvbWVUe/Zf0fKxPksSSPbA/iTVWnURABESgCgQ2btxoxk9WzOvatavl/QxWg8WoDj/8cLd161br/F988cXgZn0WAREQAREQARFIMAFyepPeBi/PLl26NDJ+Um3G+SOOOMJt3rzZxvkVK1YkuDWqmgiIgAiIgAiUjsDjjz9uzj6tW7fezvjJVYh+xOiJQ9CsWbNKd+ESn0kG0BID1elEQARqkwCLTr3zzjuuZcuWjoWnogozXiyGxH54iaiIgAiIgAiIgAikgwBKGzk/Ue40zqfjnqmWIiACIiAClSGAbkuoO96fmQp6MgsIvvrqq5YfNNN+1fxeBtBq0te1RUAEUkPgo48+Mq+PXAsfsELsp59+6jZs2JCatqmiIiACIiACIlDvBBi3Gb9zrfSucb7enxS1XwREQATqiwApYD788EOLhGjSJHsWTcZIIiXQnZNYZABN4l1RnURABBJHoGnTptbps0BCtsJ2wuQyeY9kO1bbREAEREAEREAEqkOAcZvxW+N8dfjrqiIgAiIgAskkwNiILowhNFdhH79/rn2rsV0G0GpQ1zVFQARSR4BkzqwG+/7772et+wcffOBYGTacGDrrQdooAiIgAiIgAiJQVQKM24zfGuereht0cREQAREQgQQSIM0bCwBn8+wk/J11M1q0aGFp4xLYDCcDaBLviuokAiKQOAIHH3ywO+yww6xe69ati6wfHT7b2rVr57p37x65j74UAREQAREQARFIHoH27dvbAg5ffvmlrQIfVUMWSiLPNzJBt27donbRdyIgAiIgAiJQcwR69uxpOi75sqM8Qb/66itbAInJRPbFCzSJJXsAfxJrrDqJgAiIQBUIsMDRsGHDzMC5bNkym93CK7R58+aW7JmFE9auXWsrxA4aNMi8SKpQTV1SBERABERABESgAAI77rijjfNvv/22C47zeLzg1cI4v2bNGnfkkUe60047zaJCCriMDhEBERABERCB1BHAuefYY481HXjJkiWuY8eOtvI7Y+fHH3/sVq1aZWHy7HfKKacktn0ygCb21qhiIiAC5SCAh+brr7/uNm3aZMZLPD6yrWYXrAOenZdccom5/7O63QsvvOC2bNniSAa97777uh49ephS1K9fv+Bh+iwCIiACIiACIpAwAniwMJa/9dZblveT8HciPS6++OKGcf65555zW7duNaVun332ccccc4wbMmSIO/HEExPWGlVHBERABERABEpPgAnAV155xSIjWOX9kEMOMR2ayUJWhsfzk4WP9ttvP9elSxc3atQo2176mpTmjDKAloajziICIpBwAsxM3Xfffe6ZZ56x/F4oNCx4QI6Szp07u3POOcc+52oGytENN9zgFi1aZIMB4XB4hxAO16tXL9emTZtcp9B2ERABERABERCBKhJAaXvooYfca6+9ZvnMMIbuuuuuNoZj3Lz++uvd0qVLzUAaHOfxfmndunUVa65Li4AIiIAIiEBlCDz77LNu2rRp5t2JLk2KGIyd6NBHHHGEa9WqlVUEffqoo46yFHB4hCa5yACa5LtTRN02b97sFi5c6F588UX33nvvWQ4G8jGQr4icDEl/MItoet0fimfj/Pnz3cqVKx0L8uCdiNcCnVL//v0dodyFFJQD3N0xIOJFyf90epz3hBNOMCNgIeetxDEka/79739vygyf27Zta0wwgqIEEdLGLNbYsWMbOvJs9UJJgiUvFREQAREQAREQgfQQQI656667HN6dTGCiyLHwETITMsKMGTPc8ccf7/75n/95uzA+5J9JkyZZJAn77rnnnpYTDTmIBSKqVVi5/qmnnjIZjRyleORgqD366KOtLbRRRQREQAREoDIEPvvsM/fkk0/aOEP6FGwvOMngIclEGvp5OQqTelz3jTfesGhHIhvw2GRizxsr416X80yYMME9//zzbvfdd7doR9rBpODq1astBL5Dhw7WLjxEcTR65JFHLLISpyDSxSSxlId8EltaR3V68803TbBbsWKFhfVgqUcQQsjDgEVeI1yTeZBVaosAod133323GT8RgP29b9q0qd13OqsLLrggb2MlHd24cePc008/bXkuCfvGkEpyY56pxYsXu4suushc35NIdPLkyVZP6sagEzQCE/7OYIGnx8SJE91VV13VaHsS26M6iYAIiIAIiIAI5E8Ao+W9995rhkLyl23YsMGMmbwj2yAvExbvDaLXXXedTfJypXnz5rkpU6bY/h9++KEptMhZKJjIQYMHD3YDBw7Mv1JFHrF+/XqT0TDskoscxRs5BwUbGY3XhRdemLfyW2S1dLgIiIAI1CUBDJ5MsmE49ClWGFuYiKI/RuekT2bsKFXh/EQ1zJkzp2GCDj2d7/HOZIw6++yzTQ+Oc03acP/995sB9/DDDzfHIX8chlz05wULFlh7SAPHdSiMidiYaGefPn3ceeedVzZjr69Pvu8ygOZLLOH7I8Ddcccd7oknnrDcCyShxfBJwW0ZoQ7hj3LFFVfIE9RI1MYfPH2593gA7LXXXubp62f86cSYmZk1a5YJxeSxjFvw9MT4SYeKdykh4HvssYcdjrKA0RWPU/a75pprzBsi7rkrsR/KAO77GHGZjQoaP7k+/zMzxsQAOT3xCKWjVxEBERABERABEagtAsjHyMJ4R27cuNFWrMWYiSKKdwwyAQZEJoxJdYP3C+F+5EBjMhWFlnzgyEIolyh7yFjLly+3XKHI3H379q0YNOp65513mnEWL1Cicqgv5dNPP7UJXgy3yGhX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+w0XAXbKTTfd1Dz11FPNuuuu2yxZsqTYKRtttNFw3UhqGwIhEAIhsGgE4gBdNPSDc+Hf//73zRlnnFGUyQceeKB59tlnm5VXXrkok1tssUWz//77NwcccECz0korDU6lU5MQCIEQCIEQCIEQCIGxIvDrX/+6+d73vtfceeedzaOPPtq89NJLzWqrrdasvfbazTbbbNMceeSRzSabbDJWTEb9Zjk82SnXXXddc9999xWnt2fO8bnVVlsVO4WtkhICIRACIRACkxGIA3QyQiO+/fnnn2++/vWvN1dffXWJqFIkRFRfeeWV5rHHHmuuv/768vuLL77YHHbYYSNOI7cXAiEQAiEQAiEQAiEwiASMUqKz/uIXv2jWX3/9oq+uvvrqJXD/29/+trnqqquaZ555pnn729/ebL755oN4C6nTNAnI8P27v/u7Yqc8+eST5dnK+H3LW95S7JNrr7228TtH+MEHHzzNs2f3EAiBEAiBcSMQB+i4PfGO+7344oubG264oeHgfP/7318yP+su66yzTomiG2Z0ySWXNO95z3uad77znXVzvkMgBEIgBEIgBEIgBEJg3gm88MILzfe///3i/Nx6663fkOXJCcohdv/99zc333xzc/bZZzennXZaRi7N+1OZ/wtceOGFzfLly0tihmm5ODqVNdZYo9lggw1W2CkXXXRRsVOMXEsJgRAIgRAIgV4EsghSLzJj8DslQuTUcJJ3v/vdb3B+1ttfc801G4rmXXfd1VxzzTX153yHQAiEQAiEQAiEQAiEwIIQ4Ni84447mre+9a1vcH62L77ZZpuV/956661liHx7W/4ePgKSMwx7/5d/+Zdip3Sbiks2qJFr5oONnTJ8zzg1DoEQCIGFJhAH6EITH6DrUSjMn2TieJHzXsVcSk888URz991399olv4dACIRACIRACIRACITAvBCgg1qk821ve1vf81u403733HNP3/2ycfAJSNCodorFWXsVbcIzj53Si1B+D4EQCIEQqATiAK0kxvDb/J+yQPs5P2GxIJJicaSUEAiBEAiBEAiBEAiBEFhIAlPVWem0dFv7pww3Ac/w5ZdfLotc9buTVVZZpXn11VfzzPtByrYQCIEQCIFCIA7QMW4I6667bplDxwTj/QpFsq4K32+/bAuBEAiBEAiBEAiBEAiBuSYwVZ2VTmt+SPunDDeB+swnS8Aw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IRACIRACIRACIRACIRACIRACIRACIRACITDsBFYd9hsY1fpb8frMM89srrvuuubxxx9vtttuu7Lq7iGHHJJVyOf4oVth1apz9957b/OOd7yj2WmnnZr99tuv/N3rUrfccktzxhlnNL/73e+atddeuxxj9bJtttmm1yH5vQ+BK6+8svnZz37W3Hrrrc1KK61UOJ5wwgnNVltt1fOoPIOeaKa94bHHHmtOP/305rbbbmseffTRZvPNN2+WLVvW7Lvvvs3KK3ePk6WPmjbmoT0g71r3R/fss882/+7f/btm0003bf7Df/gP3Xea+HUc3xX9iD7Fqs0PPvhg87a3va3Zeuutm+OPP77ZZJNNurIaR06PPPJI861vfausbP3cc88173nPe5pdd921Wbp0aVdGfhxHTp0wli9f3vzP//k/mz333LP5whe+0Lm5/H/cOOmPvvrVr3ZlUX88/PDDm3e96131v0PDadye5Rse0Ij950c/+lHzjW98o/lP/+k/NTvssEPPu5uJ3jGTY3pWIBtmTOCSSy5pLr/88mJXv/rqq8WW++AHP1jsil4nncmzm8kxva6f32dOYKH8KHMpB7IK/Myf97wd+cQTTzSnnXZac88995RrbLjhhg0HhbLPPvs0//E//sdmtdVWK//PPzMn8PLLLzd//ud/XhxvzrLuuus2Tz/9dPPaa6816623XvOXf/mXzY477vimC3BM//f//t////bOBMqK4vrDZRBlU1EQFGVRETAqqyAQjBARQwgiiUBUIqAoGECOgBDc8pewSEyIikQEFRdkSVBBcANFoxgQg7IEUESiyGYOhiCKCur836881fZ7r9/Mm56eYd70d895r7tr6+qveqm+feuWDa9SpYo5cOCA/VWsWNHccccdpnnz5ml5CAgmcPDgQTN58mTz1FNP2QTi/uWXX9oXvHLlyplbbrnFdOzYMS0zbZCGJHTAihUrzNixY83evXttGdWrVzd6KZeIve43qcI9KpVI2d3mWgtuWz0nRo8ebfTxRgqre+65JzBhHK8VfVAcP368kUJP9/Fq1arZDyvffPON0XNy1KhR5oILLkjiFUdO+uinZ5yeeRL1Qfbt22fXf/azn5mRI0emffCOIycLxPcnRn379jX/+c9/eEb5uKxdu9YMGjTIF5K+qme9Pmw6yYXzKRfq6HiyzJ/AunXrzPXXX2/0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JvLyoyzw1FNPtfXs1q1blMVGWtZnn31m1q5dG2mZFAYBCEAAAhCAAATiQgAFaFxamuOEAAQgAAEIQAACh4hAXl7eIdpz2djtX//6V9OoUSPz7LPPlo0D4iggAAEIQAACEIBACRM4vIT3x+4gAAEIQAACEIAABCAAgSwJfPzxx6ZXr15ZpiYZBCAAAQhAAAIQgEAQASxAg6gQBgEIQAACEIAABCAAAQhAAAIQgAAEIAABCJQJAihAy0QzchAQgAAEIAABCEAAAhCAAAQgAAEIQAACEIBAEAGGwAdRIQwCEIAABCAAAQhAIHICn3zyiVmxYoVZtWqVqVOnjmnVqpX1bfmDH6R/kz9w4IBZvXq1rYPSnnDCCYH1UZnvv/++jTvzzDNN5cqVA9Pt3bvXPPPMM2bz5s2mWrVqpl27dubss882QfsOKkD55YNzy5YtpkKFCqZNmzamefPmdn3btm1mx44dpmLFirbMoPwKUxlr1qyxP603btzYNG3a1LIIyvPmm28aHZ8T7WflypV2s0WLFqZcuXIuiiUEIAABCEAAAhCAQD4EUIDmA4coCEAAAhCAAAQgAIFoCGgin759+5ovvvgiqcAmTZqYefPmmfr16yeF79y505x77rk27M477zQjRoxIincbUmr26dPHbko52LJlSxflLceNG2cmTpxo9u3b54VpRQpI5S9IMuWvVauWeeqpp8z8+fPNhAkTTIMGDcy7776bVpwmgZo0aZK5+eabzVdffZUWf/nll5spU6aYqlWrJsW1bdvWfP31116Y0ugn+d///meOOeYYL44VCEAAAhCAAAQgAIHMBFCAZmZDDAQgAAEIQAACEIBABARmzpxpLS9lsSil5hlnnGGtIN9++227POecc6wSsX379hHsLbmIa6+91kyfPt0GVqlSxVpuHnfccWb58uVm7dq1tj779+9PzuTbGjBggJk2bZoNkXVp69atTY0aNcwbb7xhrUHPP/98I8vTTCKF789//nOzdOlSm6RmzZp2n1JeyhJ2w4YNZtasWWbZsmVm8eLFpmHDhl5RsvL88ssvLSMFnnTSSebEE0+08Vh/ephYgQAEIAABCEAAAgUSQAFaICISQAACEIAABCAAAQgUhYCGnVevXt1aekph6ERWof369bNDwwcNGmTWrVuX9ZB0V0Z+y+eee85TfsoyVNaaUiJKZJV56623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" width="672" /></p>
<p><strong>input variables</strong></p>
<p><br /><br /><br /></p>
<p><strong>output variable</strong></p>
<p><br /><br /><br /></p>
<p>More generally </p>
<p><br /><br /><br /><br /><br /><br /></p>
<p><span class="math display">\[
Y = f(X) + e.
\]</span></p>
<p><br /><br /><br /></p>
<p>Essentially, <em>statistical learning</em> is a set of approaches for estimating <span class="math inline">\(f\)</span>.</p>
<div id="why-estimate-f" class="section level2">
<h2><span class="header-section-number">1.1</span> Why estimate <span class="math inline">\(f\)</span>?</h2>
<p>There are two main reasons we may wish to estimate <span class="math inline">\(f\)</span>.</p>
<p><strong>Prediction</strong></p>
<p>In many cases, inputs <span class="math inline">\(X\)</span> are readily available, but the output <span class="math inline">\(Y\)</span> cannot be readily obtained (or is expensive to obtain). In this case, we can predict <span class="math inline">\(Y\)</span> using</p>
<p><span class="math display">\[
\hat{Y} = \qquad \qquad
\]</span></p>
<p>In this case, <span class="math inline">\(\hat{f}\)</span> is often treated as a black box, i.e.we dont care much about it as long as it yields accurate predictions for <span class="math inline">\(Y\)</span>.</p>
<p>The accuracy of <span class="math inline">\(\hat{Y}\)</span> in predicting <span class="math inline">\(Y\)</span> depends on two quantities, <em>reducible</em> and <em>irreducible</em> error.</p>
<div class="page-break-after"></div>
<p>We will focus on techniques to estimate <span class="math inline">\(f\)</span> with the aim of reducing the reducible error. It is important to remember that the irreducible error will always be there and gives an upper bound on our accuracy.</p>
<p><strong>Inference</strong></p>
<p>Sometimes we are interested in understanding the way <span class="math inline">\(Y\)</span> is affected as <span class="math inline">\(X_1, \dots, X_p\)</span> change. We want to estimate <span class="math inline">\(f\)</span>, but our goal isnt to necessarily predict <span class="math inline">\(Y\)</span>. Instead we want to understand the relationship between <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>.</p>
<p><br /></p>
<p>We may be interested in the following questions:</p>
<ol style="list-style-type: decimal">
<li><p><br /><br /><br /></p></li>
<li><p><br /><br /><br /></p></li>
<li><p><br /><br /><br /></p></li>
</ol>
<p>To return to our advertising data,</p>
<p><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /></p>
<p>Depending on our goals, different statistical learning methods may be more attractive.</p>
<div class="page-break-after"></div>
</div>
<div id="how-do-we-estimate-f" class="section level2">
<h2><span class="header-section-number">1.2</span> How do we estimate <span class="math inline">\(f\)</span>?</h2>
<p><strong>Goal:</strong></p>
<p><br /><br /><br /></p>
<p>In other words, find a function <span class="math inline">\(\hat{f}\)</span> such that <span class="math inline">\(Y \approx \hat{f}(X)\)</span> for any observation <span class="math inline">\((X,Y)\)</span>. We can characterize this task as either <em>parametric</em> or <em>non-parametric</em></p>
<p><strong>Parametric</strong></p>
<ol style="list-style-type: decimal">
<li><p><br /><br /><br /><br /><br /><br /></p></li>
<li><p><br /><br /><br /><br /><br /><br /></p></li>
</ol>
<p>This approach reduced the problem of estimating <span class="math inline">\(f\)</span> down to estimating a set of <em>parameters</em>.</p>
<p>Why?</p>
<div class="page-break-after"></div>
<p><strong>Non-parametric</strong></p>
<p>Non-parametric methods do not make explicit assumptions about the functional form of <span class="math inline">\(f\)</span>. Instead we seek an estimate of <span class="math inline">\(f\)</span> tht is as close to the data as possible without being too wiggly.</p>
<p>Why?</p>
<div class="page-break-after"></div>
</div>
<div id="prediction-accuracy-and-interpretability" class="section level2">
<h2><span class="header-section-number">1.3</span> Prediction Accuracy and Interpretability</h2>
<p>Of the many methods we talk about in this class, some are less flexible  they produce a small range of shapes to estimate <span class="math inline">\(f\)</span>.</p>
<p>Why would we choose a less flexible model over a more flexible one?</p>
</div>
</div>
<div id="supervised-vs.unsupervised-learning" class="section level1">
<h1><span class="header-section-number">2</span> Supervised vs.Unsupervised Learning</h1>
<p>Most statistical learning problems are either <em>supervised</em> or <em>unsupervised</em> </p>
<div class="page-break-after"></div>
<p>Whats possible when we dont have a response variable?</p>
<ul>
<li><p>We can seek to understand the relatopnships between the variables, or</p></li>
<li><p>We can seek to understand the relationships between the observations.</p></li>
</ul>
<p><br /><br /><br /><br /><br /></p>
<p><img src="data:image/png;base64,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65JrSc/4vPrqq2Xz5s0pfQ+FQonk5x577JFyzKsV+++/v2PXXn75ZcfZrY4nN6iMx+Ny8803N6j94duf//zn0rJlS8djVCKAAAIIIIAAAggggAACCCCAAAIIFEaABGhhnEuylfvuu0/07EancuGFF8quu+7qdMizdToh6VS+//57ufvuu50ONVn30ksvidPj75ZlyVFHHdXk9ZyAAAIIIIAAAggggAACCCCAAAIIIGBWgE2QzPqWbHS9Nuajjz7q2P9DDz1UfvGLXzgeM125fv16effddx2bOeCAA6Rdu3aOx3TlwIEDZffdd5epU6emnPPYY4/JXnvtJUOHDk05lq7izTfflP/93/91PPyb3/xGevTo4XiMSgQQQAABBBBAAAEEEEAAAQQQQACBwgmQAC2cdUm19NBDD4l+vLthqaiokN69e8v48eMbHsr7+6YSmLqBlStXyo033ujYVv/+/RtNgOqLLrroIjnllFPEaTf7Sy+9VE499VQ55phjJBBI/9KoqamRW265RV555RXHfuid5c8880zHY1QigAACCCCAAAIIIIAAAggggAACCBRWIH2Wp7D9oDUPCSxZskT07EanUldXJ7fddpvTobzrMklg5ttIr1695IwzzpA777wzJZQem65//fXX5cQTTxTdH53M1MlQPfN0+vTpiQ99XM+QdSqtWrVKrJuqE8UUBBBAAAEEEEAAAQQQQAABBBBAAIHiC5AALf498FwP3n77bccZkp7raI4dOuGEE2TNmjXy1FNPOUaYO3eu/O1vf0sc08lPvYP86tWrHc+tX6k3PLrpppsSidP69XyNAAIIIIAAAggggAACCCCAAAIIIFA8ATZBKp69Z1vWCcByL+eee66cdNJJojcraqxEo9GMkp/t27dPPJo/aNCgxsJxDAEEEEAAAQQQQAABBBBAAAEEEECgwAIkQAsMXgrNNYcEqE586kfhb731VunSpUvOt0XHOeKIIxIbRg0ePDjnOFyIAAIIIIAAAggggAACCCCAAAIIIGBGgEfgzbiWbFS98dGCBQtKtv/ZdnzIkCHyxBNPiH7s/8knn5RZs2ZlFKJ169ay3377JZKfzPrMiIyTEEAAAQQQQAABBBBAAAEEEEAAgaIIkAAtCrv7jd51112uBPX5fIlkoCvBDATp16+fTJw40dXIep3PMWPGJD5WrVolU6dOle++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YwgggAACCCCAAAIIIIAAAggggAACiRfgFvjEm6dEixMmTNC9n2q39QcffFC2b98eFHvgwIFy0UUXBZUbVaD6onaAP/kYNGiQDB069OTiqL9Wu8BzIIAAAggggAACCCCAAAIIIIAAAggkX4AsTfLnwJQ9aNasme79evHFFzWTn61bt5bbbrtN9/bKC7h161bNXe67dOkizZs3L+9SziGAAAIIIIAAAggggAACCCCAAAIIpJAAt8Cn0GSlclfnzZsnkycHPz25WrVq8ve//10yMjISOrxQt7+3aNEiof2gMQQQQAABBBBAAAEEEEAAAQQQQAABYwVIgBrrS3SfwK+//upPcp6MoW4Tf/TRR6V69eonnzL8a60EaH5+vtStW9fwtmkAAQQQQAABBBBAAAEEEEAAAQQQQCBxAiRAE2edli2VlJTI/fffL0ePHg0a/5gxY6Rt27ZB5Yko0NoBntWfiZCnDQQQQAABBBBAAAEEEEAAAQQQQCCxAiRAE+uddq09++yzsnbt2qBxt2/fXoYMGRJUnqgCrRWgJEATpU87CCCAAAIIIIAAAggggAACCCCAQOIE2AQpcdZp19LPP/8sH3zwQdC41a3vd9xxh9hstqBziSjYvXu3HDp0KKipli1bBpVRgAACCCCAAAIIIIAAAggggAACxgis2Cri9eoXu2ltkWZ19ItHJOsIkAC1zlyaaiQej0eefvppzT5dccUV0qhRI81ziSjUWv2p2mUFaCL0aQMBBBBAAAEEEEAAAQQQQACB3wS+WSGiXnodfziDBKhellaLwy3wVptRk4znww8/FK1Eo9pkaOTIkUntpdbzPytWrCh16vDfREmdGBpHAAEEEEAAAQQQQAABBBBAAAEEDBBgBagBqOke8uDBg/Lyyy9rMtx2222SlZWleS5RhVrPJD311FM1m3e5XLJt2zbZunWr2O12qVq1qn/X+lq1amnWpxABBBBAAAEEEEAAAQQQQAABBBBAwFwCJEDNNR+W6M2ECRPkyJEjQWPp27evdOvWLag80QVaK0DLPv9TPbv03XffFVVv+/bt4na7g7qoVov26NFD+vXrl7Sd7IM6RQECCCCAAAIIIIAAAggggAACCCCAQJAACdAgEgriEVi5cqXMnDkzKEROTo6MHj06qDzRBQUFBfLrr78GNaue/7l69Wp55ZVXZOHChUHnTy7YsWOH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6i3wqkPLli2TM844Q2688caoVn8eO3ZMevToIePGjZPS0lKtsVGGAAIIIIAAAggggAACCCCAAAIIIIAAAmkukLQEqMvlkocffli6dOkiCxcujGkaCgsL5d5775XOnTv7d36PKQgXIYAAAggggAACCCCAAAIIIIAAAggggIBlBZKSAF29erV/1eeDDz4oKhEa77F8+XLp3r27PPTQQ+J2u+MNx/UIIIAAAggggAACCCCAAAIIIGBige37RH5Yb+IO0jUEEDCVQEIToF6vV8aPHy+dOnWSxYsXRwRRr149Oeuss8LWVYnUsWPHSu/evWXr1q1h61MBAQQQQAABBBBAAAEEEEAAAQRSU2DOzyKPTU/NvtNrBBBIvEDCEqA7duyQ8847T/7617+KunU9kuPiiy8Wtbpz7ty5/uSm3R6+u/PmzfNvjDRt2rRImqAOAggggAACCCCAAAIIIIAAAggggAACCFhYIHxGUYfBv//++9KuXTv54osvIopWoUIFeeWVV2TGjBlStWpVUYlPdbv8l19+KXXr1g0bQ+0oP3z4cLnmmmukoKAgbH0qIIAAAggggAACCCCAAAIIIIAAAggggIA1BQxNgKrk47XXXitqJee+fb4HdERwqA2Nli5d6k9enlxd3d6udo1XK0kjOV577TX/7fY//PBDJNWpgwACCCCAAAIIIIAAAggggAACCCCAAAIWEzAsAbpo0SLp2LGjfyVnJGZqlafa0f27776T5s2bh7ykRo0aMmvWLBk3bpw4nc6Q9QIn1q5d699w6Z///KeoZ5ByIIAAAggggAACCCCAAAIIIIAAAggggED6COieAFW7sD/66KNy5plnyrp16yKSPOWUU/y3tz/22GMRJTVtNpvcfffd8s0330iDBg3CtlFSUiJ33nmnDBgwQNSzSDkQQAABBBBAAAEEEEAAAQQQQAABBBBAID0Ewi+hjMJh8+bNMmLECJk/f37EV1166aXy0ksvSZUqVSK+JlCxR48e/lvir776avnwww8DxSE/zp49279Bkro1fuDAgSHrcQIBBBBAAAEEEEAAAQQQQAABBBCwmsAG35qwjxYbO6oLTxc5tZ6xbRAdgWgFdEuAvv3223LzzTfL4cOHI+pDXl6ePPvsszJq1KiI6oeqpBKnH3zwgYwfP17uuusuUas9yzv27NkjgwYNktGjR8uTTz4pWVlZ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AAHQ6JwohQACCCCAAAIIIIAAAggggAACCCCAAAI+FCAA6sODRpcRQAABBBBAAAEEEEAAAQQQQAABBBBAIDqBLtEVoxQCCCCAAAIIIIAAAggkKvDZZ59JfX192GrS0tLk3HPPlW7duoUt49SGhoYG0f41NzeHbeLss8+WXr16hd1u54YnnnhCysrK9lZ58MEHyy233LL3NT8ggAACCCCAAALRCqQFfsEJ/xtOtLVQDgEEEEAAAQQQQAABBDoUeOSRR2T48OERy91zzz0yZsyYiGWc2HjvvffK2LFjw1Z9ySWXyJIlS0SDtE6nWbNmyU033dSmmaFDh8qqVava5PECAQQQQAABBBCIRoAAaDRKlEEAAQQQQAABBBBAwAaBxsZGOf/882Xp0qVha+vUqZN89NFHct5554UtY/cGDWxedtllYe/+POyww2T16tXSv39/u5sOqW/Hjh0yZMiQNnd/aiECoCFUZCCAAAIIIIBAlALMARolFMUQQAABBBBAAAEEEEhUoHPnzvLiiy9Knz59wlbV1NQk1113nZSWloYtY+eGrVu3yvXXXx82+Kl9njdvnivBTx2XPube+tF3O8dKXQgggAACCCCQmgIEQFPzuDNqBBBAAAEEEEAAgSQJHHHEETJ16tSIrefm5sqf//zniGXs2FhXVydXXXWVFBcXh63u4YcfDs5LGraAjRt03k+9G5WEAAIIIIAAAgjYKUAA1E5N6kIAAQQQQAABBBBAIAqBa665Rv7whz9ELLlgwYLg3aIRCyW48e9//7t8/fXXYWu56KKL5L777gu73c4N06dPlzvvvNPOKqkLAQQQQAABBBAICjAHKCcCAggggAACCCCAAAJJECgvL5dTTz1VNm/eHLb1/fbbT9asWSNHHnlk2DLxbli0aJFcccUVYXfXVde/++47GTBgQNgydm2YM2eO3HjjjWEfw9d2mAPULm3qQQABBBBAIPUEuAM09Y45I0YAAQQQQAABBBDwgIAGN+fOnSs6x2a4pEFSvVNUF0+yM23cuDEYcAxXpy7E9NJLL7kS/Jw/f35wxffm5uZw3SEfAQQQQAABBBBISIAAaEJ87IwAAggggAACCCCAQPwCP/3pT2X48OERK1i2bJmMHj06YplYNtbU1MiVV14pGlwNl7RPulq900nn/NQAry78REIAAQQQQAABBJwS4BF4p2SpFwEE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hggQIECAAAECBKoq8MMPP8RNN90U3d3d/d7i77//HrNnz47Ozs5+XyORAAECBAgQIFAlAQPQKnXTXggQIECAAAECBCorkD3Ls6mpKb7//vsB7/GTTz6Je++9d8DXuYAAAQIECBAgUAUBA9AqdNEeCBAgQIAAAQIEKi/Q0tIS2TM9847Ro0fnhXrOv/DCC7Fly5ZkjiABAgQIECBAoIoCBqBV7Ko9ESBAgAABAgQIVEpg+/bt0dzcnLunbPiZ5UyYMCE3JwvMnTs3vvvuu2SOIAECBAgQIECgagIGoFXrqP0QIECAAAECBAhUSmDPnj09z/Ds6urK3dfDDz8c5513XrS1teXmZIEff/wxbrnllshup3cQIECAAAECBIaLgAHocOm0fRIgQIAAAQIECNSkwK233hq7d+/Orf3cc8+NRYsW9cSvvPLKaGxszM3NAlu3bo0VK1YkcwQJECBAgAABAlUSMACtUjfthQABAgQIECBAoFICK1euTD6384gjjoi1a9dGfX39oX1n15x88smHfu7tLw899FDs3Lmzt5BzBAgQIECAAIHKCRiAVq6lNkSAAAECBAgQIFAFgffeey8WL16c3Ep26/sFF1zwj5zjjjuuZyj6j5P/+mH//v3R0NAQv/76678ifiRAgAABAgQIVE/AALR6PbUjAgQIECBAgACBGhfYt29fzJo1K7JBZd4xffr0yL7J2dtxxRVXxMKFC3sLHTr32Wefxd13333oZ38hQIAAAQIECFRVwAC0qp21LwIECBAgQIAAgZoVuO2222LXrl259Y8bNy7Wr18fI0eOzM1paWmJKVOm5MazwOrVq+PVV19N5ggSIECAAAECBGpdwAC01juofgIECBAgQIAAgUoJZG9yf/nll5N7WrVqVUyaNCmZM2rUqNiwYUMceeSRybxs2Prtt98mcwQJECBAgAABArUsYABay91TOwECBAgQIECAQKUEPvrooz5vS8/eCj9jxox+7fv888+Pxx9/PJm7Z8+eaGpqiu7u7mSeIAECBAgQIECgVgUMQGu1c+omQIAAAQIECBColMAvv/wSM2fOjN9++y13X5MnT45nnnkmN95bYNGiRXHppZf2Fjp07o033ojW1tZDP/sLAQIECBAgQKBKAgagVeqmvRAgQIAAAQIECNSswPz58+PTTz/NrT+7lb2joyPGjBmTm9NboK6uLtatWxfZc0NTR/ZG+ezN8w4CBAgQIECAQNUEDECr1lH7IUCAAAECBAgQqDmBbEDZ3t6erHvp0qUxderUZE5ecOLEifH888/nhXvO//HHH9HQ0BDZN1EdBAgQIECAAIEqCRiAVqmb9kKAAAECBAgQIFBzAtm3PhcsWJCs+/LLL4/sVvbDOWbNmhWNjY3JJb744ou46667kjmCBAgQIECAAIFaEzAArbWOqZcAAQIECBAgQKAyAp2dnXHjjTcmv3V5wgkn9NzCPmLEiMPe93PPPRennnpqcp21a9fG5s2bkzmCBAgQIECAAIFaEjAAraVuqZUAAQIECBAgQKBSAvfcc098/PHHyT1lA8lTTjklmdPf4NixY3tutc+eC5o67rjjjvj6669TKWIECBAgQIAAgZoRSP/Lp2a2oVACBAgQIECAAAECtSWwadOmaGtrSxa9cOHCuPrqq5M5Aw1Onz49HnjggeRle/fujZtvvjm6u7uTeYIECBAgQIAAgVoQMACthS6pkQABAgQIECBAoFICu3btittvvz25p3POOSdaW1uTOf9v8NFHH41p06YlL3/rrbdi2bJlyRxBAgQIECBAgEAtCBiA1kKX1EiAAAECBAgQIFAZgf3798fMmTNj3759uXsaNWpUdHR0xNFHH52bcziB+vr6WL9+fYwePTq5zCOPPBLvvvtuMkeQAAECBAgQIFB2AQPQsndIfQQIECBAgAABApUSWLx4cezYsSO5p+XLl8fZZ5+dzDnc4JlnnhlPPfVUcpmurq5oaGiIn3/+OZknSIAAAQIECBAos4ABaJm7ozYCBAgQIECAAIFKCWzZsiVWrlyZ3NN1110X8+fPT+YUFcxednTNNdckl8tu17/zzjuTOYIECBAgQIAAgTILGICWuTtqI0CAAAECBAgQqIzA7t27Y86cOcn9jB8/Pl588cVkTtHBNWvWxEknnZRcdt26dbFx48ZkjiABAgQIECBAoKwCBqBl7Yy6CBAgQIAAAQIEKiOQ3Uo+e/bsyN6unnfU1dVFe3t7HH/88Xkpg3L+xBNP7NfQdd68efHVV18NSg0WJUCAAAECBAgMpoAB6GDqWpsAAQIECBAgQIDA3wLNzc2xffv2pMV9990Xl112WTJnsIJXXXVVn7fd//TTT9HY2Bh//vnnYJVhXQIECBAgQIDAoAgYgA4Kq0UJECBAgAABAgQI/E/gtddei5aWliTHhRdeGEuWLEnmDHYwe/HSWWedlfyYbdu2xdKlS5M5ggQIECBAgACBsgmMOPD3Ubai1EOAAAECBAgQIECAAAECBAgQIECAAIEiBHwDtAhFaxAgQIAAAQIECBAgQIAAAQIECBAgUEoBA9BStkVRBAgQIECAAAECBAgQIECAAAECBAgUIWAAWoSiNQgQIECAAAECBAgQIECAAAECBAgQKKWAAWgp26IoAgQIECBAgAABAgQIECBAgAABAgSKEDAALULRGgQIECBAgAABAgQIECBAgAABAgQIlFLAALSUbVEUAQIECBAgQIAAAQIECBAgQIAAAQJFCBiAFqFoDQIECBAgQIAAAQIECBAgQIAAAQIESilgAFrKtiiKAAECBAgQIECAAAECBAgQIECAAIEiBAxAi1C0BgECBAgQIECAAAECBAgQIECAAAECpRQwAC1lWxRFgAABAgQIECBAgAABAgQIECBAgEARAgagRShagwABAgQIECBAgAABAgQIECBAgACBUgoYgJayLYoiQIAAAQIECBAgQIAAAQIECBAgQKAIAQPQIhStQYAAAQIECBAgQIAAAQIECBAgQIBAKQUMQEvZFkURIECAAAECBAgQIECAAAECBAgQIFCEgAFoEYrWIECAAAECBAgQIECAAAECBAgQIECglAIGoKVsi6IIECBAgAABAgQIECBAgAABAgQIEChCwAC0CEVrECBAgAABAgQIECBAgAABAgQIECBQSgED0FK2RVEECBAgQIAAAQIECBAgQIAAAQIECBQhYABahKI1CBAgQIAAAQIECBAgQIAAAQIECBAopYABaCnboigCBAgQIECAAAECBAgQIECAAAECBIoQMAAtQtEaBAgQIECAAAECBAgQIECAAAECBAiUUsAAtJRtURQBAgQIECBAgAABAgQIECBAgAABAkUIGIAWoWgNAgQIECBAgAABAgQIECBAgAABAgRKKWAAWsq2KIoAAQIECBAgQIAAAQIECBAgQIAAgSIEDECLULQGAQIECBAgQIAAAQIECBAgQIAAAQKlFDAALWVbFEWAAAECBAgQIECAAAECBAgQIECAQBECBqBFKFqDAAECBAgQIECAAAECBAgQIECAAIFSChiAlrItiiJAgAABAgQIECBAgAABAgQIECBAoAgBA9AiFK1BgAABAgQIECBAgAABAgQIECBAgEApBQxAS9kWRREgQIAAAQIECBAgQIAAAQIECBAgUITAXwOXOLUbvec/AAAAAElFTkSuQmCC" width="50%" /><img src="data:image/png;base64,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EEAAAQRaXYAEaKuTZ77gI488kvbkWWedJX379k17rqWD+pliejMlnehs/EzRp59+Wk4++WTp0KFDS2E4jwACCCCAQJsKJJctlfgLz0tixkei/kHL3Jd27SR00CES+vZ3xVTPG6QggAACCCCAAAIIIIAAAtwC76HPwBdffNGkN3qnd52kLKQMGDBAjjrqqCYhampq5NNPP21ynAMIIIAAAgh4RcBWG0pE//6Y1F71W0lMf7/55KfutFohGn/5Ran51WUSn/KuV4ZBPxBAAAEEEEAAAQQQQKANBUiAtiF+w0tvULfx6R2/G5d+/fo5sjPs4MGDG4dOfb18+fK0xzmIAAIIIIBAWwvo293r/vxHib/ykqgHZOfWHfWol+jf7pHo44+KbVm5taU2AggggAACCCCAAAII+EqAW+A9Mp0rVqxI25P+/funPZ7rQb0KNF1ZuXJlusMcQwABBBBAoE0FbPVsz9qb/yTW/HkF9SP+6sup9mWnnFZQHBojgAACCCCAAAIIIIBA8QqwAtQjc5cpEalXgDpRMiVSWQHqhC4xEEAAAQScFog+/EDByc/6PukkaPzdt+u/5L8IIIAAAggggAACCCBQYgIkQD0y4eFwOG1PYrFY2uO5HrS4/S9XMuojgAACCLSRQOLTTyTx7juOXj366CNibdroaEyCIYAAAggggAACCCCAQHEIkAD1yDzttNNOaXuyZs2atMdzPbhgwYK0Tbp06ZL2OAcRQAABBBBoK4HY0085f2n1nO34iy84H5eICCCAAAIIIIAAAggg4HkBEqAemaLKysq0PZkzZ07a47kezJQA7datW66hqI8AAggggIBrAkn1Bztr6RJX4sfVqlLboTsrXOkgQRFAAAEEEEAAAQQQQMAVARKgrrDmHnTXXXeV7t27N2k4d+5cWbRoUZPjuR7IlEgdOXJkrqGojwACCCCAgGsCiZkfuRZb1M7wyS+/cC8+kRFAAAEEEEAAAQQQQMCTAiRAPTQt+++/f9rePPPMM2mPZ3tw9uzZ8vrrrzepHolEZO+9925ynAMIIIAAAgi0lUChu7631O/kgvktVeE8AggggAACCCCAAAII+EyABKiHJvSYY45J25vnn39ePvjgg7TnWjoYjUbl97//vdi23aTqIYccImVlZU2OcwABBBBAAIG2ErDWrnX10vZaZ56t7WonCY4AAggggAACCCCAAAKOCpAAdZSzsGB77rmnHHjggWmD3HDDDZLpOZ5pG6iDiURCbrnlFlm2bFmTKnrX+QkTJjQ5zgEEEEAAAQTaUsCuq3X18nZtnavxCY4AAggggAACCCCAAALeEyAB6rE5Oe+880QnJxuXqqoqOeecc+TFF19sfCrt119++aWcffbZGeuffPLJ0qNHj7RtOYgAAggggEBbCRihkKuXNkJBV+MTHAEEEEAAAQQQQAABBLwnQALUY3PSu3dvufLKK9P2KqZ2rr3xxhvl1FNPlSeeeEJWrVolyWQyVdeyLFm6dKm89dZbcvPNN8u5554rCxcuTBtn7NixctZZZ6U9x0EEEEAAAQTaUsDYqYurl3c7vqudJzgCCCCAAAIIIIAAAgjkJcAyiLzY3G106KGHil4Jes8996S9kE503nnnnalXIBCQrl27yqZNm0QnSFsqAwcOlOuuu050OwoCCCCAAAJeEzB37yPW4kWudUvHpyCAAAIIIIAAAggggEBpCbAC1KPzrVd5Xn311S1uUqRXgK5VG0Zkk/w87LDDUknTiooKj46abiGAAAIIlLpAcPhw9wgMQwJ77uVefCIjgAACCCCAAAIIIICAJwVYAerJafm6U0ceeaT069dP/vznP8vs2bPz7mnnzp3lzDPPlPHjx+cdg4YIIIAAAgi0hkBgxN4iHTqIbNni+OUCw0eK2amT43EJiAACCCCAAAIIIIAAAt4WIAHq7fmR/v37y9133y0zZsyQxx57TGbOnLn9uZ8tdb1Xr15ywgknyPHHHy/l5eUtVec8AggggAACbS6gN0EKf+d7Envy7473JXzc8Y7HJCACCCCAAAIIIIAAAgh4X4AEqPfnKNXD0aNHi37V1tbKrFmzUq8NGzZIdXW1bN68OZXg7KRWtXTs2FEGDBggY8aMYZf3IplbuokAAgggsKNA6KhjJPHeFLGWL9vxRAFfBQ8+VAIDBhYQgaYIIIAAAggggAACCCBQrAIkQIts5vRKTr2Lu35REEAAAQQQ8KOAEQxK5OJLpeaaq0S2bS14iGa//lJ2+hkFxyEAAggggAACCCCAAAIIFKcAmyAV57zRawQQQAABBHwtYFZ2l/JLLhNp176gcZq79ZbIRZeKvrWeggACCCCAAAIIIIAAAqUpQAK0NOedUSOAAAIIIOB5gcDAQVJx7fViqmda51MCo/eR8quuEVNtBkhBAAEEEEAAAQQQQACB0hXgFvjSnXtGjgACCCCAgOcFzO5qJejvbpD4Ky9J7OWXsrol3ui5s4TH/0BCY/fz/PjoIAIIIIAAAggggAACCLgvQALUfWOugAACCCCAAAIFCKR2hj/2eAkd/W1JzJwhyVmfirVksVhVG0TicZFIRPQt84H+AyQwarQE9hgihslNLgWQ0xQBBBBAAAEEEEAAAV8JkAD11XQyGAQQQAABBPwrYITDEtpv/9TLv6NkZAgggAACCCCAAAIIIOC0AMsjnBYlHgIIIIAAAggggAACCCCAAAIIIIAAAgh4RoAEqGemgo4ggAACCCCAAAIIIIAAAggggAACCCCAgNMCJECdFiUeAggggAACCCCAAAIIIIAAAggggAACCHhGgASoZ6aCjiCAAAIIIIAAAggggAACCCCAAAIIIICA0wIkQJ0WJR4CCCCAAAIIIIAAAggggAACCCCAAAIIeEaABKhnpoKOIIAAAggggAACCCCAAAIIIIAAAggggIDTAiRAnRYlHgIIIIAAAggggAACCCCAAAIIIIAAAgh4RoAEqGemgo4ggAACCCCAAAIIIIAAAggggAACCCCAgNMCJECdFiUeAggggAACCCCAAAIIIIAAAggggAACCHhGgASoZ6aCjiCAAAIIIIAAAggggAACCCCAAAIIIICA0wIkQJ0WJR4CCCCAAAIIIIAAAggggAACCCCAAAIIeEaABKhnpoKOIIAAAggggAACCCCAAAIIIIAAAggggIDTAiRAnRYlHgIIIIAAAggggAACCCCAAAIIIIAAAgh4RoAEqGemgo4ggAACCCCAAAIIIIAAAggggAACCCCAgNMCJECdFiUeAggggAACCCCAAAIIIIAAAggggAACCHhGgASoZ6aCjiCAAAIIIIAAAggggAACCCCAAAIIIICA0wIkQJ0WJR4CCCCAAAIIIIAAAggggAACCCCAAAIIeEaABKhnpoKOIIAAAggggAACCCCAAAIIIIAAAggggIDTAiRAnRYlHgIIIIAAAggggAACCCCAAAIIIIAAAgh4RiDomZ7QEQQQQAABBBBAwIcC9rZtYm3cKJJMiFFeIUbXrj4cJUNCAAEEEEAAAQQQQMC7AiRAvTs39AwBBBBAAAEEilQg+dVciU95V5KfzRK7asOOowgEJNh7d7GGDJXE6H1EKit3PM9X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evvttx1ri1k46eqrr64R77rrrpNZWb568XrNt5QUBBBAAAEEEEAAAQQQQAABBBBAAAEEclOgXhKgFXRnnXWWdtttN40ZM0bffPNNxea4P2fPnh0b7Xnrrbfqueee09SpU+PWi7exf//+evzxx7XzzjvH251R20xy1iRrnSo+X/xLarY7eR6n2kscBBBAAAEEEEAAAQQQQAABBBBAAAEE3BRwfQp89cYPHDhQJrl58cUXb3Nk5oYNG2KrySeT/Lzwwgv12WefZUXys7oNrxFAAAEEEEAAAQQQQAABBBBAAAEEEEDAWYF6T4Ca5ptV4idPnqw33nhDnTp1cqRH7du312uvvaa77747Ft+RoARBAAEEEEAAAQQQQAABBBBAAAEEEEAAgawWaJAEaIXYAQccEFugyEyJT6eMHTtWc+fO1UEHHZROGI5FAAEEEEAAAQQQQAABBBBAAAEEEEAAgRwTiH/DyHrsZIsWLfTEE0/o8MMP1/nnn6+1a9cmfHYzevT+++/XwQcfnPAxVEQAAQQQQAABBBBAINMFVm+U5i6u2spwpOprXjkvYK+9KredvfYQlAxeo9V5VCIigAACCCCQAQINngA1BpFIROvWrUuKw6ws/8orr8jcU5SCAAIIIIAAAggggEAuCSxcKt3xUi71KDv68uYX0r2vu9vW606Sdurq7jmIjgACCCCAAAJVBRp0Crxpypw5czRkyBCdd955SY3+3LJli/baay/dfPPNCgaDVXvFKwQQQAABBBBAAAEEEEAAAQQQQAABBBBAwBZosBGgoVBIN954oyZNmiTzPJVSUlKiK664Qk8++aQeeugh7brrrqmE4RgEEEAAAQQQQAABBBBAAAEEEHBA4O5xkrmdRLLlisekZYnfES/Z8NRHAIE8F2iQBOi3336rU089VbNmzXKE/8svv9See+6pq666Kvbwer2OxCUIAggggAACCCCAAAIIIIAAAggkLtCsUeJ1K9f0WpVf8RwBBBBwVqBeE6BR+2ugu+66KzZq04zeTKR07NhR3bt310cffVRndTOKdOLEiXrrrbf0+OOPq0uXLnXWZycCCCCAAAIIIIAAAvks8PvDpCF9fxPwNPjNsX5rC88QQAABBBBAAAEnBeotAbp06VKdfvrpeuONNxJu/9FHH61//vOfat68eWyq/HXXXRdbMKmuACZRahZGMqvDH3/8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kqJjUswCAQQQQAABBBBAIOIEVJLs7k9F3LAjfsC3jRdRfygIIIAAAgggEF0CJED7XU/1eP/cuXPlwQcf7HeGlwgggAACCCCAAAIIIIAAAggggAACCCAQaQKRvYCnidrf+c53TIxOaAQQQAABBBBAAAEEEEAAAQQQQAABBBCwQoAEqBXK9IEAAggggAACCCCAAAIIIIAAAggggAACtgiQALWFnU4RQAABBBBAAAEEnCZQ2FritCExHgQQQAABBBBAAAEDBEiAGoBICAQQQAABBBBAAIHIFmhxtcr3j/9c0huzInsijB4BBBBAAAEEEEBggAAJ0AEkHEAAAQQQQAABBBCINYFFWaultL1cJqfMibWpM18EEEAAAQQQQCDqBUiARv0lZoIIIIAAAggggAACvgQKWoplde4mT5Xj1adlf+mbvqpzDgEEEEAAAQQQQCDCBEiARtgFY7gIIIAAAggggAACxgpMS02STnfXxaDT0+ZLR3fnxdd8gQACCCCAAAIIIBDZAiRAI/v6MXoEEEAAAQQQQACBMASOV5+S18sP94lQ2Fosq3I29DnGCwQQQAABBBBAAIHIFSABGrnXjpEjgAACCCCAAAIIhCHQ3dMtCcn6a34uzn5OKtqrwohOUwQQQAABBBBAAAGnCJAAdcqVYBwIIIAAAggggAAClgpszn9RMpqydfts7W6TWWkLdc9xEAEEEEAAAQQQQCCyBEiARtb1YrQIIIAAAggggAACBgg0dDVKYuYyn5FeLH5FztQl+6zDSQQQQAABBBBAAAHnC5AAdf41YoQIIIAAAggggAACBgskZSyX2s56v1ETUmZLT0+P33pUQAABBBBAAAEEEHCuAAlQ514bRoYAAggggAACCCBggkBWU46sz98eUOQzdedld/GrAdWlEgIIIIAAAggggIAzBUiAOvO6MCoEEEAAAQQQQAABkwSmpCSK2gAp0DIrfaG0uFoDrU49BBBAAAEEEEAAAYcJkAB12AVhOAgggAACCCCAAALmCRwsPypHq04E1UF5e6UsyX4+qDZURgABBBBAAAEEEHCOAAlQ51wLRoIAAggggAACCCBgokCXu0umpSaF1MOqnA1S2FoSUlsaIYAAAggggAACCNgrQALUXn96RwABBBBAAAEEELBI4LncLZLbUhBSbx3uTpmROi+ktjRCAAEEEEAAAQQQsFeABKi9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khVLO6RvnRIgQIAAAQIECBAgQIAAAQIEylVAALRcV8a4Kk5gzvJ5MWj0bzps3FOWfBC/efe2DutfxwQIECBAgAABAgQIECBAgACBchSwC3w5rooxVaRAzy7rx7OHPVTQsS9buizmzZ/X1GbPnj1jww03zNt+107+l84LpJAAAQIECBAgQIAAAQIECBCoOQHRkppbchMulsB6XXrEVl36FLT5pbE0ui/55/+mvXr0io3W26ig7WuMAAECBAgQIECAAAECBAgQIFDtAi6Br/YVNj8CBAgQIECAAAECBAgQIECAAAECNSwgAFrDi2/qBAgQIECAAAECBAgQIECAAAECBKpdQAC02lfY/AgQIECAAAECBAgQIECAAAECBAjUsIAAaA0vvqkTIECAAAECBAgQIECAAAECBAgQqHYBAdBqX2HzI0CAAAECBAgQIECAAAECBAgQIFDDAgKgNbz4pk6AAAECBAgQIECAAAECBAgQIECg2gUEQKt9hc2PAAECBAgQIECAAAECBAgQIECAQA0LCIDW8OKbOgECBAgQIECAAAECBAgQIECAAIFqFxAArfYVNj8CBAgQIECAAAECBAgQIECAAAECNSwgAFrDi2/qBAgQIECAAAECBAgQIECAAAECBKpdQAC02lfY/AgQIECAAAECBAgQIECAAAECBAjUsIAAaA0vvqkTIECAAAECBAgQIECAAAECBAgQqHYBAdBqX2HzI0CAAAECBAgQIECAAAECBAgQIFDDAgKgNbz4pk6AAAECBAgQIECAAAECBAgQIECg2gUEQKt9hc2PAAECBAgQIECAAAECBAgQIECAQA0LCIDW8OKbOgECBAgQIECAAAECBAgQIECAAIFqFxAArfYVNj8CBAgQIECAAAECBAgQIECAAAECNSwgAFrDi2/qBAgQIECAAAECBAgQIECAAAECBKpdQAC02lfY/AgQIECAAAECBAgQIECAAAECBAjUsIAAaA0vvqkTIECAAAECBAgQIECAAAECBAgQqHYBAdBqX2HzI0CAAAECBAgQIECAAAECBAgQIFDDAgKgNbz4pk6AAAECBAgQIECAAAECBAgQIECg2gUEQKt9hc2PAAECBAgQIECAAAECBAgQIECAQA0LCIDW8OKbOgECBAgQIECAAAECBAgQIECAAIFqFxAArfYVNj8CBAgQIECAAAECBAgQIECA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ECBQLQICoGW0kjvuuGPW0YwcOTJrfksz58yZE9kupd9rr71a2oR6BAgQIECAAAECBAgQIECAAAECBCpSQAC0jJbt4x//eNbRvPHGG1nzW5qZ6/i99967pU2oR4AAAQIECBAgQIAAAQIECBAgQKAiBQRAy2jZdtttt9hyyy0zRpQrgJlRMUfG66+/nrXEGaBZWWQSIECAAAECBAgQIECAAAECBAhUkYAAaJkt5mGHHZYxonQJ/OTJkzPyW5KxdOnSeO655zKq7rLLLrHxxhtn5MsgQIAAAQIECBAgQIAAAQIECBAgUE0CAqBltpqHH354xogaGhrizjvvzMhvScbDDz8c8+bNy6h63HHHZeTJIECAAAECBAgQIECAAAECBAgQIFBtAgKgZbaie+yxR3zsYx/LGNXjjz8eY8aMycjPl5E2P7rnnnsyqqTL7D//+c9n5MsgQIAAAQIECBAgQIAAAQIECBAgUG0CXattQtUwn1NPPTV+/vOfrzWVFStWxLnnnhs33nhjbLHFFmuVZXuybNmyOO+882Lu3LkZxensz65dC7v03/3ud6Nbt24Zfclon0BjY2OkM4BT6tSpU3Tu7G8W7RN1dLkLpPc6r/VyXyXjK4RAeq2vSum9Pb3uJQLVKrDq84zXerWusHmtElj1Wl/1vEuXLqse+pdAVQqk76rpde+1XpXLW1aTSq+z9qZOKxtpfyvtHYXjMwTOOuusePXVVzPyt9lmm7joooti9913zyhblTF9+vTo169fDB8+fFXW6n833XTT+N3vfhfrrbfe6rz2PEj3Js12lml72nTsRwILFiyI9957rylj8803j7T+EoFqFhAArebVNbc1BSZMmBALFy5sykq/03v06LFmsccEqkogfd1IX5IFQKtqWU0mi0BdXV2k/RtS6tWrV6R9FyQC1SwgAFrNq1uec/v3f//32Geffdo0OAHQNrEV/6CJEyfGN7/5zaivr8/oLJ29+eUvfzmOPvro2HnnnVefFTht2rR49NFH44EHHlj9pWrNg7t37x5XX311m18sa7blcWkEnnnmmTjttNOaOjv55JObzgIuTc96IUCAAIFiCqSrPf761782dZFuc7PDDjsUszttEyBAgEAJBNKJKJ/73OeaejrwwAPbvI9DCYaqCwIECNScQGGvg645vuJNePvtt4/zzz8/LrnkkqZTytfsKQVFH3zwwaafFAzt3bt3zJ8/P9KO77lSurSub9++gp+5gOQTIECAAAECBAgQIECAAAECBAhUpYAAaBkv6xe/+MWm4Oell16aEQRdNewUDE1/aVxX+uEPfxiHHnrouqopJ0CAAAECBAgQIECAAAECBAgQIFBVAgKgZb6cRxxxRNOmR4MGDYpJkya1erTpkrp0CfXBBx/c6mMdQIAAAQIECBAgQIAAAQIECBAgQKDSBQRAK2AF99tvv7jjjjvi3nvvjUceeSSmTJmyzlGny+JPOeWUOPLII+3Itk4tFQgQIECAAAECBAgQIECAAAECBKpVQAC0Qla2W7duceKJJzb9jBs3Ll566aWmS99nz54daafwtEP4dtttt/pnp512sqNshaytYRIgQIAAAQIECBAgQIAAAQIECBRPQAC0eLZFa3mXXXaJ9CNVv0DPnj1X7wy82WabVf+EzZAAAQI1ItCnT5/V7+/pj5wSAQIECFS+QNqgNt2CLKWtttqq8idkBgQIEKgigU6NK1MVzcdUCBAgQIAAAQIECBAgQIAAAQIECBAgsFqg8+pHHhAgQIAAAQIECBAgQIAAAQIECBAgQKDKBARAq2xBTYcAAQIECBAgQIAAAQIECBAgQIAAgY8EBEA/svCIAAECBAgQIECAAAECBAgQIECAAIEqExAArbIFNR0CBAgQIECAAAECBAgQIECAAAECBD4SEAD9yMIjAgQIECBAgAABAgQIECBAgAABAgSqTKBrlc3HdAhUtMCcOXPi+eefj0mTJjX9TJ48OaZNmxYbbLBBbLHFFk0/n/jEJ+KII46IzTffvKLnavAECBCoBYG6urp466234p133olhw4bF9OnTY+HChbFgwYLo2rVrbLTRRrHxxhvHDjvsEPvuu2988pOfjO23374WaMyRAAECNSFwzz33xBNPPLHWXM8888zYb7/91srzhAABAgSKK9CpcWUqbhdaJ0BgXQKLFy+OIUOGxNChQ2Pp0qXrqh6dOnWK/fffP0455ZTYe++911lfBQIECBAorcDcuXPjoYceavpJf9xqTUpB0BNPPDEOPPDA1hymLgECBAiUmUD6w9fpp58eDQ0Na43s0ksvjc997nNr5XlCgAABAsUVEAAtrq/WCaxT4A9/+EPcdNNNMW/evHXWbV6hS5cu8a1vfSu+8Y1vRHosESBAgEDHCzz99NMxaNCg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84QAAQIEKkdAALRy1spIK1gg16XouTZHau1Um/91etXxzgBdJeFfAgQIdKxA+kPV5ZdfHunsz2wp3Uvu7LPPjqOPPjpbsTwCBAgQKJHA22+/HXfffXdGb+eee26kIKhEgAABApUpIABametm1BUmkCsQOXPmzILMJFc7vXr1Kkj7GiFAgACBtgvMnz8/zj///HjnnXeyNtKjR4/o169fpEsrJQIECBDoOIHFixfHJZdcEg0NDWsN4rOf/WzsvPPOMW3atLXy1/Wk+e7xq+qn/Gxtpe8MG2644apq/iVAgACBAgoIgBYQU1MEcgmkXeD79OmTsdNvrp1/c7WTK3/69OlZi3yAysoikwABAiUTmDJlSvz4xz+OyZMnZ+1zs802iyuuuCL22GOPrOUyCRAgQKB0AlOnTs0amHzhhRci/RQqDRw4MGtT6RYo6VYoEgECBAgUXsAu8IU31SKBrAI77bRTRn6uwGVGxXVkZGsn/QU5BV0lAgQIEOgYgeHDh8dpp52WM/i54447xuDBgwU/O2Z59EqAAAECBAgQIFBDAgKgNbTYptqxAtkCoOkym4ULF7Z7YB988EFGG3vuuWd06tQpI18GAQIECBRf4Lnnnoszzzwz5s2bl7WzAw44IG644YbYaqutspbLJECAAAECBAgQIECgcAICoIWz1BKBvALpTJ9saeTIkdmyW5w3Z86cjEvr08F77bVXi9tQkQABAgQKJ5CCnz//+c8jbXyULR1zzDExYMCAcJ/mbDryCBAgQIAAAQIECBReQAC08KZaJJBV4OMf/3jW/DfeeCNrfkszcx2/9957t7QJ9QgQIECgQAIvvfRS04ZGK1asyNri6aefHj/60Y+iS5cuWctlEiBAgAABAgQIECBQeAGbIBXeVIsEsgrstttuseWWW0bz+3XmCmBmbSRL5uuvv54l1xmgWVFkEiBAoIgC6f34Zz/7WdTX12f00q1bt+jbt28cdthhGWUyCBAgQKA8BHbZZZd46qmnCjaYtHFSuiKgebrooosi7SzfPPnjWHMRzwkQIFA4AQHQwllqicA6BdIX36FDh65VL10Cn3YH3nbbbdfKb8mTpUuXRrrUsnlKH9423njj5tmeEyBAgECRBKZNmxY//elPs172vv7660f//v1jv/32K1LvmiVAgACBQgik++d37969EE01tdG1a/av2ym/kP0UbMAaIkCAQBULuAS+ihfX1MpP4PDDD88YVENDQ9x5550Z+S3JePjhh7NusHHccce15HB1CBAgQKAAAumMzwsvvDAWLVqU0Vr6gjto0CDBzwwZGQQIECBAgAABAgRKJyAAWjprPRGIPfbYIz72sY9lSDz++OMxZsyYjPx8GWnzo3vuuSejSrrM/vOf/3xGvgwCBAgQKI7ArbfeGsOHD8/aeLrf5z777JO1TCYBAgQIECBAgAABAqUREAAtjbNeCKwWOPXUU1c/XvUgbZZx7rnnxsyZM1dl5f132bJlcd5558XcuXMz6qWzP3NdbpNRWQYBAgQItEtg0qRJWf8YlRr98pe/HEcddVS72ncwAQIECBAgQIAAAQLtF8h+U5L2t6sFAgRyCKT7gO6///7x6quvrlVj1qxZccYZZ0S6Kfruu+++VtmaT9ImSv369Yt079DmadNNN40vfelLzbM9J0CAAIEiCaRbmKRbmTRPPXr0iJ122ikeeuih5kXtfv5//s//ifR+LxEgQIAAAQIECBAg0DIBAdCWOalFoKACZ511Vnzzm9/M2Cl46tSpcdpppzWdNXT00UfHzjvvHJ07//NE7bTBxqOPPhoPPPBALFy4MGM86T5zl1xySay33noZZTIIECBAoPAC6T37iSeeyNpwOlP/uuuuy1rW3syPf/zjAqDtRXQ8AQIECBAgQIBATQkIgNbUcptsuQhsv/32cf755zcFLBsbG9caVtpM48EHH2z6SZey9+7dO+bPnx9px/dcKe1Y2bdvX/eZywUknwABAkUQeOqppyLdwkQiQIAAAQIECBAgQKC8BQRAy3t9jK6KBb74xS9GCn5eeumlTf9mm2oKhqZL3teVfvjDH8ahhx66rmrKCRAgQKCAAhMmTChga5oiQIAAAQIECBAgQKBYAgKgxZLVLoEWCBxxxBGxxRZbxKBBgyJtpNHatMMOOzRdMn/wwQe39lD1CRAgQKCdAgKg7QR0OAECBAgQIECAAIESCQiAlghaNwRyCey3335xxx13xL333huPPPJITJkyJVfV1fnpsvhTTjkljjzyyOjSpcvqfA8IECBAoDQCaeOjiRMnlqYzvRAgQIAAAQIECBAg0C6BTisvwV37BoTtas7BBAi0V2DcuHHx0ksvNV36Pnv27FiwYEFsvvnmsd12263+STsLpx2GJQIECBAgQIAAAQIECBAgQIAAgfwCAqD5fZQSIECAAAECBAgQIECAAAECBAgQIFDBAp0reOyGToAAAQIECBAgQIAAAQIECBAgQIAAgbwCAqB5eRQSIECAAAECBAgQIECAAAECBAgQIFDJAgKglbx6xk6AAAECBAgQIECAAAECBAgQIECAQF4BAdC8PAoJECBAgAABAgQIECBAgAABAgQIEKhkAQHQSl49YydAgAABAgQIECBAgAABAgQIECBAIK+AAGheHoUECBAgQIAAAQIECBAgQIAAAQIECFSygABoJa+esRMgQIAAAQIECBAgQIAAAQIECBAgkFdAADQvj0ICBAgQIECAAAECBAgQIECAAAECBCpZQAC0klfP2AkQIECAAAECBAgQIECAAAECBAgQyCsgAJqXRyEBAgQIECBAgAABAgQIECBAgAABApUsIABayatn7AQIECBAgAABAgQIECBAgAABAgQI5BUQAM3Lo5AAAQIECBAgQIAAAQIECBAgQIAAgUoWEACt5NUzdgIECBAgQIAAAQIECBAgQIAAAQIE8goIgOblUUiAAAECBAgQIECAAAECBAgQIECAQCULCIBW8uoZOwECBAgQIECAAAECBAgQIECAAAECeQUEQPPyKCRAgAABAgQIECBAgAABAgQIECBAoJIFBEArefWMnQABAgQIECBAgAABAgQIECBAgACBvAICoHl5FBIgQIAAAQIECBAgQIAAAQIECBAgUMkCXSt58MZOgAABAgQIECBQ2wLPPvts1NXV5UTo1KlTHHLIIdG9e/ecdYpVUF9fH2l8jY2NObs46KCDYoMNNshZXsiCq6++OubPn7+6ya233jpOPfXU1c89IECAAAECBAhUq0CnlR/Icn8iq9ZZmxcBAgQIECBAgEBVCFxyySXRt2/fvHM599xzo3///nnrFKPwvPPOiyuuuCJn00ceeWQ88sgjkYK0xU633nprnHLKKWt1s++++8brr7++Vp4nBAgQIECAAIFqFBAArcZVNScCBAgQIECAQI0IrFixIg477LD429/+lnPGnTt3jqeeeioOPfTQnHUKXZACm0cffXTOsz+33XbbeOONN2LzzTcvdNcZ7U2dOjX22muvtc7+TJUEQDOoZBAgQIAAAQJVKuAeoFW6sKZFgAABAgQIEKgFgS5dusRdd90VG2+8cc7pNjQ0xEknnRTz5s3LWaeQBe+//35885vfzBn8TGP+7W9/W5LgZ5pXusx9zUvfCzlXbREgQIAAAQIEKkFAALQSVskYCRAgQIAAAQIEcgrssMMOcf311+csTwWTJk2K73//+3nrFKJw+fLl8fWvfz3mzJmTs7kLL7yw6b6kOSsUsCDd9zOdjSoRIECAAAECBGpZQAC0llff3AkQIECAAAECVSJw/PHHxze+8Y28sxk6dGjT2aJ5K7Wz8JxzzolXXnklZytf/OIX4/zzz89ZXsiCwYMHx49+9KNCNqktAgQIECBAgEBFCrgHaEUum0ETIECAAAECBAg0F1iwYEF88pOfjAkTJjQvWv18o402irfeeit23HHH1XmFenD//ffHV7/61ZzNpV3X33zzzejTp0/OOoUquP322+Pkk0/OeRl+6sc9QAulrR0CBAgQIECg3AWcAVruK2R8BAgQIECAAAECLRJIwc2777470j02c6UUJE1niqbNkwqZ3n333aaAY64200ZM99xzT0mCn0OGDGna8b2xsTHXcOQTIECAAAECBGpKQAC0ppbbZAkQIECAAAEC1S3wmc98Jvr27Zt3ks8//3xcfvnleeu0pnDp0qXxta99LVJwNVdKY0q71Rc7pXt+pgBv2vhJIkCAAAECBAgQ+KeAS+C9EggQIECAAAECBKpKIJ3d+bnPfS5efPHFnPPq2rVrvPDCC3HAAQfkrNPSgrTL+o033pizegp8Pvnkk5HOAi1WSru8p0veH3jggRZ34RL4FlOpSIAAAQIECFS4QPE+hVU4jOETIECAAAECBAhUpkC6BD5dCp8uic+V6uvr48QTT4xFixblqtKi/NRPvuBnut9nuvS9mMHPdF/R/fffv1XBzxZNTiUCBAgQIECAQJUICIBWyUKaBgECBAgQIECAwEcCO+20U/zqV7/6KCPLo7Fjx8b//M//ZClpWdbIkSPjtNNOy1k5BT1TgDRtflSsdNNNN8WnP/3pSPcglQgQIECAAAECBLILCIBmd5FLgAABAgQIECBQ4QLpXpjHH3983lncfPPN8dBDD+Wtk61w8eLFTTu+5zuD9LzzzosvfOEL2Q5vd166vD8FPr/3ve9FugepRIAAAQIECBAgkFtAADS3jRICBAgQIECAAIEKF7j++utjhx12yDuL7373uzFt2rS8dZoXpjM/R4wY0Tx79fNDDjkkLrrootXPC/Vg3LhxTYHXz372s/HSSy/lbTbd5/Rb3/pW3joKCRAgQIAAAQK1ICAAWgurbI4ECBAgQIAAgRoV2HjjjeOuu+7Kew/OWbNmNQUKGxsbW6SUzhpNbeZKm2++eQwZMiTSvUgLldImR+ly/T333DPuv//+dTa72WabxWOPPdZ0hmiuyp06dcpVJJ8AAQIECBAgUFUCAqBVtZwmQ4AAAQIECBAg0FwgnY3505/+tHn2Ws8ff/zxuO6669bKy/bkrbfeih/+8IfZipryUlDxjjvuiI997GM567SlIF3yfu2110ZdXd06D//Xf/3XePnll+Pwww9fZ10VCBAgQIAAAQK1ICAAWgurbI4ECBAgQIAAgRoX6NevXxx44IF5Fc4///wYNWpUzjrpXpvpnqL57rn54x//OI488sicbRSzoHv37nHxxRfHP/7xj9h1112L2ZW2CRAgQIAAAQIVJSAAWlHLZbAECBAgQIAAAQJtEUj3w0w7sm+wwQY5D1+yZEmcdNJJUV9fn7XOueeeG2nn91wpbUp02WWX5Souav5BBx0Ub7zxRlxwwQXRrVu3ovalcQIECBAgQIBApQkIgFbaihkvAQIECBAgQIBAmwTSWZG//OUv8x6bzp7MFsR88skn8x6b7rk5dOjQSIHWUqbtt9++6ZL7F154Ifbaa69Sdq0vAgQIECBAgEDFCAiAVsxSGSgBAgQIECBAgEB7BdKu6F/72tfyNpMuI3/zzTdX15k7d258+9vfjnybJN12222RgpGlSptuumkMHDgwxowZ03TWaufOPtaXyl4/BAgQIECAQOUJ+KRUeWtmxAQIECBAgAABAu0QGDx4cGy33XY5W0iXwJ922mnR0NDQVOf000+PyZMn56yfdmc/+uijc5YXsiAFWa+44ooYP358pPuN9ujRo5DNa4sAAQIECBAgUJUCpb1GpyoJTYoAAQIECBAgQKCSBNLZk3feeWfTLumrgpzNx592Ub/xxhtjk002iSFDhjQvXv38gAMOaApIrs4o0oNtt9027rvvvjjmmGOiS5cuRepFswQIECBAgACB6hTotPJSnsbqnJpZESBAgAABAgQIEMgtkHZ979+/f84KKVCaUroEPltKwdHXX389dtppp2zFZZH397//PT7zmc9kHct+++0Xr732WtYymQQIECBAgACBahJwCXw1raa5ECBAgAABAgQItFjgoosuiv333z9n/RT4zBX8TAfdfPPNZR38zDkxBQQIECBAgACBGhMQAK2xBTddAgQIECBAgACBfwp069Yt7rnnnujVq1erSdJ9Qf/zP/+z1cc5gAABAgQIECBAoPQCAqClN9cjAQIECBAgQIBAmQjstttucc0117RqNOnS8SuvvLJVx6hMgAABAgQIECDQcQICoB1nr2cCBAgQIECAAIEyEPjOd77TtLlQS4ay0UYbxb333mv39ZZgqUOAAAECBAgQKBMBAdAyWQjDIECAAAECBAgQ6DiBm266KbbZZpt1DmDQoEGx6667rrOeCgQIECBAgAABAuUjIABaPmthJAQIECBAgAABAh0kkHZ033nnndfZ+/333x+NjY3rrKcCAQIECBAgQIBA+QgIgJbPWhgJAQIECBAgQIBABwlcfPHF8fzzz6+z97/85S+tvmfoOhtVgQABAgQIECBAoKgCAqBF5dU4AQIECBAgQIBAuQs888wzkQKgLU3nn39+vPXWWy2trh4BAgQIECBAgEAHCwiAdvAC6J4AAQIECBAgQKDjBGbMmBH/9V//FQ0NDS0exLJly+L444+PJUuWtPgYFQkQIECAAAECBDpOQAC04+z1TIAAAQIECBAg0IEC6V6eJ510UkybNq3Voxg5cmT86Ec/avVxDiBAgAABAgQIECi9gABo6c31SIAAAQIECBAgUAYCAwYMiHRPz1ypZ8+euYqa8m+44YZ4+OGH89ZRSIAAAQIECBAg0PECAqAdvwZGQIAAAQIECBAgUGKBF198MS644IKcvabgZ6qz7bbb5qyTCr7zne/E1KlT89ZRSIAAAQIECBAg0LECAqAd6693AgQIECBAgACBEgvMmTOn6R6e9fX1OXvu27dv/Ou//msMHjw4Z51UMGvWrPjmN78Z6XJ6iQABAgQIECBAoDwFBEDLc12MigABAgQIECBAoEgCJ598ckycODFn6/vss0+cffbZTeVHHnlknHjiiTnrpoInn3wyrrzyyrx1FBIgQIAAAQIECHScgABox9nrmQABAgQIECBAoMQC1157bd77dnbt2jVuvfXW6Nat2+qRpWO22mqr1c+zPfjZz34Wr7/+erYieQQIECBAgAABAh0sIADawQugewIECBAgQIAAgdIIvPrqq/GTn/wkb2fp0vdPfepTa9XZbLPNmoKia2U2e7J8+fI44YQTYvHixc1KPCVAgAABAgQIEOhoAQHQjl4B/RMgQIAAAQIECBRdYMGCBXHcccdFClTmSoccckikMzmzpX//93+PM844I1vR6rzRo0fH//zP/6x+7gEBAgQIECBAgEB5CAiAlsc6GAUBAgQIECBAgEARBb773e/GuHHjcvawySabxN133x1dunTJWWfAgAGx11575SxPBTfddFM88MADeesoJECAAAECBAgQKK2AAGhpvfVGgAABAgQIECBQYoG0k/vvfve7vL3eeOONsf322+ets/7668c999wT3bt3z1svBVunTJmSt45CAgQIECBAgACB0gkIgJbOWk8ECBAgQIAAAQIlFnj77bfXeVl62hX+a1/7WotG9slPfjIuueSSvHXnzJkTJ510UjQ0NOStp5AAAQIECBAgQKA0AgKgpXHWCwECBAgQIECAQIkFFi1aFMcee2wsXbo0Z8+77bZbXHfddTnLsxWcffbZcdhhh2UrWp339NNPx8CBA1c/94AAAQIECBAgQKDjBARAO85ezwQIECBAgAABAkUU+MEPfhCjRo3K2UO6lH3IkCHRq1evnHWyFXTu3DnuuOOOSPcNzZfSjvJp53mJAAECBAgQIECgYwUEQDvWX+8ECBAgQIAAAQJFEEgByjvvvDNvy5deemnst99+eevkKtxuu+3i+uuvz1XclF9XVxcnnHBCpDNRJQIECBAgQIAAgY4TEADtOHs9EyBAgAABAgQIFEEgnfV5+umn5235C1/4QqRL2duTjjvuuDjxxBPzNjF27Ng488wz89ZRSIAAAQIECBAgUFwBAdDi+mqdAAECBAgQIECghAJLliyJr3/963nPutxiiy2aLmHv1KlTu0f261//Onbccce87dx6661x33335a2jkAABAgQIECBAoHgCAqDFs9UyAQIECBAgQIBAiQXOOuuseOedd/L2mgKSW2+9dd46LS3caKONmi61T/cFzZdOPfXUmDRpUr4qyggQIECAAAECBIokkP+TWpE61SwBAgQIECBAgACBQgvce++9MXjw4LzNnnHGGfGlL30pb53WFh5yyCFx3nnn5T1s7ty58Y1vfCMaGhry1lNIgAABAgQIECBQeAEB0MKbapEAAQIECBAgQKDEAuPGjYvvfe97eXv9l3/5lxg4cGDeOm0t/MUvfhH7779/3sOfffbZ6N+/f946CgkQIECAAAECBAovIABaeFMtEiBAgAABAgQIlFBg+fLlceyxx8aCBQty9rr++uvHkCFDYr311stZpz0F3bp1i7vvvjt69uyZt5l+/frFK6+8kreOQgIECBAgQIAAgcIKCIAW1lNrBAgQIECAAAECJRb4yU9+Eq+99lreXgcNGhR777133jrtLdx9993jqquuyttMfX19nHDCCbFw4cK89RQSIECAAAECBAgUTkAAtHCWWiJAgAABAgQIECixwMMPPxzXXntt3l6/8pWvxA9+8IO8dQpVmDY7+vKXv5y3uXS5/g9/+MO8dRQSIECAAAECBAgUTkAAtHCWWiJAgAABAgQIECihwMSJE+Pb3/523h632WabuOWWW/LWKXThzTffHFtuuWXeZu+4444YOnRo3joKCRAgQIAAAQIECiMgAFoYR60QIECAAAECBAiUUCBdSn788cdH2l09V+rcuXPceeed0bt371xVipLfp0+fFgVdTzvttHj//feLMgaNEiBAgAABAgQIfCQgAPqRhUcECBAgQIAAAQIVInDBBRfEiy++mHe055xzThx++OF56xSr8KijjlrnZffz58+PE088MVasWFGsYWiXAAECBAgQIEBgpYAAqJcBAQIECBAgQIBARQk89thjMWDAgLxj/rd/+7e4+OKL89YpdmHaeGmPPfbI283zzz8fl156ad46CgkQIECAAAECBNon0KlxZWpfE44mQIAAAQIECBAgQIAAAQIECBAgQIBAeQo4A7Q818WoCBAgQIAAAQIECBAgQIAAAQIECBAogIAAaAEQNUGAAAECBAgQIECAAAECBAgQIECAQHkKCICW57oYFQECBAgQIECAAAECBAgQIECAAAECBRAQAC0AoiYIECBAgAABAgQIECBAgAABAgQIEChPAQHQ8lwXoyJAgAABAgQIECBAgAABAgQIECBAoAACAqAFQNQEAQIECBAgQIAAAQIECBAgQIAAAQLlKSAAWp7rYlQECBAgQIAAAQIECBAgQIAAAQIECBRAQAC0AIiaIECAAAECBAgQIECAAAECBAgQIECgPAUEQMtzXYyKAAECBAgQIECAAAECBAgQIECAAIECCAiAFgBREwQIECBAgAABAgQIECBAgAABAgQIlKeAAGh5rotRESBAgAABAgQIECBAgAABAgQIECBQAAEB0AIgaoIAAQIECBAgQIAAAQIECBAgQIAAgfIUEAAtz3UxKgIECBAgQIAAAQIECBAgQIAAAQIECiAgAFoARE0QIECAAAECBAgQIECAAAECBAgQIFCeAgKg5bkuRkWAAAECBAgQIECAAAECBAgQIECAQAEEBEALgKgJAgQIECBAgAABAgQIECBAgAABAgTKU0AAtDzXxagIECBAgAABAgQIECBAgAABAgQIECiAgABoARA1QYAAAQIECBAgQIAAAQIECBAgQIBAeQoIgJbnuhgVAQIECBAgQIAAAQIECBAgQIAAAQIFEBAALQCiJggQIECAAAECBAgQIECAAAECBAgQKE8BAdDyXBejIkCAAAECBAgQIECAAAECBAgQIECgAAICoAVA1AQBAgQIECBAgAABAgQIECBAgAABAuUpIABanutiVAQIECBAgAABAgQIECBAgAABAgQIFEBAALQAiJogQIAAAQIECBAgQIAAAQIECBAgQKA8BQRAy3NdjIoAAQIECBAgQIAAAQIECBAgQIAAgQIICIAWAFETBAgQIECAAAECBAgQIECAAAECBAiUp4AAaHmui1ERIECAAAECBAgQIECAAAECBAgQIFAAAQHQAiBqggABAgQIECBAgAABAgQIECBAgACB8hQQAC3PdTEqAgQIECBAgAABAgQIECBAgAABAgQKICAAWgBETRAgQIAAAQIECBAgQIAAAQIECBAgUJ4C/z9OT3L4MbaDzwAAAABJRU5ErkJggg==" width="50%" /></p>
<p><br /><br /><br /><br /><br /><br /><br /></p>
<p>Sometimes it is not so clear whether we are in a supervised or unsupervised problem. For example, we may have <span class="math inline">\(m &lt; n\)</span> observations with a response measurement and <span class="math inline">\(n-m\)</span> observations with no response. Why?</p>
<p><br /></p>
<p>In this case, we want a method that can incorporate all the information we have.</p>
</div>
<div id="regression-vs.classification" class="section level1">
<h1><span class="header-section-number">3</span> Regression vs.Classification</h1>
<p>Variables can be either quantitative or categorical.</p>
<p><br /><br /></p>
<p>Examples </p>
<p>Age</p>
<p><br /></p>
<p>Height</p>
<p><br /></p>
<p>Income</p>
<p><br /></p>
<p>Price of stock</p>
<p><br /></p>
<p>Brand of product purchased</p>
<p><br /></p>
<p>Cancer diagnosis</p>
<p><br /></p>
<p>Color of cat</p>
<p><br /></p>
<p>We tend to select statistical learning methods for supervised problems based on whether the response is quantitative or categorical.</p>
<p><br /></p>
<p>However, when the predictors are quantitative or categorical is less important for this choice.</p>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
